Ты — **владелец** репозитория `https://github.com/ferixdi-png/TRT`. Действуешь **автономно**, без вопросов. Твоя цель — довести TRT до **идеального продакшн-бота-интегратора** уровня “лучший аналог Syntx” и “лучший интегратор Kie AI”.

### 0) Нерушимые правила

* **main всегда зелёный**: никаких полурабочих коммитов.
* Никаких “Accept both changes” без понимания: запрещены merge markers.
* **Секреты не попадают в логи** (маска/редакция всегда).
* Платежи **предсказуемы**: idempotency, rollback, отсутствие двойных списаний.
* UX **без тупиков**: пользователь всегда понимает “что дальше” и “как исправить”.
* Каждый фикс = **минимальный безопасный diff** + **тест, который падал до фикса**.
* Все изменения: **commit + push в main сразу** (PR только если нужно, но конечное состояние — main).

### 1) Обязательные ENV ключи (фиксируем как контракт)

Проект должен стартовать и валидироваться только с этими ключами:
`ADMIN_ID, BOT_MODE, DATABASE_URL, DB_MAXCONN, KIE_API_KEY, PAYMENT_BANK, PAYMENT_CARD_HOLDER, PAYMENT_PHONE, PORT, SUPPORT_TELEGRAM, SUPPORT_TEXT, TELEGRAM_BOT_TOKEN, WEBHOOK_BASE_URL`

Сделай:

* `docs/env.md` (таблица: ключ → назначение → пример формата → где используется).
* `app/utils/startup_validation.py`: явная проверка наличия/валидности.
* Логи при старте: показывать только факт “OK”, **без значений**.

### 2) Что значит “идеальный бот” (Definition of Done)

Проект считается идеальным только если:

* CI: `compileall + pytest` ✅
* Render: deploy ✅, `/health` ✅, webhook register ✅
* В боте ручной smoke проходит:

  1. /start
  2. выбор модели
  3. ввод корректных данных
  4. генерация результата
  5. неправильный ввод → понятная ошибка + подсказка + кнопка “назад”
  6. free tier работает и ограничен корректно
  7. paid flow: резерв/списание/отмена/повтор → без дублей
* Все модели: 100% корректно спрашивают нужные поля и не ломают wizard.

### 3) UX / Design стандарт (делаем “дорого и понятно”)

Твоя цель — ощущение “продукт, а не бот”.
Сделай UI правила и приведи весь wizard к ним:

**Компоненты:**

* Единый “Model Card”:

  * Название
  * Коротко “что делает”
  * Цена (руб/запрос)
  * Пример input
  * Кнопка: “Запустить”
* Единый “Input Step”:

  * Заголовок: что нужно
  * 1–2 строки примера
  * Ошибки: конкретно что не так
  * Кнопки: `⬅️ Назад` `❌ Отмена` `✅ Продолжить`
* Единый “Result View”:

  * Сверху: статус + request_id
  * Ниже: результат (файл/ссылка/текст)
  * Кнопки: “Сделать ещё раз”, “Выбрать другую модель”

**Тексты:**

* Без канцелярита. Коротко. По делу.
* Всегда писать “что нужно сделать” (а не “ошибка произошла”).

**Запрещено:**

* тупики без кнопки назад
* скрытые обязательные поля
* “неизвестная ошибка” без request_id

### 4) Архитектурный контракт моделей (самое важное)

Сделай единый контракт модели, чтобы wizard был предсказуемым:

* Каждая модель должна иметь:

  * `id`
  * `type` (text/image/audio/video/utility)
  * `schema` (required/properties)
  * `examples`
  * `pricing`
  * `supports` (какие форматы принимает/выдаёт)
* Валидация schema до генерации.
* Wizard строится **только** из schema (никаких “магических исключений”).

Добавь тесты:

* “каждая enabled модель имеет schema required/properties”
* “wizard может построить flow без runtime ошибок”
* “missing required → корректный user error”

### 5) Платежи (уровень банка)

Нужно гарантировать:

* idempotency ключ на операцию (по request_id + user_id + model_id)
* если генерация отменена/упала → резерв/списание откатывается
* повтор “нажали два раза” → не двойная оплата
* тесты на cancel/error/retry

### 6) Webhook / Security

* `/health` всегда доступен
* path-based секрет маскируется в логах
* header fallback только при явном флаге env (и тест на это)
* ни один лог не содержит токены/секреты (добавь sanitization слой + тест)

### 7) CI как “охранник качества”

Обязательно:

* `python -m compileall -q .`
* `pytest -q`
* guard: запрещены `<<<<<<<`, `=======`, `>>>>>>>`
* guard: запрещены `print(` вне tests
* (опционально) mypy/ruff позже, но не ломай

### 8) Ветки: один рабочий main

Цель: **main — единственная правда**.
Сделай:

* `docs/branch_policy.md`: “работаем только через main”
* Удали remote ветки, кроме main (если есть доступ через gh cli).
* Если нет доступа — зафиксируй в отчёте, какие ветки и почему не удалил.

### 9) Процесс работы “итерациями”

Работаешь циклами по 5 задач.

Каждый цикл:

1. pull main
2. выбираешь самую критичную боль (Render crash/CI fail/UX тупик/оплата риск)
3. фикс + тест
4. прогон локально `compileall + pytest`
5. push main
6. Render deploy + smoke
7. обновляешь **две штуки**:

   * `docs/quality_log.md`
   * `~/Desktop/TRT_REPORT.md` (каждые 5 задач)

### 10) Отчёт (формат железно)

Файл: `~/Desktop/TRT_REPORT.md`

Структура:

* TL;DR (1–3 строки)
* 5 выполненных задач (чеклист)
* Команды, которыми проверял (`pytest`, `curl /health`, smoke steps)
* Доказательства: ссылки на коммиты + Render deploy отметка
* Риски/что осталось
* Следующие 5 задач (автоматически предлагаешь)

---

## ✅ Первая “пачка” задач (10 штук, выполняй подряд)

1. Починить `SyntaxError duplicate argument task_id_callback` в `app/payments/integration.py` + тест.
2. Добавить CI guard на merge markers + тест.
3. Стабилизировать `/health` и тест на него.
4. Вынести и задокументировать `docs/env.md` + startup_validation обязательных ключей.
5. Внедрить sanitization логов (mask secrets) + тест.
6. Привести wizard к единому UX: кнопки back/cancel/continue на каждом шаге + тест на отсутствие тупиков.
7. Стандартизировать model schema контракт + тест “все enabled модели валидны”.
8. Оплаты: idempotency + rollback при cancel/error + тест.
9. E2E smoke тесты без реальных ключей (моки) + CI.
10. Документация “Syntx-grade parity checklist” + smoke сценарии.

---

Если Cursor не пушит — он обязан **сначала** починить пуш/права/remote (и зафиксировать в отчёте), иначе работа считается проваленной.

сам смотри самые важные ошибки и исправляй их в первую очередь а потом уже оставшиеся! пуш на гитхаб всех изменений если какие то конфликты решай сам