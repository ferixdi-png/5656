"""
KIE (Knowledge Is Everything) Telegram Bot
Enhanced version with KIE AI model selection and generation
"""

import logging
import asyncio
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters,
    ConversationHandler, CallbackQueryHandler
)
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes
import os
from dotenv import load_dotenv
from knowledge_storage import KnowledgeStorage
from translations import t, TRANSLATIONS
from kie_client import get_client
from kie_models import (
    KIE_MODELS, get_model_by_id, get_models_by_category, get_categories,
    get_generation_types, get_models_by_generation_type, get_generation_type_info
)
import json
import aiohttp
import aiofiles
import io
from io import BytesIO
import re
import platform
import random
import time
from asyncio import Lock
from typing import Optional
import threading

# Load environment variables FIRST
load_dotenv()

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

logger = logging.getLogger(__name__)

# Try to import PIL/Pillow
try:
    from PIL import Image
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False
    logger.warning("PIL/Pillow not available. Image analysis will be limited.")

# Try to import pytesseract and configure Tesseract path
try:
    import pytesseract
    OCR_AVAILABLE = True
    tesseract_found = False
    
    # Try to set Tesseract path
    # On Windows, check common installation paths
    # On Linux (Render/Timeweb), Tesseract should be in PATH
    if platform.system() == 'Windows':
        # Common Tesseract installation paths on Windows
        possible_paths = [
            r'C:\Program Files\Tesseract-OCR\tesseract.exe',
            r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe',
            r'C:\Users\{}\AppData\Local\Programs\Tesseract-OCR\tesseract.exe'.format(os.getenv('USERNAME', '')),
        ]
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                tesseract_found = True
                logger.info(f"Tesseract found at: {path}")
                break
    else:
        # On Linux, assume Tesseract is in PATH (installed via apt-get in Dockerfile)
        # Don't search PATH at import time - it can cause timeout
        # pytesseract will try to find tesseract automatically when needed
        logger.info("Tesseract should be in PATH (Linux). Will auto-detect when OCR is used.")
        # Assume it's available if we're on Linux (installed in Dockerfile)
        tesseract_found = True
    
    if not tesseract_found:
        logger.warning("Tesseract not found. OCR analysis will be disabled. Install tesseract-ocr package if needed.")
        OCR_AVAILABLE = False
    else:
        # Don't test Tesseract at import time - it can hang or timeout
        # Test will happen when OCR is actually needed
        logger.info("Tesseract OCR path configured. Will be tested when needed.")
except ImportError:
    OCR_AVAILABLE = False
    tesseract_found = False
    logger.warning("pytesseract not available. OCR analysis will be disabled.")

# Bot token from environment variable
BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')

# Admin user ID (can be set via environment variable)
try:
    admin_id_str = os.getenv('ADMIN_ID', '6913446846')
    if admin_id_str and admin_id_str != 'your_admin_id_here':
        ADMIN_ID = int(admin_id_str)
    else:
        ADMIN_ID = 6913446846  # Default fallback
except (ValueError, TypeError):
    ADMIN_ID = 6913446846  # Default fallback if invalid

# Price conversion constants
# Based on: 18 credits = $0.09 = 6.95 ‚ÇΩ
# NOTE: –¢–µ–ø–µ—Ä—å —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å config.settings –¥–ª—è —ç—Ç–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
CREDIT_TO_USD = 0.005  # 1 credit = $0.005 ($0.09 / 18)
USD_TO_RUB = 6.95 / 0.09  # 1 USD = 77.2222... RUB (calculated from 6.95 ‚ÇΩ / $0.09)

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
try:
    from bot_kie_services import pricing_service, storage_service, model_validator
    from bot_kie_utils import is_admin as is_admin_new
    NEW_SERVICES_AVAILABLE = True
except ImportError:
    NEW_SERVICES_AVAILABLE = False
    logger.warning("–ù–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã –Ω–µ –¥–æ—Å—Ç—É–ø–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å—Ç–∞—Ä–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è")

# Initialize knowledge storage and KIE client (will be initialized in main() to avoid blocking import)
storage = None
kie = None

# Store user sessions
user_sessions = {}


def get_admin_limits() -> dict:
    """Get admin limits data."""
    return load_json_file(ADMIN_LIMITS_FILE, {})


def save_admin_limits(data: dict):
    """Save admin limits data."""
    save_json_file(ADMIN_LIMITS_FILE, data)


def is_admin(user_id: int) -> bool:
    """Check if user is admin (main admin or limited admin)."""
    if user_id == ADMIN_ID:
        return True
    admin_limits = get_admin_limits()
    return str(user_id) in admin_limits


def get_admin_spent(user_id: int) -> float:
    """Get amount spent by admin (for limited admins)."""
    admin_limits = get_admin_limits()
    admin_data = admin_limits.get(str(user_id), {})
    return admin_data.get('spent', 0.0)


def get_admin_limit(user_id: int) -> float:
    """Get spending limit for admin (100 rubles for limited admins, unlimited for main admin)."""
    if user_id == ADMIN_ID:
        return float('inf')  # Main admin has unlimited
    admin_limits = get_admin_limits()
    admin_data = admin_limits.get(str(user_id), {})
    return admin_data.get('limit', 100.0)  # Default 100 rubles


def add_admin_spent(user_id: int, amount: float):
    """Add to admin's spent amount."""
    if user_id == ADMIN_ID:
        return  # Main admin doesn't have limits
    admin_limits = get_admin_limits()
    if str(user_id) not in admin_limits:
        return
    admin_limits[str(user_id)]['spent'] = admin_limits[str(user_id)].get('spent', 0.0) + amount
    save_admin_limits(admin_limits)


def get_admin_remaining(user_id: int) -> float:
    """Get remaining limit for admin."""
    limit = get_admin_limit(user_id)
    if limit == float('inf'):
        return float('inf')
    spent = get_admin_spent(user_id)
    return max(0.0, limit - spent)


def get_is_admin(user_id: int) -> bool:
    """
    Determine if user is admin, taking into account admin user mode.
    
    If admin is in user mode (admin_user_mode = True), returns False.
    Otherwise, returns True for admin, False for regular users.
    """
    if is_admin(user_id):
        # Check if admin is in user mode (viewing as regular user)
        if user_id in user_sessions and user_sessions[user_id].get('admin_user_mode', False):
            return False  # Show as regular user
        else:
            return True
    else:
        return False


def calculate_price_rub(model_id: str, params: dict = None, is_admin: bool = False) -> float:
    """Calculate price in rubles based on model and parameters."""
    if params is None:
        params = {}
    
    # Base prices in credits
    if model_id == "z-image":
        base_credits = 0.8
    elif model_id == "nano-banana-pro":
        # Price depends on resolution parameter
        # 1K/2K: 18 credits, 4K: 24 credits
        resolution = params.get("resolution", "1K")
        if resolution == "4K":
            base_credits = 24
        else:  # 1K or 2K
            base_credits = 18
    elif model_id == "seedream/4.5-text-to-image" or model_id == "seedream/4.5-edit":
        # Both Seedream models cost 6.5 credits per image
        # NOTE: Currently price is fixed regardless of quality (basic/high) or aspect_ratio
        # If API pricing changes based on quality (basic=2K, high=4K), update this calculation:
        # quality = params.get("quality", "basic")
        # base_credits = 6.5 if quality == "basic" else <higher_price_for_high>
        base_credits = 6.5
    elif model_id == "sora-watermark-remover":
        # Sora watermark remover costs 10 credits per use
        base_credits = 10
    elif model_id == "sora-2-text-to-video" or model_id == "sora-2-image-to-video":
        # Sora 2 text-to-video and image-to-video cost 30 credits per 10-second video with audio
        base_credits = 30
    elif model_id == "sora-2-pro-storyboard":
        # Sora 2 Pro Storyboard pricing:
        # 10 seconds: 150 credits ($0.75)
        # 15-25 seconds: 270 credits ($1.35)
        n_frames = params.get("n_frames", "10")
        n_frames_str = str(n_frames).strip()
        # Remove "s" suffix if present
        if n_frames_str.lower().endswith('s'):
            n_frames_str = n_frames_str[:-1].strip()
        
        if n_frames_str == "10":
            base_credits = 150  # 10 seconds
        elif n_frames_str in ["15", "25"]:
            base_credits = 270  # 15-25 seconds
        else:
            # Default to 10 seconds pricing if invalid
            base_credits = 150
    elif model_id == "sora-2-pro-text-to-video":
        # Sora 2 Pro Text-to-Video pricing:
        # Price depends on size and n_frames parameters
        # Standard: 10s = 150 credits ($0.75), 15s = 270 credits ($1.35)
        # High: 10s = 330 credits ($1.65), 15s = 630 credits ($3.15)
        size = params.get("size", "standard")
        n_frames = params.get("n_frames", "10")
        
        # Normalize size to lowercase
        size = str(size).strip().lower()
        if size not in ["standard", "high"]:
            size = "standard"  # Default to standard if invalid
        
        # Normalize n_frames (remove "s" suffix if present)
        n_frames_str = str(n_frames).strip()
        if n_frames_str.lower().endswith('s'):
            n_frames_str = n_frames_str[:-1].strip()
        
        if size == "high":
            # High quality pricing
            if n_frames_str == "15":
                base_credits = 630  # High, 15s
            else:  # n_frames == "10" or default
                base_credits = 330  # High, 10s
        else:  # size == "standard"
            # Standard quality pricing
            if n_frames_str == "15":
                base_credits = 270  # Standard, 15s
            else:  # n_frames == "10" or default
                base_credits = 150  # Standard, 10s
    elif model_id == "sora-2-pro-image-to-video":
        # Sora 2 Pro Image-to-Video pricing:
        # Price depends on size and n_frames parameters (same as text-to-video)
        # Standard: 10s = 150 credits ($0.75), 15s = 270 credits ($1.35)
        # High: 10s = 330 credits ($1.65), 15s = 630 credits ($3.15)
        size = params.get("size", "standard")
        n_frames = params.get("n_frames", "10")
        
        # Normalize size to lowercase
        size = str(size).strip().lower()
        if size not in ["standard", "high"]:
            size = "standard"  # Default to standard if invalid
        
        # Normalize n_frames (remove "s" suffix if present)
        n_frames_str = str(n_frames).strip()
        if n_frames_str.lower().endswith('s'):
            n_frames_str = n_frames_str[:-1].strip()
        
        if size == "high":
            # High quality pricing
            if n_frames_str == "15":
                base_credits = 630  # High, 15s
            else:  # n_frames == "10" or default
                base_credits = 330  # High, 10s
        else:  # size == "standard"
            # Standard quality pricing
            if n_frames_str == "15":
                base_credits = 270  # Standard, 15s
            else:  # n_frames == "10" or default
                base_credits = 150  # Standard, 10s
    elif model_id == "kling-2.6/image-to-video" or model_id == "kling-2.6/text-to-video":
        # Kling 2.6 pricing (same for both image-to-video and text-to-video):
        # Price depends on duration and sound parameters
        # 5s no-audio: 55 credits
        # 10s no-audio: 110 credits
        # 5s with audio: 110 credits
        # 10s with audio: 220 credits
        duration = params.get("duration", "5")
        sound = params.get("sound", False)
        
        if duration == "5":
            if sound:
                base_credits = 110  # 5s with audio
            else:
                base_credits = 55  # 5s no-audio
        else:  # duration == "10"
            if sound:
                base_credits = 220  # 10s with audio
            else:
                base_credits = 110  # 10s no-audio
    elif model_id == "kling/v2-5-turbo-text-to-video-pro" or model_id == "kling/v2-5-turbo-image-to-video-pro":
        # Kling 2.5 Turbo pricing (same for both text-to-video and image-to-video):
        # 5s: 42 credits
        # 10s: 84 credits
        duration = params.get("duration", "5")
        if duration == "10":
            base_credits = 84
        else:  # duration == "5"
            base_credits = 42
    elif model_id == "wan/2-5-image-to-video" or model_id == "wan/2-5-text-to-video":
        # WAN 2.5 pricing (same for both image-to-video and text-to-video):
        # 720p: 12 credits per second
        # 1080p: 20 credits per second
        duration = params.get("duration", "5")
        resolution = params.get("resolution", "720p")
        
        duration_int = int(duration)
        if resolution == "1080p":
            base_credits = 20 * duration_int  # 20 credits per second
        else:  # 720p
            base_credits = 12 * duration_int  # 12 credits per second
    elif model_id == "wan/2-2-animate-move" or model_id == "wan/2-2-animate-replace":
        # WAN 2.2 Animate pricing (same for both move and replace):
        # 480p: 6 credits per second
        # 580p: 9.5 credits per second
        # 720p: 12.5 credits per second
        # Note: Duration is determined by input video length (up to 30 seconds)
        # For pricing calculation, we'll use a default of 5 seconds as minimum
        resolution = params.get("resolution", "480p")
        
        # Default duration for pricing (actual duration comes from video)
        default_duration = 5
        
        if resolution == "720p":
            base_credits = 12.5 * default_duration  # 12.5 credits per second
        elif resolution == "580p":
            base_credits = 9.5 * default_duration  # 9.5 credits per second
        else:  # 480p
            base_credits = 6 * default_duration  # 6 credits per second
    elif model_id == "hailuo/02-text-to-video-pro" or model_id == "hailuo/02-image-to-video-pro":
        # Hailuo 02 Pro pricing:
        # 9.5 credits per second for 1080p
        # One generation yields a 6-second 1080p video
        # So: 9.5 * 6 = 57 credits per generation
        base_credits = 57  # Fixed price for 6-second 1080p video
    elif model_id == "hailuo/02-image-to-video-standard":
        # Hailuo 02 Standard image-to-video pricing:
        # 512P: 2 credits per second
        # 768P: 5 credits per second
        resolution = params.get("resolution", "768P")
        duration = params.get("duration", "6")
        duration_int = int(duration)
        
        if resolution == "768P":
            base_credits = 5 * duration_int  # 5 credits per second
        else:  # 512P
            base_credits = 2 * duration_int  # 2 credits per second
    elif model_id == "hailuo/02-text-to-video-standard":
        # Hailuo 02 Standard text-to-video pricing:
        # 768P: 5 credits per second
        duration = params.get("duration", "6")
        duration_int = int(duration)
        base_credits = 5 * duration_int  # 5 credits per second for 768P
    elif model_id == "hailuo/2-3-image-to-video-pro":
        # Hailuo 2-3 Image-to-Video Pro pricing:
        # Price depends on resolution and duration parameters
        # NOTE: 10-second videos are not supported for 1080P resolution
        # 768P, 6s: Need to check exact pricing
        # 768P, 10s: Need to check exact pricing
        # 1080P, 6s: Need to check exact pricing
        # For now, using estimated pricing based on similar Hailuo models:
        # 768P: ~5 credits per second
        # 1080P: ~9.5 credits per second
        resolution = params.get("resolution", "768P")
        duration = params.get("duration", "6")
        duration_int = int(duration)
        
        if resolution == "1080P":
            # 1080P pricing (only supports 6s, not 10s)
            base_credits = 9.5 * duration_int  # ~9.5 credits per second for 1080P
        else:  # 768P
            base_credits = 5 * duration_int  # ~5 credits per second for 768P
    elif model_id == "hailuo/2-3-image-to-video-standard":
        # Hailuo 2-3 Image-to-Video Standard pricing:
        # Price depends on resolution and duration parameters
        # NOTE: 10-second videos are not supported for 1080P resolution
        # Standard version is typically cheaper than Pro version
        # 768P, 6s: Need to check exact pricing
        # 768P, 10s: Need to check exact pricing
        # 1080P, 6s: Need to check exact pricing
        # For now, using estimated pricing based on similar Hailuo standard models:
        # 768P: ~5 credits per second (same as Pro for 768P)
        # 1080P: ~7 credits per second (cheaper than Pro ~9.5 credits/sec)
        resolution = params.get("resolution", "768P")
        duration = params.get("duration", "6")
        duration_int = int(duration)
        
        if resolution == "1080P":
            # 1080P pricing (only supports 6s, not 10s)
            # Standard version is cheaper than Pro
            base_credits = 7 * duration_int  # ~7 credits per second for 1080P (standard)
        else:  # 768P
            base_credits = 5 * duration_int  # ~5 credits per second for 768P
    elif model_id == "topaz/video-upscale":
        # Topaz Video Upscale pricing:
        # 12 credits per second
        # Note: Duration is determined by input video length
        # For pricing calculation, we'll use a default of 5 seconds as minimum
        default_duration = 5
        base_credits = 12 * default_duration  # 12 credits per second
    elif model_id == "kling/v1-avatar-standard":
        # Kling Avatar Standard pricing:
        # 8 credits per second for 720P
        # Up to 15 seconds per generation
        # For pricing calculation, we'll use a default of 5 seconds as minimum
        default_duration = 5
        base_credits = 8 * default_duration  # 8 credits per second for 720P
    elif model_id == "kling/ai-avatar-v1-pro":
        # Kling Avatar Pro pricing:
        # 16 credits per second for 1080P
        # Up to 15 seconds per generation
        # For pricing calculation, we'll use a default of 5 seconds as minimum
        default_duration = 5
        base_credits = 16 * default_duration  # 16 credits per second for 1080P
    elif model_id == "bytedance/seedream-v4-text-to-image" or model_id == "bytedance/seedream-v4-edit":
        # Seedream V4 pricing:
        # 5 credits per image
        # Price is independent of resolution, determined by number of images returned
        max_images = params.get("max_images", 1) if params else 1
        base_credits = 5 * max_images  # 5 credits per image
    elif model_id == "infinitalk/from-audio":
        # InfiniteTalk pricing:
        # 480P: 3 credits per second
        # 720P: 12 credits per second
        # Up to 15 seconds per generation
        # For pricing calculation, we'll use a default of 5 seconds as minimum
        resolution = params.get("resolution", "480p")
        default_duration = 5
        
        if resolution == "720p":
            base_credits = 12 * default_duration  # 12 credits per second
        else:  # 480p
            base_credits = 3 * default_duration  # 3 credits per second
    elif model_id == "recraft/remove-background":
        # Recraft Remove Background pricing:
        # Free and unlimited for users
        base_credits = 0
    elif model_id == "recraft/crisp-upscale":
        # Recraft Crisp Upscale pricing:
        # Free and unlimited for users
        base_credits = 0
    elif model_id == "ideogram/v3-reframe" or model_id == "ideogram/v3-text-to-image" or model_id == "ideogram/v3-edit" or model_id == "ideogram/v3-remix":
        # Ideogram V3 pricing (same for all variants):
        # TURBO: 3.5 credits per image
        # BALANCED: 7 credits per image
        # QUALITY: 10 credits per image
        rendering_speed = params.get("rendering_speed", "BALANCED") if params else "BALANCED"
        num_images = int(params.get("num_images", "1")) if params else 1
        
        if rendering_speed == "TURBO":
            credits_per_image = 3.5
        elif rendering_speed == "QUALITY":
            credits_per_image = 10
        else:  # BALANCED
            credits_per_image = 7
        
        base_credits = credits_per_image * num_images
    elif model_id == "wan/2-2-a14b-speech-to-video-turbo":
        # WAN 2.2 Speech-to-Video pricing:
        # 480P: 12 credits per second
        # 580P: 18 credits per second
        # 720P: 24 credits per second
        # Note: Duration is determined by audio length
        # For pricing calculation, we'll use a default of 5 seconds as minimum
        resolution = params.get("resolution", "480p")
        default_duration = 5
        
        if resolution == "720p":
            base_credits = 24 * default_duration  # 24 credits per second
        elif resolution == "580p":
            base_credits = 18 * default_duration  # 18 credits per second
        else:  # 480p
            base_credits = 12 * default_duration  # 12 credits per second
    elif model_id == "wan/2-2-a14b-text-to-video-turbo" or model_id == "wan/2-2-a14b-image-to-video-turbo":
        # WAN 2.2 A14B Turbo pricing:
        # 480p: 8 credits per second
        # 580p: 12 credits per second
        # 720p: 16 credits per second
        # For pricing calculation, we'll use a default of 5 seconds as minimum
        resolution = params.get("resolution", "720p") if params else "720p"
        default_duration = 5
        
        if resolution == "720p":
            base_credits = 16 * default_duration  # 16 credits per second
        elif resolution == "580p":
            base_credits = 12 * default_duration  # 12 credits per second
        else:  # 480p
            base_credits = 8 * default_duration  # 8 credits per second
    elif model_id == "bytedance/seedream":
        # Seedream 3.0 pricing:
        # 3.5 credits per image
        base_credits = 3.5
    elif model_id == "qwen/text-to-image":
        # Qwen Image pricing:
        # 4 credits per megapixel
        # Need to calculate megapixels based on image_size
        # Approximate resolutions:
        # square: 512x512 = 0.26 MP
        # square_hd: 1024x1024 = 1.05 MP
        # portrait_4_3: 768x1024 = 0.79 MP
        # portrait_16_9: 1024x1792 = 1.84 MP
        # landscape_4_3: 1024x768 = 0.79 MP
        # landscape_16_9: 1792x1024 = 1.84 MP
        image_size = params.get("image_size", "square_hd") if params else "square_hd"
        
        # Calculate megapixels based on image size
        mp_map = {
            "square": 0.26,  # 512x512
            "square_hd": 1.05,  # 1024x1024
            "portrait_4_3": 0.79,  # 768x1024
            "portrait_16_9": 1.84,  # 1024x1792
            "landscape_4_3": 0.79,  # 1024x768
            "landscape_16_9": 1.84  # 1792x1024
        }
        
        megapixels = mp_map.get(image_size, 1.05)  # Default to square_hd
        base_credits = 4 * megapixels  # 4 credits per megapixel
    elif model_id == "qwen/image-to-image":
        # Qwen Image-to-Image pricing:
        # 4 credits per image
        base_credits = 4
    elif model_id == "qwen/image-edit":
        # Qwen Image Edit pricing:
        # ‚âà $0.03 per megapixel, depending on image aspect ratio
        # Need to calculate megapixels based on image_size
        # Use same mapping as qwen/text-to-image
        image_size = params.get("image_size", "landscape_4_3") if params else "landscape_4_3"
        num_images = int(params.get("num_images", "1")) if params else 1
        
        # Calculate megapixels based on image size (same as qwen/text-to-image)
        mp_map = {
            "square": 0.26,  # 512x512
            "square_hd": 1.05,  # 1024x1024
            "portrait_4_3": 0.79,  # 768x1024
            "portrait_16_9": 1.84,  # 1024x1792
            "landscape_4_3": 0.79,  # 1024x768
            "landscape_16_9": 1.84  # 1792x1024
        }
        
        megapixels = mp_map.get(image_size, 0.79)  # Default to landscape_4_3
        # $0.03 per MP ‚âà 6 credits per MP (assuming $0.005 per credit)
        base_credits = 6 * megapixels * num_images
    elif model_id == "google/imagen4-ultra":
        # Google Imagen 4 Ultra pricing:
        # 12 credits per image
        base_credits = 12
    elif model_id == "google/imagen4-fast":
        # Google Imagen 4 Fast pricing:
        # 4 credits per image
        num_images = int(params.get("num_images", "1")) if params else 1
        base_credits = 4 * num_images
    elif model_id == "google/imagen4":
        # Google Imagen 4 pricing:
        # 8 credits per image
        num_images = int(params.get("num_images", "1")) if params else 1
        base_credits = 8 * num_images
    elif model_id == "ideogram/character-edit" or model_id == "ideogram/character-remix" or model_id == "ideogram/character":
        # Ideogram Character pricing (same for edit, remix, and base):
        # TURBO: 12 credits
        # BALANCED: 18 credits
        # QUALITY: 24 credits
        rendering_speed = params.get("rendering_speed", "BALANCED") if params else "BALANCED"
        num_images = int(params.get("num_images", "1")) if params else 1
        
        if rendering_speed == "TURBO":
            credits_per_image = 12
        elif rendering_speed == "QUALITY":
            credits_per_image = 24
        else:  # BALANCED
            credits_per_image = 18
        
        base_credits = credits_per_image * num_images
    elif model_id == "flux-2/pro-image-to-image" or model_id == "flux-2/pro-text-to-image":
        # Flux 2 Pro pricing (same for both image-to-image and text-to-image):
        # 1K: 5 credits
        # 2K: 7 credits
        resolution = params.get("resolution", "1K")
        if resolution == "2K":
            base_credits = 7
        else:  # 1K
            base_credits = 5
    elif model_id == "flux-2/flex-image-to-image" or model_id == "flux-2/flex-text-to-image":
        # Flux 2 Flex pricing (same for both image-to-image and text-to-image):
        # 1K: 14 credits
        # 2K: 24 credits
        resolution = params.get("resolution", "1K")
        if resolution == "2K":
            base_credits = 24
        else:  # 1K
            base_credits = 14
    elif model_id == "topaz/image-upscale":
        # Topaz Image Upscale pricing:
        # 1x (‚â§2K): 10 credits
        # 2x/4x (4K): 20 credits
        # 8x (8K): 40 credits
        upscale_factor = params.get("upscale_factor", "2")
        if upscale_factor == "8":
            base_credits = 40  # 8K
        elif upscale_factor in ["2", "4"]:
            base_credits = 20  # 4K
        else:  # upscale_factor == "1"
            base_credits = 10  # ‚â§2K
    elif model_id == "bytedance/v1-pro-fast-image-to-video":
        # ByteDance V1 Pro Fast Image-to-Video pricing:
        # Price depends on resolution and duration parameters
        # 480p, 5s: 10 credits (estimated)
        # 480p, 10s: 20 credits (estimated)
        # 720p, 5s: 16 credits
        # 720p, 10s: 36 credits
        # 1080p, 5s: 36 credits
        # 1080p, 10s: 72 credits
        resolution = params.get("resolution", "720p")
        duration = params.get("duration", "5")
        
        if resolution == "1080p":
            if duration == "10":
                base_credits = 72  # 1080p, 10s
            else:  # duration == "5"
                base_credits = 36  # 1080p, 5s
        elif resolution == "720p":
            if duration == "10":
                base_credits = 36  # 720p, 10s
            else:  # duration == "5"
                base_credits = 16  # 720p, 5s
        else:  # resolution == "480p"
            if duration == "10":
                base_credits = 20  # 480p, 10s (estimated)
            else:  # duration == "5"
                base_credits = 10  # 480p, 5s (estimated)
    elif model_id == "bytedance/v1-lite-text-to-video":
        # ByteDance V1 Lite Text-to-Video pricing:
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        # Price likely depends on resolution and duration parameters (similar to v1-pro-fast)
        # For now, use default pricing until confirmed
        resolution = params.get("resolution", "480p") if params else "480p"
        duration = params.get("duration", "5") if params else "5"
        
        # Default pricing (to be updated when actual pricing is confirmed)
        if resolution == "1080p":
            if duration == "10":
                base_credits = 50  # 1080p, 10s (estimated)
            else:  # duration == "5"
                base_credits = 25  # 1080p, 5s (estimated)
        elif resolution == "720p":
            if duration == "10":
                base_credits = 25  # 720p, 10s (estimated)
            else:  # duration == "5"
                base_credits = 12  # 720p, 5s (estimated)
        else:  # resolution == "480p"
            if duration == "10":
                base_credits = 15  # 480p, 10s (estimated)
            else:  # duration == "5"
                base_credits = 8  # 480p, 5s (estimated)
    elif model_id == "bytedance/v1-pro-text-to-video":
        # ByteDance V1 Pro Text-to-Video pricing:
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        # Price likely depends on resolution and duration parameters (similar to v1-pro-fast-image-to-video)
        # For now, use default pricing until confirmed
        resolution = params.get("resolution", "720p") if params else "720p"
        duration = params.get("duration", "5") if params else "5"
        
        # Default pricing (to be updated when actual pricing is confirmed)
        # Pro version should be more expensive than lite version
        if resolution == "1080p":
            if duration == "10":
                base_credits = 72  # 1080p, 10s (estimated, same as v1-pro-fast-image-to-video)
            else:  # duration == "5"
                base_credits = 36  # 1080p, 5s (estimated, same as v1-pro-fast-image-to-video)
        elif resolution == "720p":
            if duration == "10":
                base_credits = 36  # 720p, 10s (estimated, same as v1-pro-fast-image-to-video)
            else:  # duration == "5"
                base_credits = 16  # 720p, 5s (estimated, same as v1-pro-fast-image-to-video)
        else:  # resolution == "480p"
            if duration == "10":
                base_credits = 20  # 480p, 10s (estimated)
            else:  # duration == "5"
                base_credits = 10  # 480p, 5s (estimated)
    elif model_id == "bytedance/v1-lite-image-to-video":
        # ByteDance V1 Lite Image-to-Video pricing:
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        # Price likely depends on resolution and duration parameters (similar to v1-lite-text-to-video)
        # For now, use default pricing until confirmed
        resolution = params.get("resolution", "480p") if params else "480p"
        duration = params.get("duration", "5") if params else "5"
        
        # Default pricing (to be updated when actual pricing is confirmed)
        # Same pricing as v1-lite-text-to-video
        if resolution == "1080p":
            if duration == "10":
                base_credits = 50  # 1080p, 10s (estimated)
            else:  # duration == "5"
                base_credits = 25  # 1080p, 5s (estimated)
        elif resolution == "720p":
            if duration == "10":
                base_credits = 25  # 720p, 10s (estimated)
            else:  # duration == "5"
                base_credits = 12  # 720p, 5s (estimated)
        else:  # resolution == "480p"
            if duration == "10":
                base_credits = 15  # 480p, 10s (estimated)
            else:  # duration == "5"
                base_credits = 8  # 480p, 5s (estimated)
    elif model_id == "bytedance/v1-pro-image-to-video":
        # ByteDance V1 Pro Image-to-Video pricing:
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        # Price likely depends on resolution and duration parameters (similar to v1-pro-fast-image-to-video)
        # For now, use default pricing until confirmed
        resolution = params.get("resolution", "720p") if params else "720p"
        duration = params.get("duration", "5") if params else "5"
        
        # Default pricing (to be updated when actual pricing is confirmed)
        # Pro version should be more expensive than lite version
        if resolution == "1080p":
            if duration == "10":
                base_credits = 72  # 1080p, 10s (estimated, same as v1-pro-fast-image-to-video)
            else:  # duration == "5"
                base_credits = 36  # 1080p, 5s (estimated, same as v1-pro-fast-image-to-video)
        elif resolution == "720p":
            if duration == "10":
                base_credits = 36  # 720p, 10s (estimated, same as v1-pro-fast-image-to-video)
            else:  # duration == "5"
                base_credits = 16  # 720p, 5s (estimated, same as v1-pro-fast-image-to-video)
        else:  # resolution == "480p"
            if duration == "10":
                base_credits = 20  # 480p, 10s (estimated)
            else:  # duration == "5"
                base_credits = 10  # 480p, 5s (estimated)
    elif model_id == "kling/v2-1-master-image-to-video" or model_id == "kling/v2-1-standard" or model_id == "kling/v2-1-pro":
        # Kling V2.1 pricing (same for master, standard, and pro):
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        # Price likely depends on duration parameter
        # For now, use default pricing until confirmed
        duration = params.get("duration", "5") if params else "5"
        
        # Default pricing (to be updated when actual pricing is confirmed)
        # Estimated based on similar kling models
        if duration == "10":
            base_credits = 80  # 10s (estimated)
        else:  # duration == "5"
            base_credits = 40  # 5s (estimated)
    elif model_id == "elevenlabs/speech-to-text":
        # ElevenLabs Speech-to-Text pricing:
        # 3.5 credits per minute
        # For pricing calculation, we'll use a default of 1 minute as minimum
        # Note: Actual price depends on audio duration, but we show minimum price
        base_credits = 3.5  # Per minute
    else:
        # Default fallback
        base_credits = 1.0
    
    # Convert credits to USD, then to RUB (no rounding)
    price_usd = base_credits * CREDIT_TO_USD
    price_rub = price_usd * USD_TO_RUB
    
    # For regular users, multiply by 2
    if not is_admin:
        price_rub *= 2
    
    # Return exact value without rounding
    return price_rub


def format_price_rub(price: float, is_admin: bool = False) -> str:
    """Format price in rubles with appropriate text (rounded to 2 decimal places)."""
    # Always round to 2 decimal places
    price_rounded = round(price, 2)
    price_str = f"{price_rounded:.2f}"
    if is_admin:
        return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (—Ü–µ–Ω–∞: {price_str} ‚ÇΩ)"
    else:
        return f"üí∞ <b>{price_str} ‚ÇΩ</b>"


def get_model_price_text(model_id: str, params: dict = None, is_admin: bool = False, user_id: int = None) -> str:
    """Get formatted price text for a model."""
    if model_id == "z-image":
        price = calculate_price_rub(model_id, params, is_admin)
        if not is_admin and user_id is not None:
            # Check if user has free generations available
            remaining = get_user_free_generations_remaining(user_id)
            if remaining > 0:
                price_str = f"{round(price, 2):.2f}"
                return f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–û</b> ({remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å) –∏–ª–∏ {price_str} ‚ÇΩ"
        return format_price_rub(price, is_admin) + " –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"
    elif model_id == "nano-banana-pro":
        price_1k = calculate_price_rub(model_id, {"resolution": "1K"}, is_admin)
        price_4k = calculate_price_rub(model_id, {"resolution": "4K"}, is_admin)
        # Format prices to 2 decimal places
        price_1k_str = f"{round(price_1k, 2):.2f}"
        price_4k_str = f"{round(price_4k, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (1K/2K: {price_1k_str} ‚ÇΩ, 4K: {price_4k_str} ‚ÇΩ)"
        else:
            return f"üí∞ <b>–û—Ç {price_1k_str} ‚ÇΩ</b> (1K/2K: {price_1k_str} ‚ÇΩ, 4K: {price_4k_str} ‚ÇΩ)"
    elif model_id == "sora-watermark-remover":
        price = calculate_price_rub(model_id, params, is_admin)
        return format_price_rub(price, is_admin) + " –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ"
    elif model_id == "sora-2-text-to-video" or model_id == "sora-2-image-to-video":
        price = calculate_price_rub(model_id, params, is_admin)
        return format_price_rub(price, is_admin) + " –∑–∞ 10-—Å–µ–∫—É–Ω–¥–Ω–æ–µ –≤–∏–¥–µ–æ"
    elif model_id == "kling-2.6/image-to-video" or model_id == "kling-2.6/text-to-video":
        # Show price range based on duration and sound
        duration = params.get("duration", "5") if params else "5"
        sound = params.get("sound", False) if params else False
        
        if duration == "5":
            if sound:
                price = calculate_price_rub(model_id, {"duration": "5", "sound": True}, is_admin)
                return format_price_rub(price, is_admin) + " –∑–∞ 5—Å –≤–∏–¥–µ–æ (—Å–æ –∑–≤—É–∫–æ–º)"
            else:
                price = calculate_price_rub(model_id, {"duration": "5", "sound": False}, is_admin)
                return format_price_rub(price, is_admin) + " –∑–∞ 5—Å –≤–∏–¥–µ–æ (–±–µ–∑ –∑–≤—É–∫–∞)"
        else:  # duration == "10"
            if sound:
                price = calculate_price_rub(model_id, {"duration": "10", "sound": True}, is_admin)
                return format_price_rub(price, is_admin) + " –∑–∞ 10—Å –≤–∏–¥–µ–æ (—Å–æ –∑–≤—É–∫–æ–º)"
            else:
                price = calculate_price_rub(model_id, {"duration": "10", "sound": False}, is_admin)
                return format_price_rub(price, is_admin) + " –∑–∞ 10—Å –≤–∏–¥–µ–æ (–±–µ–∑ –∑–≤—É–∫–∞)"
    elif model_id == "kling/v2-5-turbo-text-to-video-pro" or model_id == "kling/v2-5-turbo-image-to-video-pro":
        # Show price based on duration
        duration = params.get("duration", "5") if params else "5"
        price_5s = calculate_price_rub(model_id, {"duration": "5"}, is_admin)
        price_10s = calculate_price_rub(model_id, {"duration": "10"}, is_admin)
        price_5s_str = f"{round(price_5s, 2):.2f}"
        price_10s_str = f"{round(price_10s, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (5—Å: {price_5s_str} ‚ÇΩ, 10—Å: {price_10s_str} ‚ÇΩ)"
        else:
            return f"üí∞ <b>–û—Ç {price_5s_str} ‚ÇΩ</b> (5—Å: {price_5s_str} ‚ÇΩ, 10—Å: {price_10s_str} ‚ÇΩ)"
    elif model_id == "wan/2-5-image-to-video" or model_id == "wan/2-5-text-to-video":
        # Show price based on duration and resolution
        duration = params.get("duration", "5") if params else "5"
        resolution = params.get("resolution", "720p") if params else "720p"
        price_720p_5s = calculate_price_rub(model_id, {"duration": "5", "resolution": "720p"}, is_admin)
        price_1080p_5s = calculate_price_rub(model_id, {"duration": "5", "resolution": "1080p"}, is_admin)
        price_720p_10s = calculate_price_rub(model_id, {"duration": "10", "resolution": "720p"}, is_admin)
        price_1080p_10s = calculate_price_rub(model_id, {"duration": "10", "resolution": "1080p"}, is_admin)
        price_720p_5s_str = f"{round(price_720p_5s, 2):.2f}"
        price_1080p_5s_str = f"{round(price_1080p_5s, 2):.2f}"
        price_720p_10s_str = f"{round(price_720p_10s, 2):.2f}"
        price_1080p_10s_str = f"{round(price_1080p_10s, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 720p:</b> {price_720p_5s_str}‚ÇΩ (5—Å), {price_720p_10s_str}‚ÇΩ (10—Å)\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 1080p:</b> {price_1080p_5s_str}‚ÇΩ (5—Å), {price_1080p_10s_str}‚ÇΩ (10—Å)"
        else:
            return f"üí∞ <b>–û—Ç {price_720p_5s_str} ‚ÇΩ</b>\n\nüì∫ <b>720p:</b> {price_720p_5s_str}‚ÇΩ (5—Å), {price_720p_10s_str}‚ÇΩ (10—Å)\nüì∫ <b>1080p:</b> {price_1080p_5s_str}‚ÇΩ (5—Å), {price_1080p_10s_str}‚ÇΩ (10—Å)"
    elif model_id == "wan/2-2-animate-move" or model_id == "wan/2-2-animate-replace":
        # Show price based on resolution
        resolution = params.get("resolution", "480p") if params else "480p"
        price_480p = calculate_price_rub(model_id, {"resolution": "480p"}, is_admin)
        price_580p = calculate_price_rub(model_id, {"resolution": "580p"}, is_admin)
        price_720p = calculate_price_rub(model_id, {"resolution": "720p"}, is_admin)
        price_480p_str = f"{round(price_480p, 2):.2f}"
        price_580p_str = f"{round(price_580p, 2):.2f}"
        price_720p_str = f"{round(price_720p, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 480p:</b> {price_480p_str}‚ÇΩ (5—Å)\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 580p:</b> {price_580p_str}‚ÇΩ (5—Å)\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 720p:</b> {price_720p_str}‚ÇΩ (5—Å)"
        else:
            return f"üí∞ <b>–û—Ç {price_480p_str} ‚ÇΩ</b>\n\nüì∫ <b>480p:</b> {price_480p_str}‚ÇΩ (5—Å)\nüì∫ <b>580p:</b> {price_580p_str}‚ÇΩ (5—Å)\nüì∫ <b>720p:</b> {price_720p_str}‚ÇΩ (5—Å)"
    elif model_id == "hailuo/02-text-to-video-pro" or model_id == "hailuo/02-image-to-video-pro":
        # Show fixed price for 6-second 1080p video
        price = calculate_price_rub(model_id, params, is_admin)
        price_str = f"{round(price, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> ({price_str} ‚ÇΩ –∑–∞ 6—Å 1080p –≤–∏–¥–µ–æ)"
        else:
            return f"üí∞ <b>{price_str} ‚ÇΩ</b> –∑–∞ 6—Å 1080p –≤–∏–¥–µ–æ"
    elif model_id == "hailuo/02-image-to-video-standard":
        # Show price based on resolution and duration
        resolution = params.get("resolution", "768P") if params else "768P"
        duration = params.get("duration", "6") if params else "6"
        price_512p_6s = calculate_price_rub(model_id, {"resolution": "512P", "duration": "6"}, is_admin)
        price_768p_6s = calculate_price_rub(model_id, {"resolution": "768P", "duration": "6"}, is_admin)
        price_512p_10s = calculate_price_rub(model_id, {"resolution": "512P", "duration": "10"}, is_admin)
        price_768p_10s = calculate_price_rub(model_id, {"resolution": "768P", "duration": "10"}, is_admin)
        price_512p_6s_str = f"{round(price_512p_6s, 2):.2f}"
        price_768p_6s_str = f"{round(price_768p_6s, 2):.2f}"
        price_512p_10s_str = f"{round(price_512p_10s, 2):.2f}"
        price_768p_10s_str = f"{round(price_768p_10s, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 512p:</b> {price_512p_6s_str}‚ÇΩ (6—Å), {price_512p_10s_str}‚ÇΩ (10—Å)\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 768p:</b> {price_768p_6s_str}‚ÇΩ (6—Å), {price_768p_10s_str}‚ÇΩ (10—Å)"
        else:
            return f"üí∞ <b>–û—Ç {price_512p_6s_str} ‚ÇΩ</b>\n\nüì∫ <b>512p:</b> {price_512p_6s_str}‚ÇΩ (6—Å), {price_512p_10s_str}‚ÇΩ (10—Å)\nüì∫ <b>768p:</b> {price_768p_6s_str}‚ÇΩ (6—Å), {price_768p_10s_str}‚ÇΩ (10—Å)"
    elif model_id == "hailuo/02-text-to-video-standard":
        # Show price based on duration (fixed 768P)
        duration = params.get("duration", "6") if params else "6"
        price_6s = calculate_price_rub(model_id, {"duration": "6"}, is_admin)
        price_10s = calculate_price_rub(model_id, {"duration": "10"}, is_admin)
        price_6s_str = f"{round(price_6s, 2):.2f}"
        price_10s_str = f"{round(price_10s, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 768p:</b> {price_6s_str}‚ÇΩ (6—Å), {price_10s_str}‚ÇΩ (10—Å)"
        else:
            return f"üí∞ <b>–û—Ç {price_6s_str} ‚ÇΩ</b>\n\nüì∫ <b>768p:</b> {price_6s_str}‚ÇΩ (6—Å), {price_10s_str}‚ÇΩ (10—Å)"
    elif model_id == "topaz/video-upscale":
        # Show price per second
        price_per_sec = calculate_price_rub(model_id, {}, is_admin) / 5  # Divide by default 5 seconds
        price_per_sec_str = f"{round(price_per_sec, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> ({price_per_sec_str} ‚ÇΩ/—Å–µ–∫)"
        else:
            return f"üí∞ <b>{price_per_sec_str} ‚ÇΩ/—Å–µ–∫</b>"
    elif model_id == "kling/v1-avatar-standard":
        # Show price per second for 720P
        price_per_sec = calculate_price_rub(model_id, {}, is_admin) / 5  # Divide by default 5 seconds
        price_per_sec_str = f"{round(price_per_sec, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ:</b> 720p\nüí∞ {price_per_sec_str} ‚ÇΩ/—Å–µ–∫\n‚è±Ô∏è –î–æ 15 —Å–µ–∫—É–Ω–¥"
        else:
            return f"üí∞ <b>{price_per_sec_str} ‚ÇΩ/—Å–µ–∫</b>\n\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ:</b> 720p\n‚è±Ô∏è –î–æ 15 —Å–µ–∫—É–Ω–¥"
    elif model_id == "kling/ai-avatar-v1-pro":
        # Show price per second for 1080P
        price_per_sec = calculate_price_rub(model_id, {}, is_admin) / 5  # Divide by default 5 seconds
        price_per_sec_str = f"{round(price_per_sec, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ:</b> 1080p\nüí∞ {price_per_sec_str} ‚ÇΩ/—Å–µ–∫\n‚è±Ô∏è –î–æ 15 —Å–µ–∫—É–Ω–¥"
        else:
            return f"üí∞ <b>{price_per_sec_str} ‚ÇΩ/—Å–µ–∫</b>\n\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ:</b> 1080p\n‚è±Ô∏è –î–æ 15 —Å–µ–∫—É–Ω–¥"
    elif model_id == "bytedance/seedream-v4-text-to-image" or model_id == "bytedance/seedream-v4-edit":
        # Show price per image
        max_images = params.get("max_images", 1) if params else 1
        price_per_image = calculate_price_rub(model_id, {"max_images": 1}, is_admin)
        price_total = calculate_price_rub(model_id, {"max_images": max_images}, is_admin)
        price_per_image_str = f"{round(price_per_image, 2):.2f}"
        price_total_str = f"{round(price_total, 2):.2f}"
        if is_admin:
            if max_images > 1:
                return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> ({price_per_image_str} ‚ÇΩ/–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –¥–æ {max_images} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π = {price_total_str} ‚ÇΩ)"
            else:
                return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> ({price_per_image_str} ‚ÇΩ/–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ)"
        else:
            if max_images > 1:
                return f"üí∞ <b>{price_per_image_str} ‚ÇΩ/–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b> (–¥–æ {max_images} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π = {price_total_str} ‚ÇΩ)"
            else:
                return f"üí∞ <b>{price_per_image_str} ‚ÇΩ/–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>"
    elif model_id == "infinitalk/from-audio":
        # Show price per second based on resolution
        resolution = params.get("resolution", "480p") if params else "480p"
        price_per_sec_480p = calculate_price_rub(model_id, {"resolution": "480p"}, is_admin) / 5
        price_per_sec_720p = calculate_price_rub(model_id, {"resolution": "720p"}, is_admin) / 5
        price_per_sec_480p_str = f"{round(price_per_sec_480p, 2):.2f}"
        price_per_sec_720p_str = f"{round(price_per_sec_720p, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 480p:</b> {price_per_sec_480p_str}‚ÇΩ/—Å–µ–∫\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 720p:</b> {price_per_sec_720p_str}‚ÇΩ/—Å–µ–∫\n‚è±Ô∏è –î–æ 15 —Å–µ–∫—É–Ω–¥"
        else:
            return f"üí∞ <b>–û—Ç {price_per_sec_480p_str} ‚ÇΩ/—Å–µ–∫</b>\n\nüì∫ <b>480p:</b> {price_per_sec_480p_str}‚ÇΩ/—Å–µ–∫\nüì∫ <b>720p:</b> {price_per_sec_720p_str}‚ÇΩ/—Å–µ–∫\n‚è±Ô∏è –î–æ 15 —Å–µ–∫—É–Ω–¥"
    elif model_id == "recraft/remove-background":
        # Show free and unlimited price
        if is_admin:
            return f"üí∞ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ –∏ –±–µ–∑–ª–∏–º–∏—Ç–Ω–æ</b>"
        else:
            return f"üí∞ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ</b> (–±–µ–∑–ª–∏–º–∏—Ç–Ω–æ)"
    elif model_id == "recraft/crisp-upscale":
        # Show free and unlimited price
        if is_admin:
            return f"üí∞ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ –∏ –±–µ–∑–ª–∏–º–∏—Ç–Ω–æ</b>"
        else:
            return f"üí∞ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ</b> (–±–µ–∑–ª–∏–º–∏—Ç–Ω–æ)"
    elif model_id == "ideogram/v3-reframe" or model_id == "ideogram/v3-text-to-image" or model_id == "ideogram/v3-edit" or model_id == "ideogram/v3-remix":
        # Show price based on rendering speed (same for all Ideogram V3 models)
        rendering_speed = params.get("rendering_speed", "BALANCED") if params else "BALANCED"
        price_turbo = calculate_price_rub(model_id, {"rendering_speed": "TURBO", "num_images": "1"}, is_admin)
        price_balanced = calculate_price_rub(model_id, {"rendering_speed": "BALANCED", "num_images": "1"}, is_admin)
        price_quality = calculate_price_rub(model_id, {"rendering_speed": "QUALITY", "num_images": "1"}, is_admin)
        price_turbo_str = f"{round(price_turbo, 2):.2f}"
        price_balanced_str = f"{round(price_balanced, 2):.2f}"
        price_quality_str = f"{round(price_quality, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (Turbo: {price_turbo_str}‚ÇΩ, Balanced: {price_balanced_str}‚ÇΩ, Quality: {price_quality_str}‚ÇΩ)"
        else:
            return f"üí∞ <b>–û—Ç {price_turbo_str} ‚ÇΩ</b> (Turbo: {price_turbo_str}‚ÇΩ, Balanced: {price_balanced_str}‚ÇΩ, Quality: {price_quality_str}‚ÇΩ)"
    elif model_id == "wan/2-2-a14b-speech-to-video-turbo":
        # Show price per second based on resolution
        resolution = params.get("resolution", "480p") if params else "480p"
        price_per_sec_480p = calculate_price_rub(model_id, {"resolution": "480p"}, is_admin) / 5
        price_per_sec_580p = calculate_price_rub(model_id, {"resolution": "580p"}, is_admin) / 5
        price_per_sec_720p = calculate_price_rub(model_id, {"resolution": "720p"}, is_admin) / 5
        price_per_sec_480p_str = f"{round(price_per_sec_480p, 2):.2f}"
        price_per_sec_580p_str = f"{round(price_per_sec_580p, 2):.2f}"
        price_per_sec_720p_str = f"{round(price_per_sec_720p, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 480p:</b> {price_per_sec_480p_str}‚ÇΩ/—Å–µ–∫\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 580p:</b> {price_per_sec_580p_str}‚ÇΩ/—Å–µ–∫\nüì∫ <b>–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 720p:</b> {price_per_sec_720p_str}‚ÇΩ/—Å–µ–∫"
        else:
            return f"üí∞ <b>–û—Ç {price_per_sec_480p_str} ‚ÇΩ/—Å–µ–∫</b>\n\nüì∫ <b>480p:</b> {price_per_sec_480p_str}‚ÇΩ/—Å–µ–∫\nüì∫ <b>580p:</b> {price_per_sec_580p_str}‚ÇΩ/—Å–µ–∫\nüì∫ <b>720p:</b> {price_per_sec_720p_str}‚ÇΩ/—Å–µ–∫"
    elif model_id == "bytedance/seedream":
        # Show fixed price per image
        price = calculate_price_rub(model_id, {}, is_admin)
        price_str = f"{round(price, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> ({price_str} ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ)"
        else:
            return f"üí∞ <b>{price_str} ‚ÇΩ</b> –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"
    elif model_id == "qwen/text-to-image":
        # Show price range based on image size (megapixels)
        price_square = calculate_price_rub(model_id, {"image_size": "square"}, is_admin)
        price_square_hd = calculate_price_rub(model_id, {"image_size": "square_hd"}, is_admin)
        price_portrait = calculate_price_rub(model_id, {"image_size": "portrait_16_9"}, is_admin)
        price_square_str = f"{round(price_square, 2):.2f}"
        price_square_hd_str = f"{round(price_square_hd, 2):.2f}"
        price_portrait_str = f"{round(price_portrait, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (–æ—Ç {price_square_str}‚ÇΩ, –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è: 4 –∫—Ä–µ–¥–∏—Ç–∞/–ú–ü)"
        else:
            return f"üí∞ <b>–û—Ç {price_square_str} ‚ÇΩ</b> (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è: 4 –∫—Ä–µ–¥–∏—Ç–∞/–ú–ü)"
    elif model_id == "qwen/image-to-image":
        # Show fixed price per image
        price = calculate_price_rub(model_id, {}, is_admin)
        price_str = f"{round(price, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> ({price_str} ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ)"
        else:
            return f"üí∞ <b>{price_str} ‚ÇΩ</b> –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"
    elif model_id == "qwen/image-edit":
        # Show price range based on image size (megapixels)
        price_square = calculate_price_rub(model_id, {"image_size": "square", "num_images": "1"}, is_admin)
        price_landscape = calculate_price_rub(model_id, {"image_size": "landscape_4_3", "num_images": "1"}, is_admin)
        price_portrait = calculate_price_rub(model_id, {"image_size": "portrait_16_9", "num_images": "1"}, is_admin)
        price_square_str = f"{round(price_square, 2):.2f}"
        price_landscape_str = f"{round(price_landscape, 2):.2f}"
        price_portrait_str = f"{round(price_portrait, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (–æ—Ç {price_square_str}‚ÇΩ, –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è: ‚âà6 –∫—Ä–µ–¥–∏—Ç–æ–≤/–ú–ü)"
        else:
            return f"üí∞ <b>–û—Ç {price_square_str} ‚ÇΩ</b> (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è: ‚âà6 –∫—Ä–µ–¥–∏—Ç–æ–≤/–ú–ü)"
    elif model_id == "ideogram/character-edit" or model_id == "ideogram/character-remix" or model_id == "ideogram/character":
        # Show price based on rendering speed
        rendering_speed = params.get("rendering_speed", "BALANCED") if params else "BALANCED"
        price_turbo = calculate_price_rub(model_id, {"rendering_speed": "TURBO", "num_images": "1"}, is_admin)
        price_balanced = calculate_price_rub(model_id, {"rendering_speed": "BALANCED", "num_images": "1"}, is_admin)
        price_quality = calculate_price_rub(model_id, {"rendering_speed": "QUALITY", "num_images": "1"}, is_admin)
        price_turbo_str = f"{round(price_turbo, 2):.2f}"
        price_balanced_str = f"{round(price_balanced, 2):.2f}"
        price_quality_str = f"{round(price_quality, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (Turbo: {price_turbo_str}‚ÇΩ, Balanced: {price_balanced_str}‚ÇΩ, Quality: {price_quality_str}‚ÇΩ)"
        else:
            return f"üí∞ <b>–û—Ç {price_turbo_str} ‚ÇΩ</b> (Turbo: {price_turbo_str}‚ÇΩ, Balanced: {price_balanced_str}‚ÇΩ, Quality: {price_quality_str}‚ÇΩ)"
    elif model_id == "flux-2/pro-image-to-image" or model_id == "flux-2/pro-text-to-image":
        # Show price based on resolution
        resolution = params.get("resolution", "1K") if params else "1K"
        price_1k = calculate_price_rub(model_id, {"resolution": "1K"}, is_admin)
        price_2k = calculate_price_rub(model_id, {"resolution": "2K"}, is_admin)
        price_1k_str = f"{round(price_1k, 2):.2f}"
        price_2k_str = f"{round(price_2k, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (1K: {price_1k_str} ‚ÇΩ, 2K: {price_2k_str} ‚ÇΩ)"
        else:
            return f"üí∞ <b>–û—Ç {price_1k_str} ‚ÇΩ</b> (1K: {price_1k_str} ‚ÇΩ, 2K: {price_2k_str} ‚ÇΩ)"
    elif model_id == "flux-2/flex-image-to-image" or model_id == "flux-2/flex-text-to-image":
        # Show price based on resolution
        resolution = params.get("resolution", "1K") if params else "1K"
        price_1k = calculate_price_rub(model_id, {"resolution": "1K"}, is_admin)
        price_2k = calculate_price_rub(model_id, {"resolution": "2K"}, is_admin)
        price_1k_str = f"{round(price_1k, 2):.2f}"
        price_2k_str = f"{round(price_2k, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (1K: {price_1k_str} ‚ÇΩ, 2K: {price_2k_str} ‚ÇΩ)"
        else:
            return f"üí∞ <b>–û—Ç {price_1k_str} ‚ÇΩ</b> (1K: {price_1k_str} ‚ÇΩ, 2K: {price_2k_str} ‚ÇΩ)"
    elif model_id == "topaz/image-upscale":
        # Show price based on upscale factor
        upscale_factor = params.get("upscale_factor", "2") if params else "2"
        price_1x = calculate_price_rub(model_id, {"upscale_factor": "1"}, is_admin)
        price_2x = calculate_price_rub(model_id, {"upscale_factor": "2"}, is_admin)
        price_8x = calculate_price_rub(model_id, {"upscale_factor": "8"}, is_admin)
        price_1x_str = f"{round(price_1x, 2):.2f}"
        price_2x_str = f"{round(price_2x, 2):.2f}"
        price_8x_str = f"{round(price_8x, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> (1x: {price_1x_str} ‚ÇΩ, 2x/4x: {price_2x_str} ‚ÇΩ, 8x: {price_8x_str} ‚ÇΩ)"
        else:
            return f"üí∞ <b>–û—Ç {price_1x_str} ‚ÇΩ</b> (1x: {price_1x_str} ‚ÇΩ, 2x/4x: {price_2x_str} ‚ÇΩ, 8x: {price_8x_str} ‚ÇΩ)"
    elif model_id == "elevenlabs/speech-to-text":
        # Show price per minute for speech-to-text
        price = calculate_price_rub(model_id, {}, is_admin)
        price_str = f"{round(price, 2):.2f}"
        if is_admin:
            return f"üí∞ <b>–ë–µ–∑–ª–∏–º–∏—Ç</b> ({price_str} ‚ÇΩ –∑–∞ –º–∏–Ω—É—Ç—É)"
        else:
            return f"üí∞ <b>{price_str} ‚ÇΩ</b> –∑–∞ –º–∏–Ω—É—Ç—É"
    else:
        price = calculate_price_rub(model_id, params, is_admin)
        return format_price_rub(price, is_admin)

# Conversation states for model selection and parameter input
SELECTING_MODEL, INPUTTING_PARAMS, CONFIRMING_GENERATION = range(3)

# Payment states
SELECTING_AMOUNT, WAITING_PAYMENT_SCREENSHOT = range(3, 5)

# Admin test OCR state
ADMIN_TEST_OCR = 5

# Broadcast states
WAITING_BROADCAST_MESSAGE = 6

# Admin test OCR state
ADMIN_TEST_OCR = 5

# Store user sessions
user_sessions = {}

# Store saved generation data for "generate again" feature
saved_generations = {}

# Global HTTP client for connection pooling (optimized for 1000+ users)
_http_client: Optional[aiohttp.ClientSession] = None

# File operation locks to prevent race conditions (using threading.Lock for sync operations)
_file_locks = {
    'balances': threading.Lock(),
    'generations_history': threading.Lock(),
    'referrals': threading.Lock(),
    'promocodes': threading.Lock(),
    'free_generations': threading.Lock(),
    'languages': threading.Lock(),
    'gifts': threading.Lock(),
    'payments': threading.Lock(),
    'broadcasts': threading.Lock(),
    'admin_limits': threading.Lock(),
    'blocked_users': threading.Lock()
}

# In-memory cache for frequently accessed data (optimized for 1000+ users)
_data_cache = {
    'balances': {},
    'free_generations': {},
    'languages': {},
    'gifts': {},
    'cache_timestamps': {}
}

# Cache TTL in seconds (5 minutes)
CACHE_TTL = 300
_last_save_time = {}

# Payment data files
BALANCES_FILE = "user_balances.json"
USER_LANGUAGES_FILE = "user_languages.json"
GIFT_CLAIMED_FILE = "gift_claimed.json"
ADMIN_LIMITS_FILE = "admin_limits.json"  # File to store admins with spending limits
PAYMENTS_FILE = "payments.json"
BLOCKED_USERS_FILE = "blocked_users.json"
FREE_GENERATIONS_FILE = "daily_free_generations.json"  # File to store daily free generations
PROMOCODES_FILE = "promocodes.json"  # File to store promo codes
REFERRALS_FILE = "referrals.json"  # File to store referral data
BROADCASTS_FILE = "broadcasts.json"  # File to store broadcast statistics
GENERATIONS_HISTORY_FILE = "generations_history.json"  # File to store user generation history

# Free generation settings
FREE_MODEL_ID = "z-image"  # Model that is free for users
FREE_GENERATIONS_PER_DAY = 5  # Number of free generations per day per user
REFERRAL_BONUS_GENERATIONS = 5  # Bonus generations for inviting a user


# ==================== Payment System Functions ====================

def get_cache_key(filename: str) -> str:
    """Get cache key for filename."""
    cache_map = {
        BALANCES_FILE: 'balances',
        FREE_GENERATIONS_FILE: 'free_generations',
        USER_LANGUAGES_FILE: 'languages',
        GIFT_CLAIMED_FILE: 'gifts',
        REFERRALS_FILE: 'referrals',
        PROMOCODES_FILE: 'promocodes',
        GENERATIONS_HISTORY_FILE: 'generations_history',
        PAYMENTS_FILE: 'payments',
        BROADCASTS_FILE: 'broadcasts',
        ADMIN_LIMITS_FILE: 'admin_limits',
        BLOCKED_USERS_FILE: 'blocked_users'
    }
    return cache_map.get(filename, filename)

def load_json_file(filename: str, default: dict = None) -> dict:
    """Load JSON file with caching and locking for performance (optimized for 1000+ users)."""
    if default is None:
        default = {}
    
    cache_key = get_cache_key(filename)
    current_time = time.time()
    
    # Check cache first (thread-safe read)
    if cache_key in _data_cache['cache_timestamps']:
        cache_time = _data_cache['cache_timestamps'][cache_key]
        if current_time - cache_time < CACHE_TTL and cache_key in _data_cache:
            if cache_key != filename:  # Only for mapped cache keys
                cached_data = _data_cache.get(cache_key)
                if cached_data is not None:
                    return cached_data.copy()
    
    # Get lock for this file type
    lock_key = cache_key if cache_key in _file_locks else 'balances'  # Default to balances lock
    lock = _file_locks.get(lock_key, _file_locks['balances'])
    
    # Load from file with lock to prevent race conditions
    with lock:
        try:
            if os.path.exists(filename):
                with open(filename, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    # Update cache (thread-safe)
                    if cache_key != filename:
                        _data_cache[cache_key] = data.copy()
                        _data_cache['cache_timestamps'][cache_key] = current_time
                    return data
            return default
        except Exception as e:
            logger.error(f"Error loading {filename}: {e}")
            return default


def save_json_file(filename: str, data: dict, use_cache: bool = True):
    """Save data to JSON file with batched writes (optimized for 1000+ users)."""
    try:
        cache_key = get_cache_key(filename)
        current_time = time.time()
        
        # Update cache immediately
        if use_cache and cache_key != filename:
            _data_cache[cache_key] = data.copy()
            _data_cache['cache_timestamps'][cache_key] = current_time
        
        # Batch writes: only save if enough time passed (reduce I/O)
        if filename in _last_save_time:
            time_since_last_save = current_time - _last_save_time[filename]
            # For critical files (balances), save immediately
            # For others, batch every 2 seconds max
            if filename not in [BALANCES_FILE] and time_since_last_save < 2.0:
                return  # Skip write, will be saved later or by batch save
        
        # Perform actual write
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        
        _last_save_time[filename] = current_time
    except Exception as e:
        logger.error(f"Error saving {filename}: {e}")


async def get_http_client() -> aiohttp.ClientSession:
    """Get or create global HTTP client with connection pooling."""
    global _http_client
    if _http_client is None or _http_client.closed:
        connector = aiohttp.TCPConnector(
            limit=100,  # Max connections
            limit_per_host=30,  # Max connections per host
            ttl_dns_cache=300,  # DNS cache TTL
            use_dns_cache=True,
        )
        timeout = aiohttp.ClientTimeout(total=60, connect=10)
        _http_client = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers={'User-Agent': 'TelegramBot/1.0'}
        )
    return _http_client


async def cleanup_http_client():
    """Close HTTP client on shutdown."""
    global _http_client
    if _http_client and not _http_client.closed:
        await _http_client.close()
        _http_client = None


def cleanup_old_sessions(max_age_seconds: int = 3600):
    """Clean up old user sessions to prevent memory leaks (optimized for 1000+ users)."""
    current_time = time.time()
    keys_to_remove = []
    
    for user_id, session in user_sessions.items():
        session_time = session.get('last_activity', current_time)
        if current_time - session_time > max_age_seconds:
            keys_to_remove.append(user_id)
    
    for key in keys_to_remove:
        del user_sessions[key]
    
    if keys_to_remove:
        logger.info(f"Cleaned up {len(keys_to_remove)} old user sessions")


def update_session_activity(user_id: int):
    """Update last activity time for user session."""
    if user_id in user_sessions:
        user_sessions[user_id]['last_activity'] = time.time()


def get_user_balance(user_id: int) -> float:
    """Get user balance in rubles (optimized with caching)."""
    user_key = str(user_id)
    
    # Check cache first
    current_time = time.time()
    if 'balances' in _data_cache['cache_timestamps']:
        cache_time = _data_cache['cache_timestamps']['balances']
        if current_time - cache_time < CACHE_TTL and user_key in _data_cache.get('balances', {}):
            return _data_cache['balances'][user_key]
    
    # Load from file if not in cache
    balances = load_json_file(BALANCES_FILE, {})
    return balances.get(user_key, 0.0)


def set_user_balance(user_id: int, amount: float):
    """Set user balance in rubles (optimized with caching)."""
    user_key = str(user_id)
    balances = load_json_file(BALANCES_FILE, {})
    balances[user_key] = amount
    
    # Update cache immediately
    if 'balances' not in _data_cache:
        _data_cache['balances'] = {}
    _data_cache['balances'][user_key] = amount
    _data_cache['cache_timestamps']['balances'] = time.time()
    
    save_json_file(BALANCES_FILE, balances)


def add_user_balance(user_id: int, amount: float) -> float:
    """Add amount to user balance, return new balance."""
    current = get_user_balance(user_id)
    new_balance = current + amount
    set_user_balance(user_id, new_balance)
    return new_balance


def subtract_user_balance(user_id: int, amount: float) -> bool:
    """Subtract amount from user balance. Returns True if successful, False if insufficient funds."""
    current = get_user_balance(user_id)
    if current >= amount:
        set_user_balance(user_id, current - amount)
        return True
    return False


# ==================== User Language System ====================

def get_user_language(user_id: int) -> str:
    """Get user language preference (default: 'ru')."""
    languages = load_json_file(USER_LANGUAGES_FILE, {})
    return languages.get(str(user_id), 'ru')  # Default to Russian

def has_user_language_set(user_id: int) -> bool:
    """Check if user has explicitly set their language preference."""
    languages = load_json_file(USER_LANGUAGES_FILE, {})
    return str(user_id) in languages


def set_user_language(user_id: int, language: str):
    """Set user language preference ('ru' or 'en')."""
    languages = load_json_file(USER_LANGUAGES_FILE, {})
    languages[str(user_id)] = language
    save_json_file(USER_LANGUAGES_FILE, languages)


# ==================== Gift System ====================

def has_claimed_gift(user_id: int) -> bool:
    """Check if user has already claimed their gift."""
    claimed = load_json_file(GIFT_CLAIMED_FILE, {})
    return claimed.get(str(user_id), False)


def set_gift_claimed(user_id: int):
    """Mark gift as claimed for user."""
    claimed = load_json_file(GIFT_CLAIMED_FILE, {})
    claimed[str(user_id)] = True
    save_json_file(GIFT_CLAIMED_FILE, claimed)


def spin_gift_wheel() -> float:
    """Spin the gift wheel and return random amount between 10 and 30 rubles."""
    import random
    # Generate random amount between 10 and 30 with 2 decimal places
    amount = round(random.uniform(10.0, 30.0), 2)
    return amount


# ==================== Free Generations System ====================

def get_free_generations_data() -> dict:
    """Get daily free generations data."""
    return load_json_file(FREE_GENERATIONS_FILE, {})


def save_free_generations_data(data: dict):
    """Save daily free generations data."""
    save_json_file(FREE_GENERATIONS_FILE, data)


def get_user_free_generations_today(user_id: int) -> int:
    """Get number of free generations used by user today."""
    from datetime import datetime
    
    data = get_free_generations_data()
    user_key = str(user_id)
    today = datetime.now().strftime('%Y-%m-%d')
    
    if user_key not in data:
        return 0
    
    user_data = data[user_key]
    if user_data.get('date') == today:
        return user_data.get('count', 0)
    else:
        # Reset for new day
        return 0


def get_user_free_generations_remaining(user_id: int) -> int:
    """Get remaining free generations for user today (including bonus)."""
    used = get_user_free_generations_today(user_id)
    data = get_free_generations_data()
    user_key = str(user_id)
    bonus = data.get(user_key, {}).get('bonus', 0)
    total_available = FREE_GENERATIONS_PER_DAY + bonus
    remaining = total_available - used
    return max(0, remaining)


def use_free_generation(user_id: int) -> bool:
    """Use one free generation. Returns True if successful, False if limit reached."""
    from datetime import datetime
    
    data = get_free_generations_data()
    user_key = str(user_id)
    today = datetime.now().strftime('%Y-%m-%d')
    
    if user_key not in data:
        data[user_key] = {'date': today, 'count': 0, 'bonus': 0}
    
    user_data = data[user_key]
    
    # Reset if new day (but keep bonus)
    if user_data.get('date') != today:
        old_bonus = user_data.get('bonus', 0)
        user_data['date'] = today
        user_data['count'] = 0
        user_data['bonus'] = old_bonus  # Keep bonus across days
    
    # Get total available (base + bonus)
    bonus = user_data.get('bonus', 0)
    total_available = FREE_GENERATIONS_PER_DAY + bonus
    
    # Check limit (including bonus)
    if user_data.get('count', 0) >= total_available:
        return False
    
    # Increment count
    user_data['count'] = user_data.get('count', 0) + 1
    save_free_generations_data(data)
    return True


def is_free_generation_available(user_id: int, model_id: str) -> bool:
    """Check if free generation is available for this user and model."""
    # Only for regular users (not admins)
    if get_is_admin(user_id):
        return False
    
    # Only for free model
    if model_id != FREE_MODEL_ID:
        return False
    
    # Check if user has remaining free generations
    remaining = get_user_free_generations_remaining(user_id)
    return remaining > 0


# ==================== Referral System ====================

def get_referrals_data() -> dict:
    """Get referrals data."""
    return load_json_file(REFERRALS_FILE, {})


def save_referrals_data(data: dict):
    """Save referrals data."""
    save_json_file(REFERRALS_FILE, data)


def get_user_referrals(user_id: int) -> list:
    """Get list of users referred by this user."""
    data = get_referrals_data()
    user_key = str(user_id)
    return data.get(user_key, {}).get('referred_users', [])


def get_referrer(user_id: int) -> int:
    """Get the user who referred this user, or None if not referred."""
    data = get_referrals_data()
    user_key = str(user_id)
    return data.get(user_key, {}).get('referred_by')


def add_referral(referrer_id: int, referred_id: int):
    """Add a referral relationship and give bonus to referrer."""
    import time
    data = get_referrals_data()
    referrer_key = str(referrer_id)
    referred_key = str(referred_id)
    
    # Check if already referred
    if referred_key in data and data[referred_key].get('referred_by'):
        return  # Already referred by someone
    
    # Add referral relationship
    if referred_key not in data:
        data[referred_key] = {}
    data[referred_key]['referred_by'] = referrer_id
    data[referred_key]['referred_at'] = int(time.time())
    
    # Add to referrer's list
    if referrer_key not in data:
        data[referrer_key] = {'referred_users': []}
    if 'referred_users' not in data[referrer_key]:
        data[referrer_key]['referred_users'] = []
    
    if referred_id not in data[referrer_key]['referred_users']:
        data[referrer_key]['referred_users'].append(referred_id)
    
    save_referrals_data(data)
    
    # Give bonus generations to referrer
    give_bonus_generations(referrer_id, REFERRAL_BONUS_GENERATIONS)


def give_bonus_generations(user_id: int, bonus_count: int):
    """Give bonus free generations to a user."""
    from datetime import datetime
    
    data = get_free_generations_data()
    user_key = str(user_id)
    today = datetime.now().strftime('%Y-%m-%d')
    
    if user_key not in data:
        data[user_key] = {'date': today, 'count': 0, 'bonus': 0}
    
    user_data = data[user_key]
    
    # Reset if new day (but keep bonus)
    if user_data.get('date') != today:
        old_bonus = user_data.get('bonus', 0)
        user_data['date'] = today
        user_data['count'] = 0
        user_data['bonus'] = old_bonus + bonus_count
    else:
        user_data['bonus'] = user_data.get('bonus', 0) + bonus_count
    
    save_free_generations_data(data)


def get_user_referral_link(user_id: int, bot_username: str = None) -> str:
    """Get referral link for user."""
    if bot_username is None:
        bot_username = "Ferixdi_bot_ai_bot"
    return f"https://t.me/{bot_username}?start=ref_{user_id}"


def get_fake_online_count() -> int:
    """Generate dynamic fake online user count - changes every time it's called."""
    # Base number around 500
    base = 500
    # Random variation ¬±80 for more dynamic changes
    variation = random.randint(-80, 80)
    # Time-based variation (slight changes based on time of day)
    current_hour = time.localtime().tm_hour
    # More activity during day hours (9-22)
    if 9 <= current_hour <= 22:
        time_multiplier = random.randint(0, 50)
    else:
        time_multiplier = random.randint(-30, 20)
    
    # Add microsecond-based variation for more randomness
    microsecond_variation = random.randint(-20, 20)
    
    count = base + variation + time_multiplier + microsecond_variation
    # Ensure reasonable bounds (300-700 range)
    return max(300, min(700, count))


# ==================== Promocodes System ====================

def load_promocodes() -> list:
    """Load promocodes from file."""
    data = load_json_file(PROMOCODES_FILE, {})
    return data.get('promocodes', [])


def save_promocodes(promocodes: list):
    """Save promocodes to file."""
    data = {'promocodes': promocodes}
    save_json_file(PROMOCODES_FILE, data)


def get_active_promocode() -> dict:
    """Get the currently active promocode."""
    promocodes = load_promocodes()
    for promo in promocodes:
        if promo.get('active', False):
            return promo
    return None


# ==================== Broadcast System ====================

def get_all_users() -> list:
    """Get list of all user IDs from various sources."""
    user_ids = set()
    
    # From user balances
    balances = load_json_file(BALANCES_FILE, {})
    user_ids.update([int(uid) for uid in balances.keys() if uid.isdigit()])
    
    # From payments
    payments = load_json_file(PAYMENTS_FILE, {})
    for payment in payments.values():
        if 'user_id' in payment:
            user_ids.add(payment['user_id'])
    
    # From referrals
    referrals = get_referrals_data()
    for user_key in referrals.keys():
        if user_key.isdigit():
            user_ids.add(int(user_key))
        # Also get referred users
        referred_users = referrals.get(user_key, {}).get('referred_users', [])
        user_ids.update(referred_users)
    
    # From free generations
    free_gens = get_free_generations_data()
    for user_key in free_gens.keys():
        if user_key.isdigit():
            user_ids.add(int(user_key))
    
    return sorted(list(user_ids))


def save_broadcast(broadcast_data: dict):
    """Save broadcast statistics."""
    broadcasts = load_json_file(BROADCASTS_FILE, {})
    broadcast_id = broadcast_data.get('id', len(broadcasts) + 1)
    broadcasts[str(broadcast_id)] = broadcast_data
    save_json_file(BROADCASTS_FILE, broadcasts)
    return broadcast_id


def get_broadcasts() -> dict:
    """Get all broadcasts."""
    return load_json_file(BROADCASTS_FILE, {})


def get_broadcast(broadcast_id: int) -> dict:
    """Get specific broadcast by ID."""
    broadcasts = get_broadcasts()
    return broadcasts.get(str(broadcast_id), {})


# ==================== Generations History System ====================

def save_generation_to_history(user_id: int, model_id: str, model_name: str, params: dict, result_urls: list, task_id: str, price: float = 0.0, is_free: bool = False):
    """Save generation to user history."""
    import time
    history = load_json_file(GENERATIONS_HISTORY_FILE, {})
    user_key = str(user_id)
    
    if user_key not in history:
        history[user_key] = []
    
    generation_entry = {
        'id': len(history[user_key]) + 1,
        'timestamp': int(time.time()),
        'model_id': model_id,
        'model_name': model_name,
        'params': params.copy(),
        'result_urls': result_urls.copy(),
        'task_id': task_id,
        'price': price,
        'is_free': is_free
    }
    
    history[user_key].append(generation_entry)
    
    # Keep only last 100 generations per user
    if len(history[user_key]) > 100:
        history[user_key] = history[user_key][-100:]
    
    save_json_file(GENERATIONS_HISTORY_FILE, history)
    return generation_entry['id']


def get_user_generations_history(user_id: int, limit: int = 20) -> list:
    """Get user's generation history."""
    history = load_json_file(GENERATIONS_HISTORY_FILE, {})
    user_key = str(user_id)
    
    if user_key not in history:
        return []
    
    # Return last N generations, sorted by timestamp (newest first)
    user_history = history[user_key]
    user_history.sort(key=lambda x: x.get('timestamp', 0), reverse=True)
    return user_history[:limit]


def get_generation_by_id(user_id: int, generation_id: int) -> dict:
    """Get specific generation by ID."""
    history = load_json_file(GENERATIONS_HISTORY_FILE, {})
    user_key = str(user_id)
    
    if user_key not in history:
        return None
    
    for gen in history[user_key]:
        if gen.get('id') == generation_id:
            return gen
    
    return None


def is_new_user(user_id: int) -> bool:
    """Check if user is new (no balance, no history, no payments)."""
    # Check balance
    balance = get_user_balance(user_id)
    if balance > 0:
        return False
    
    # Check history
    history = get_user_generations_history(user_id, limit=1)
    if history:
        return False
    
    # Check payments
    payments = get_user_payments(user_id)
    if payments:
        return False
    
    return True


async def send_broadcast(context: ContextTypes.DEFAULT_TYPE, broadcast_id: int, user_ids: list, message_text: str = None, message_photo=None):
    """Send broadcast message to all users."""
    sent = 0
    delivered = 0
    failed = 0
    
    for user_id in user_ids:
        try:
            # Skip blocked users
            if is_user_blocked(user_id):
                continue
            
            # Send message
            if message_photo:
                # Send photo with caption
                try:
                    await context.bot.send_photo(
                        chat_id=user_id,
                        photo=message_photo.file_id,
                        caption=message_text,
                        parse_mode='HTML'
                    )
                    delivered += 1
                except Exception as e:
                    logger.error(f"Error sending broadcast photo to {user_id}: {e}")
                    failed += 1
            else:
                # Send text message
                try:
                    await context.bot.send_message(
                        chat_id=user_id,
                        text=message_text,
                        parse_mode='HTML'
                    )
                    delivered += 1
                except Exception as e:
                    logger.error(f"Error sending broadcast message to {user_id}: {e}")
                    failed += 1
            
            sent += 1
            
            # Small delay to avoid rate limiting
            await asyncio.sleep(0.05)  # 50ms delay between messages
            
        except Exception as e:
            logger.error(f"Error in broadcast to {user_id}: {e}")
            failed += 1
            sent += 1
    
    # Update broadcast statistics
    broadcasts = get_broadcasts()
    if str(broadcast_id) in broadcasts:
        broadcasts[str(broadcast_id)]['sent'] = sent
        broadcasts[str(broadcast_id)]['delivered'] = delivered
        broadcasts[str(broadcast_id)]['failed'] = failed
        save_json_file(BROADCASTS_FILE, broadcasts)
        
        # Notify admin
        try:
            admin_id = ADMIN_ID
            await context.bot.send_message(
                chat_id=admin_id,
                text=(
                    f"‚úÖ <b>–†–∞—Å—Å—ã–ª–∫–∞ #{broadcast_id} –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                    f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
                    f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent}\n"
                    f"üì¨ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {delivered}\n"
                    f"‚ùå –û—à–∏–±–æ–∫: {failed}\n\n"
                    f"üìà <b>–£—Å–ø–µ—à–Ω–æ—Å—Ç—å:</b> {(delivered/sent*100) if sent > 0 else 0:.1f}%"
                ),
                parse_mode='HTML'
            )
        except Exception as e:
            logger.error(f"Error notifying admin about broadcast: {e}")


def is_user_blocked(user_id: int) -> bool:
    """Check if user is blocked."""
    blocked = load_json_file(BLOCKED_USERS_FILE, {})
    return blocked.get(str(user_id), False)


def block_user(user_id: int):
    """Block a user."""
    blocked = load_json_file(BLOCKED_USERS_FILE, {})
    blocked[str(user_id)] = True
    save_json_file(BLOCKED_USERS_FILE, blocked)


def unblock_user(user_id: int):
    """Unblock a user."""
    blocked = load_json_file(BLOCKED_USERS_FILE, {})
    if str(user_id) in blocked:
        del blocked[str(user_id)]
        save_json_file(BLOCKED_USERS_FILE, blocked)


def check_duplicate_payment(screenshot_file_id: str) -> bool:
    """Check if this screenshot was already used for payment."""
    if not screenshot_file_id:
        return False
    payments = load_json_file(PAYMENTS_FILE, {})
    for payment in payments.values():
        if payment.get('screenshot_file_id') == screenshot_file_id:
            return True
    return False


def add_payment(user_id: int, amount: float, screenshot_file_id: str = None) -> dict:
    """Add a payment record. Returns payment dict with id, timestamp, etc."""
    payments = load_json_file(PAYMENTS_FILE, {})
    payment_id = len(payments) + 1
    import time
    payment = {
        "id": payment_id,
        "user_id": user_id,
        "amount": amount,
        "timestamp": time.time(),
        "screenshot_file_id": screenshot_file_id,
        "status": "completed"  # Auto-completed
    }
    payments[str(payment_id)] = payment
    save_json_file(PAYMENTS_FILE, payments)
    
    # Auto-add balance
    add_user_balance(user_id, amount)
    
    return payment


def get_all_payments() -> list:
    """Get all payments sorted by timestamp (newest first)."""
    payments = load_json_file(PAYMENTS_FILE, {})
    payment_list = list(payments.values())
    payment_list.sort(key=lambda x: x.get("timestamp", 0), reverse=True)
    return payment_list


def get_user_payments(user_id: int) -> list:
    """Get all payments for a specific user."""
    all_payments = get_all_payments()
    return [p for p in all_payments if p.get("user_id") == user_id]


def get_payment_stats() -> dict:
    """Get payment statistics."""
    payments = get_all_payments()
    total_amount = sum(p.get("amount", 0) for p in payments)
    total_count = len(payments)
    return {
        "total_amount": total_amount,
        "total_count": total_count,
        "payments": payments
    }


def get_extended_admin_stats() -> dict:
    """Get extended statistics for admin panel."""
    import time
    from datetime import datetime, timedelta
    
    now = time.time()
    today_start = int((datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)).timestamp())
    week_start = int((datetime.now() - timedelta(days=7)).timestamp())
    month_start = int((datetime.now() - timedelta(days=30)).timestamp())
    
    # Get all users
    all_users = get_all_users()
    total_users = len(all_users)
    
    # Get active users (users with activity in period)
    history = load_json_file(GENERATIONS_HISTORY_FILE, {})
    active_today = set()
    active_week = set()
    active_month = set()
    
    for user_key, user_history in history.items():
        for gen in user_history:
            timestamp = gen.get('timestamp', 0)
            user_id = int(user_key) if user_key.isdigit() else None
            if user_id:
                if timestamp >= today_start:
                    active_today.add(user_id)
                if timestamp >= week_start:
                    active_week.add(user_id)
                if timestamp >= month_start:
                    active_month.add(user_id)
    
    # Get top models by usage
    model_usage = {}
    for user_key, user_history in history.items():
        for gen in user_history:
            model_id = gen.get('model_id', '')
            if model_id:
                model_usage[model_id] = model_usage.get(model_id, 0) + 1
    
    # Sort models by usage and get top 5
    top_models = sorted(model_usage.items(), key=lambda x: x[1], reverse=True)[:5]
    top_models_list = []
    for model_id, count in top_models:
        model_info = get_model_by_id(model_id)
        model_name = model_info.get('name', model_id) if model_info else model_id
        top_models_list.append({'name': model_name, 'id': model_id, 'count': count})
    
    # Get payment statistics
    payment_stats = get_payment_stats()
    total_revenue = payment_stats.get('total_amount', 0)
    total_payments = payment_stats.get('total_count', 0)
    
    # Calculate conversion rate (users who made at least one payment)
    users_with_payments = set()
    for payment in payment_stats.get('payments', []):
        user_id = payment.get('user_id')
        if user_id:
            users_with_payments.add(user_id)
    
    conversion_rate = (len(users_with_payments) / total_users * 100) if total_users > 0 else 0
    
    # Calculate average check
    avg_check = (total_revenue / total_payments) if total_payments > 0 else 0
    
    # Get revenue for periods
    payments = payment_stats.get('payments', [])
    revenue_today = sum(p.get('amount', 0) for p in payments if p.get('timestamp', 0) >= today_start)
    revenue_week = sum(p.get('amount', 0) for p in payments if p.get('timestamp', 0) >= week_start)
    revenue_month = sum(p.get('amount', 0) for p in payments if p.get('timestamp', 0) >= month_start)
    
    # Total generations count
    total_generations = sum(len(user_history) for user_history in history.values())
    
    return {
        'total_users': total_users,
        'active_today': len(active_today),
        'active_week': len(active_week),
        'active_month': len(active_month),
        'top_models': top_models_list,
        'total_revenue': total_revenue,
        'revenue_today': revenue_today,
        'revenue_week': revenue_week,
        'revenue_month': revenue_month,
        'total_payments': total_payments,
        'conversion_rate': conversion_rate,
        'avg_check': avg_check,
        'total_generations': total_generations
    }


def get_payment_details() -> str:
    """Get payment details from .env (–°–ë–ü - –°–∏—Å—Ç–µ–º–∞ –±—ã—Å—Ç—Ä—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π)."""
    # Reload .env to ensure latest values are loaded
    # On Render, environment variables are set via dashboard, not .env file
    # But we still try to load .env for local development
    try:
        load_dotenv(override=True)
    except Exception as e:
        logger.debug(f"Could not reload .env: {e}")
    
    # Get from environment (works both for .env and Render Environment Variables)
    card_holder = os.getenv('PAYMENT_CARD_HOLDER', '').strip()
    phone = os.getenv('PAYMENT_PHONE', '').strip()
    bank = os.getenv('PAYMENT_BANK', '').strip()
    
    # Enhanced debug logging for troubleshooting
    logger.debug(f"Loading payment details - PAYMENT_PHONE: {'SET' if phone else 'NOT SET'}, PAYMENT_BANK: {'SET' if bank else 'NOT SET'}, PAYMENT_CARD_HOLDER: {'SET' if card_holder else 'NOT SET'}")
    
    # Check if any payment details are missing
    if not phone and not bank and not card_holder:
        logger.warning("Payment details not found in environment variables!")
        logger.warning("Make sure these environment variables are set in Render dashboard:")
        logger.warning("  - PAYMENT_PHONE")
        logger.warning("  - PAYMENT_BANK")
        logger.warning("  - PAYMENT_CARD_HOLDER")
        # Also log all environment variables that start with PAYMENT_ for debugging
        payment_env_vars = {k: v for k, v in os.environ.items() if k.startswith('PAYMENT_')}
        logger.debug(f"All PAYMENT_* environment variables: {payment_env_vars}")
    
    details = "üí≥ <b>–†–µ–∫–≤–∏–∑–∏—Ç—ã –¥–ª—è –æ–ø–ª–∞—Ç—ã (–°–ë–ü):</b>\n\n"
    
    if phone:
        details += f"üì± <b>–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:</b> <code>{phone}</code>\n"
    if bank:
        details += f"üè¶ <b>–ë–∞–Ω–∫:</b> {bank}\n"
    if card_holder:
        details += f"üë§ <b>–ü–æ–ª—É—á–∞—Ç–µ–ª—å:</b> {card_holder}\n"
    
    if not phone and not bank and not card_holder:
        details += "‚ö†Ô∏è <b>–í–ù–ò–ú–ê–ù–ò–ï: –†–µ–∫–≤–∏–∑–∏—Ç—ã –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã!</b>\n\n"
        details += "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è:\n"
        details += "‚Ä¢ <code>PAYMENT_PHONE</code> - –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –¥–ª—è –°–ë–ü\n"
        details += "‚Ä¢ <code>PAYMENT_BANK</code> - –Ω–∞–∑–≤–∞–Ω–∏–µ –±–∞–Ω–∫–∞\n"
        details += "‚Ä¢ <code>PAYMENT_CARD_HOLDER</code> - –∏–º—è –ø–æ–ª—É—á–∞—Ç–µ–ª—è\n\n"
        details += "–ù–∞ Render: –¥–æ–±–∞–≤—å—Ç–µ –∏—Ö –≤ —Ä–∞–∑–¥–µ–ª–µ Environment Variables\n"
        details += "–õ–æ–∫–∞–ª—å–Ω–æ: –¥–æ–±–∞–≤—å—Ç–µ –≤ —Ñ–∞–π–ª .env\n\n"
    
    details += "\n‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b> –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞ –≤ —ç—Ç–æ—Ç —á–∞—Ç.\n\n"
    details += "‚úÖ <b>–ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏</b> –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞."
    
    return details


def get_support_contact() -> str:
    """Get support contact information from .env (only Telegram)."""
    # Reload .env to ensure latest values are loaded
    # On Render, environment variables are set via dashboard, not .env file
    # But we still try to load .env for local development
    try:
        load_dotenv(override=True)
    except Exception as e:
        logger.debug(f"Could not reload .env: {e}")
    
    support_telegram = os.getenv('SUPPORT_TELEGRAM', '').strip()
    support_text = os.getenv('SUPPORT_TEXT', '').strip()
    
    # Enhanced debug logging for troubleshooting
    logger.debug(f"Loading support contact - SUPPORT_TELEGRAM: {'SET' if support_telegram else 'NOT SET'}, SUPPORT_TEXT: {'SET' if support_text else 'NOT SET'}")
    
    contact = "üÜò <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞</b>\n\n"
    
    if support_text:
        contact += f"{support_text}\n\n"
    else:
        contact += "–ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏:\n\n"
    
    if support_telegram:
        telegram_username = support_telegram.replace('@', '')
        contact += f"üí¨ <b>Telegram:</b> @{telegram_username}\n"
    else:
        logger.warning("Support contact not found in environment variables!")
        logger.warning("Make sure these environment variables are set in Render dashboard:")
        logger.warning("  - SUPPORT_TELEGRAM")
        logger.warning("  - SUPPORT_TEXT (optional)")
        # Also log all environment variables that start with SUPPORT_ for debugging
        support_env_vars = {k: v for k, v in os.environ.items() if k.startswith('SUPPORT_')}
        logger.debug(f"All SUPPORT_* environment variables: {support_env_vars}")
        contact += "‚ö†Ô∏è <b>–ö–æ–Ω—Ç–∞–∫—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.</b>\n\n"
        contact += "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å SUPPORT_TELEGRAM –≤ —Ñ–∞–π–ª–µ .env –∏–ª–∏ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Render (Environment Variables).\n\n"
        contact += "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
    
    return contact


async def analyze_payment_screenshot(image_data: bytes, expected_amount: float, expected_phone: str = None) -> dict:
    """
    Analyze payment screenshot using OCR.
    Returns dict with 'valid', 'amount_found', 'phone_found', 'message'.
    """
    if not OCR_AVAILABLE or not PIL_AVAILABLE:
        # If OCR not available, allow payment without check
        return {
            'valid': True,  # Allow without OCR check
            'amount_found': False,
            'phone_found': False,
            'message': '‚ÑπÔ∏è OCR –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.'
        }
    
    try:
        # Convert bytes to PIL Image
        image = Image.open(BytesIO(image_data))
        
        # Use OCR to extract text
        try:
            extracted_text = pytesseract.image_to_string(image, lang='rus+eng')
        except Exception as e:
            logger.error(f"OCR error: {e}")
            # Try with English only if Russian fails
            try:
                extracted_text = pytesseract.image_to_string(image, lang='eng')
            except:
                extracted_text = pytesseract.image_to_string(image)
        
        extracted_text = extracted_text.lower()
        logger.info(f"Extracted text from screenshot (first 200 chars): {extracted_text[:200]}")
        
        # Check for payment-related keywords (Russian and English)
        payment_keywords = [
            '–ø–µ—Ä–µ–≤–æ–¥', '–æ–ø–ª–∞—Ç–∞', '–ø–ª–∞—Ç–µ–∂', '—Å–ø–±', '—Å–±–ø', 'payment', 'transfer',
            '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ', '—É—Å–ø–µ—à–Ω–æ', 'success', '–ø–æ–ª—É—á–∞—Ç–µ–ª—å', '–ø–æ–ª—É—á–∞—Ç–µ–ª—å:',
            '—Å—É–º–º–∞', '–∏—Ç–æ–≥–æ', 'amount', 'total', '—Å—É–º–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞', '–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ',
            '–∫–≤–∏—Ç–∞–Ω—Ü–∏—è', 'receipt', '—Å—Ç–∞—Ç—É—Å', 'status', '–∫–æ–º–∏—Å—Å–∏—è', 'commission'
        ]
        
        has_payment_keywords = any(keyword in extracted_text for keyword in payment_keywords)
        
        # Extract amount from text (look for numbers with ‚ÇΩ, —Ä—É–±, –†, or near payment keywords)
        amount_patterns = [
            # With currency symbols
            r'(\d+[.,]\d+)\s*[‚ÇΩ—Ä—É–±–†]',
            r'(\d+)\s*[‚ÇΩ—Ä—É–±–†]',
            r'[‚ÇΩ—Ä—É–±–†]\s*(\d+[.,]\d+)',
            r'[‚ÇΩ—Ä—É–±–†]\s*(\d+)',
            # Near payment keywords
            r'(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)[:\s]+(\d+[.,]?\d*)',
            r'(\d+[.,]?\d*)\s*(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)',
            # Standalone numbers near payment context (more flexible)
            r'(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)[:\s]*\s*(\d+[.,]?\d*)\s*[‚ÇΩ—Ä—É–±–†]?',
            # Numbers that might be misrecognized (B instead of –†, 2 instead of –†)
            r'(\d+)\s*[B2]',  # 500 B or 500 2 might be 500 –†
            r'(\d+)\s*[‚ÇΩ—Ä—É–±–†B2]',
            # Just numbers in context of payment (last resort)
            r'\b(\d{2,6})\b',  # 2-6 digit numbers (likely amounts)
        ]
        
        amount_found = False
        found_amount = None
        all_found_amounts = []
        
        for pattern in amount_patterns:
            matches = re.findall(pattern, extracted_text, re.IGNORECASE)
            if matches:
                try:
                    amounts = [float(m.replace(',', '.')) for m in matches]
                    all_found_amounts.extend(amounts)
                except:
                    continue
        
        if all_found_amounts:
            # Remove duplicates and sort
            unique_amounts = sorted(set(all_found_amounts), reverse=True)
            
            # Try to find amount that matches expected (with tolerance)
            for amt in unique_amounts:
                # Check if amount matches (allow small difference for rounding)
                diff = abs(amt - expected_amount)
                diff_percent = diff / expected_amount if expected_amount > 0 else 1
                
                # Match if difference is less than 1 ruble or less than 10%
                if diff < 1.0 or diff_percent < 0.1:
                    amount_found = True
                    found_amount = amt
                    break
            
            # If no exact match, use the largest reasonable amount
            if not amount_found and unique_amounts:
                # Filter amounts that are reasonable (between 10 and 100000)
                reasonable_amounts = [a for a in unique_amounts if 10 <= a <= 100000]
                if reasonable_amounts:
                    # Check if any reasonable amount is close to expected
                    for amt in reasonable_amounts:
                        diff = abs(amt - expected_amount)
                        if diff < 10.0:  # Allow up to 10 rubles difference
                            amount_found = True
                            found_amount = amt
                            break
        
        # Extract phone number from text
        phone_found = False
        if expected_phone:
            # Normalize phone (remove +, spaces, dashes)
            normalized_expected = re.sub(r'[+\s\-()]', '', expected_phone)
            
            # Look for phone patterns
            phone_patterns = [
                r'\+?7\d{10}',
                r'\+?7\s?\d{3}\s?\d{3}\s?\d{2}\s?\d{2}',
                r'\d{11}',
                r'\+?\d{1}\s?\d{3}\s?\d{3}\s?\d{2}\s?\d{2}',
            ]
            
            for pattern in phone_patterns:
                matches = re.findall(pattern, extracted_text)
                for match in matches:
                    normalized_match = re.sub(r'[+\s\-()]', '', match)
                    if normalized_match == normalized_expected or normalized_match.endswith(normalized_expected[-10:]):
                        phone_found = True
                        break
                if phone_found:
                    break
        
        # Improved validation with scoring system
        score = 0
        max_score = 4
        
        # Amount match: +2 points (most important)
        if amount_found:
            score += 2
        elif all_found_amounts:
            # If amount found but doesn't match exactly, check if close
            reasonable_amounts = [a for a in all_found_amounts if 10 <= a <= 100000]
            if reasonable_amounts:
                # Check if any amount is within 20% of expected
                for amt in reasonable_amounts:
                    diff_percent = abs(amt - expected_amount) / expected_amount if expected_amount > 0 else 1
                    if diff_percent <= 0.2:  # Within 20%
                        score += 1  # Partial credit
                        break
        
        # Phone match: +1 point (if expected)
        if expected_phone and phone_found:
            score += 1
        
        # Payment keywords: +1 point (required for security)
        if has_payment_keywords:
            score += 1
        
        # Additional checks for better validation
        # Check for duplicate screenshots (by file_id if available)
        # This will be checked in the payment handler
        
        # Validation: Need at least 2.5 points (flexible but secure)
        # This means: (amount + keywords) OR (amount + phone) OR (amount perfect match)
        valid = score >= 2.5
        
        # Additional security: if no amount found at all, reject (unless OCR failed)
        if not all_found_amounts and not has_payment_keywords:
            valid = False
        
        # Additional check: if amount is found but way off, be more strict
        if amount_found and found_amount:
            diff_percent = abs(found_amount - expected_amount) / expected_amount if expected_amount > 0 else 1
            # If difference is more than 30%, require additional verification
            if diff_percent > 0.3:
                # Require both phone and keywords if amount is way off
                if not (phone_found and has_payment_keywords):
                    valid = False
        
        message_parts = []
        if amount_found:
            message_parts.append(f"‚úÖ –°—É–º–º–∞ –Ω–∞–π–¥–µ–Ω–∞: {found_amount:.2f} ‚ÇΩ")
        else:
            message_parts.append(f"‚ö†Ô∏è –°—É–º–º–∞ {expected_amount:.2f} ‚ÇΩ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å–∫—Ä–∏–Ω—à–æ—Ç–µ")
        
        if expected_phone:
            if phone_found:
                message_parts.append(f"‚úÖ –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–∞–π–¥–µ–Ω")
            else:
                message_parts.append(f"‚ö†Ô∏è –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω")
        
        if has_payment_keywords:
            message_parts.append("‚úÖ –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞")
        else:
            message_parts.append("‚ö†Ô∏è –ü—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã")
        
        return {
            'valid': valid,
            'amount_found': amount_found,
            'phone_found': phone_found if expected_phone else None,
            'has_payment_keywords': has_payment_keywords,
            'found_amount': found_amount,
            'message': '\n'.join(message_parts)
        }
        
    except Exception as e:
        logger.error(f"Error analyzing payment screenshot: {e}", exc_info=True)
        return {
            'valid': True,  # Allow if analysis fails (fallback)
            'amount_found': False,
            'phone_found': False,
            'message': f'‚ö†Ô∏è –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}. –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤—Ä—É—á–Ω—É—é.'
        }


# ==================== End Payment System Functions ====================


async def upload_image_to_hosting(image_data: bytes, filename: str = "image.jpg") -> str:
    """Upload image to public hosting and return public URL."""
    if not image_data or len(image_data) == 0:
        logger.error("Empty image data provided")
        return None
    
    # Try multiple hosting services
    hosting_services = [
        # 0x0.st - simple file hosting (most reliable)
        {
            'url': 'https://0x0.st',
            'method': 'POST',
            'data_type': 'form',
            'field_name': 'file'
        },
        # catbox.moe - image hosting
        {
            'url': 'https://catbox.moe/user/api.php',
            'method': 'POST',
            'data_type': 'form',
            'field_name': 'fileToUpload',
            'extra_params': {'reqtype': 'fileupload'}
        },
        # transfer.sh - file sharing
        {
            'url': f'https://transfer.sh/{filename}',
            'method': 'PUT',
            'data_type': 'raw',
            'field_name': None
        }
    ]
    
    for service in hosting_services:
        try:
            logger.info(f"Trying to upload to {service['url']}")
            session = await get_http_client()
            if service['data_type'] == 'form':
                data = aiohttp.FormData()
                # Add extra params if needed
                if 'extra_params' in service:
                    for key, value in service['extra_params'].items():
                        data.add_field(key, value)
                
                # Add file
                data.add_field(
                    service['field_name'],
                    BytesIO(image_data),
                    filename=filename,
                    content_type='image/jpeg'
                )
                
                async with session.post(service['url'], data=data, timeout=aiohttp.ClientTimeout(total=30)) as resp:
                    status = resp.status
                    text = await resp.text()
                    logger.info(f"Response from {service['url']}: status={status}, text={text[:100]}")
                    
                    if status in [200, 201]:
                        text = text.strip()
                        # For catbox.moe, response is direct URL
                        if 'catbox.moe' in service['url']:
                            if text.startswith('http'):
                                return text
                        # For 0x0.st, response is direct URL
                        elif text.startswith('http'):
                            return text
                    else:
                        logger.warning(f"Upload to {service['url']} failed with status {status}: {text[:200]}")
            else:  # raw
                    headers = {'Content-Type': 'image/jpeg', 'Max-Downloads': '1', 'Max-Days': '7'}
                    async with session.put(service['url'], data=image_data, headers=headers, timeout=aiohttp.ClientTimeout(total=30)) as resp:
                        status = resp.status
                        text = await resp.text()
                        logger.info(f"Response from {service['url']}: status={status}, text={text[:100]}")
                        
                        if status in [200, 201]:
                            text = text.strip()
                            if text.startswith('http'):
                                return text
                        else:
                            logger.warning(f"Upload to {service['url']} failed with status {status}: {text[:200]}")
        except asyncio.TimeoutError:
            logger.warning(f"Timeout uploading to {service['url']}")
            continue
        except Exception as e:
            logger.error(f"Exception uploading to {service['url']}: {e}", exc_info=True)
            continue
    
    # If all services fail, return None
    logger.error("All image hosting services failed. Image size: {} bytes".format(len(image_data)))
    return None


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send a marketing welcome message with model selection."""
    user = update.effective_user
    user_id = user.id
    
    # Check if language is set, if not - show language selection
    if not has_user_language_set(user_id):
        keyboard = [
            [
                InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="language_select:ru"),
                InlineKeyboardButton("üá¨üáß English", callback_data="language_select:en")
            ]
        ]
        await update.message.reply_html(
            t('select_language', lang='ru'),
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return
    
    # Check if user is admin
    is_admin = (user_id == ADMIN_ID)
    
    # Get user language
    user_lang = get_user_language(user_id)
    
    # Get generation types and models count
    generation_types = get_generation_types()
    total_models = len(KIE_MODELS)
    
    # Both admin and regular users see the same menu, but admin gets additional "Admin Panel" button
    # Common menu for both admin and regular users
    remaining_free = get_user_free_generations_remaining(user_id)
    is_new = is_new_user(user_id)
    referral_link = get_user_referral_link(user_id)
    referrals_count = len(get_user_referrals(user_id))
    online_count = get_fake_online_count()
    
    # Use translations
    if is_new:
        welcome_text = t('welcome_new', lang=user_lang,
                        name=user.mention_html(),
                        free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                        models=total_models,
                        types=len(generation_types),
                        online=online_count,
                        ref_bonus=REFERRAL_BONUS_GENERATIONS,
                        ref_link=referral_link)
    else:
        referral_bonus_text = ""
        if referrals_count > 0:
            if user_lang == 'ru':
                referral_bonus_text = (
                    f"\nüéÅ <b>–û—Ç–ª–∏—á–Ω–æ!</b> –¢—ã –ø—Ä–∏–≥–ª–∞—Å–∏–ª <b>{referrals_count}</b> –¥—Ä—É–∑–µ–π\n"
                    f"   ‚Üí –ü–æ–ª—É—á–µ–Ω–æ <b>+{referrals_count * REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>! üéâ\n\n"
                )
            else:
                referral_bonus_text = (
                    f"\nüéÅ <b>Great!</b> You invited <b>{referrals_count}</b> friends\n"
                    f"   ‚Üí Received <b>+{referrals_count * REFERRAL_BONUS_GENERATIONS} free generations</b>! üéâ\n\n"
                )
        
        welcome_text = t('welcome_returning', lang=user_lang,
                        name=user.mention_html(),
                        online=online_count,
                        free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                        models=total_models,
                        types=len(generation_types))
        welcome_text += referral_bonus_text
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–∏–ø–∞—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        gen_types_info = []
        for gen_type in generation_types:
            gen_info = get_generation_type_info(gen_type)
            gen_types_info.append(f"‚Ä¢ {gen_info.get('name', gen_type)} - {gen_info.get('description', '')}")
        
        if user_lang == 'ru':
            welcome_text += (
                f'üíé <b>–ü–û–õ–ù–´–ô –§–£–ù–ö–¶–ò–û–ù–ê–õ:</b>\n\n'
                f'<b>üì∏ –†–ê–ë–û–¢–ê –° –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø–ú–ò:</b>\n'
                f'‚Ä¢ ‚ú® –¢–µ–∫—Å—Ç –≤ —Ñ–æ—Ç–æ - —Å–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏–∑ —Ç–µ–∫—Å—Ç–∞\n'
                f'‚Ä¢ üé® –§–æ—Ç–æ –≤ —Ñ–æ—Ç–æ - —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –∏ —Å—Ç–∏–ª–∏–∑–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n'
                f'‚Ä¢ üñºÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–æ—Ç–æ - —É–ª—É—á—à–µ–Ω–∏–µ, –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ, —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–æ–Ω–∞\n'
                f'‚Ä¢ üé® –†–µ—Ñ—Ä–µ–π–º–∏–Ω–≥ - –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–∞–¥—Ä–∞ –∏ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è —Å—Ç–æ—Ä–æ–Ω\n\n'
                f'<b>üé¨ –†–ê–ë–û–¢–ê –° –í–ò–î–ï–û:</b>\n'
                f'‚Ä¢ üé¨ –¢–µ–∫—Å—Ç –≤ –≤–∏–¥–µ–æ - —Å–æ–∑–¥–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è\n'
                f'‚Ä¢ üì∏ –§–æ—Ç–æ –≤ –≤–∏–¥–µ–æ - –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –¥–∏–Ω–∞–º–∏—á–Ω—ã–µ –≤–∏–¥–µ–æ\n'
                f'‚Ä¢ üéôÔ∏è –†–µ—á—å –≤ –≤–∏–¥–µ–æ - —Å–æ–∑–¥–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∏–∑ —Ä–µ—á–∏ –∏ –∞—É–¥–∏–æ\n'
                f'‚Ä¢ üëÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≥—É–± - –∞–≤–∞—Ç–∞—Ä—ã —Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–µ–π –≥—É–±\n'
                f'‚Ä¢ ‚úÇÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ - —É–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞, —É–¥–∞–ª–µ–Ω–∏–µ –≤–æ–¥—è–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤\n\n'
                f'<b>üéôÔ∏è –†–ê–ë–û–¢–ê –° –ê–£–î–ò–û:</b>\n'
                f'‚Ä¢ üéôÔ∏è –†–µ—á—å –≤ —Ç–µ–∫—Å—Ç - –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ä–µ—á–∏ –≤ —Ç–µ–∫—Å—Ç —Å –≤—ã—Å–æ–∫–æ–π —Ç–æ—á–Ω–æ—Å—Ç—å—é\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üÜì <b>–ë–ï–°–ü–õ–ê–¢–ù–´–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–´:</b>\n'
                f'‚Ä¢ <b>Recraft Remove Background</b> - —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–æ–Ω–∞ (–±–µ—Å–ø–ª–∞—Ç–Ω–æ –∏ –±–µ–∑–ª–∏–º–∏—Ç–Ω–æ!)\n'
                f'‚Ä¢ <b>Recraft Crisp Upscale</b> - —É–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–±–µ—Å–ø–ª–∞—Ç–Ω–æ –∏ –±–µ–∑–ª–∏–º–∏—Ç–Ω–æ!)\n'
                f'‚Ä¢ <b>Z-Image</b> - –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π ({FREE_GENERATIONS_PER_DAY} —Ä–∞–∑ –≤ –¥–µ–Ω—å, –º–æ–∂–Ω–æ —É–≤–µ–ª–∏—á–∏—Ç—å —á–µ—Ä–µ–∑ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è!)\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üìä <b>–°–¢–ê–¢–ò–°–¢–ò–ö–ê:</b>\n'
                f'‚Ä¢ {total_models} —Ç–æ–ø–æ–≤—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π\n'
                f'‚Ä¢ {len(generation_types)} —Ç–∏–ø–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n'
                f'‚Ä¢ üåê –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –ë–ï–ó VPN\n'
                f'‚Ä¢ ‚ö° –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n\n'
                f'üí∞ <b>–¶–ï–ù–´:</b>\n'
                f'–û—Ç 0.62 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ ‚Ä¢ –û—Ç 3.86 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ\n\n'
                f'üí° <b>–ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ ‚Üí –ø–æ–ª—É—á–∏ +{REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π Z-Image!</b>\n'
                f'üîó <code>{referral_link}</code>\n\n'
                f'üéØ <b>–í—ã–±–µ—Ä–∏ —Ñ–æ—Ä–º–∞—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–∏–∂–µ –∏–ª–∏ –Ω–∞—á–Ω–∏ —Å –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π!</b>'
            )
        else:
            welcome_text += (
                f'üíé <b>FULL FUNCTIONALITY:</b>\n\n'
                f'<b>üì∏ IMAGE GENERATION:</b>\n'
                f'‚Ä¢ ‚ú® Text to Image - create images from text\n'
                f'‚Ä¢ üé® Image to Image - transform and style images\n'
                f'‚Ä¢ üñºÔ∏è Image Editing - enhance, upscale, remove background\n'
                f'‚Ä¢ üé® Reframing - change frame and aspect ratio\n\n'
                f'<b>üé¨ VIDEO GENERATION:</b>\n'
                f'‚Ä¢ üé¨ Text to Video - create videos from text descriptions\n'
                f'‚Ä¢ üì∏ Image to Video - turn images into dynamic videos\n'
                f'‚Ä¢ üéôÔ∏è Speech to Video - create videos from speech and audio\n'
                f'‚Ä¢ üëÑ Lip Sync - avatars with lip synchronization\n'
                f'‚Ä¢ ‚úÇÔ∏è Video Editing - quality enhancement, watermark removal\n\n'
                f'<b>üéôÔ∏è AUDIO PROCESSING:</b>\n'
                f'‚Ä¢ üéôÔ∏è Speech to Text - convert speech to text with high accuracy\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üÜì <b>FREE TOOLS:</b>\n'
                f'‚Ä¢ <b>Recraft Remove Background</b> - remove background (free and unlimited!)\n'
                f'‚Ä¢ <b>Recraft Crisp Upscale</b> - enhance image quality (free and unlimited!)\n'
                f'‚Ä¢ <b>Z-Image</b> - image generation ({FREE_GENERATIONS_PER_DAY} times per day, can be increased by inviting users!)\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üìä <b>STATISTICS:</b>\n'
                f'‚Ä¢ {total_models} top AI models\n'
                f'‚Ä¢ {len(generation_types)} generation types\n'
                f'‚Ä¢ üåê Direct access WITHOUT VPN\n'
                f'‚Ä¢ ‚ö° Instant generation\n\n'
                f'üí∞ <b>PRICING:</b>\n'
                f'From 0.62 ‚ÇΩ per image ‚Ä¢ From 3.86 ‚ÇΩ per video\n\n'
                f'üí° <b>Invite a friend ‚Üí get +{REFERRAL_BONUS_GENERATIONS} free Z-Image generations!</b>\n'
                f'üîó <code>{referral_link}</code>\n\n'
                f'üéØ <b>Choose generation format below or start with free!</b>'
            )
    
    # Common keyboard for both admin and regular users
    keyboard = []
    
    # Free generation button (ALWAYS prominent - biggest button)
    if remaining_free > 0:
        if user_lang == 'ru':
            button_text = f"üéÅ –ì–ï–ù–ï–†–ò–†–û–í–ê–¢–¨ –ë–ï–°–ü–õ–ê–¢–ù–û ({remaining_free} –æ—Å—Ç–∞–ª–æ—Å—å)"
        else:
            button_text = f"üéÅ GENERATE FREE ({remaining_free} left)"
        keyboard.append([
            InlineKeyboardButton(button_text, callback_data="select_model:z-image")
        ])
        keyboard.append([])  # Empty row for spacing
    
    # Generation types buttons (compact, 2 per row)
    # Find text-to-image type and add it after free generation button
    text_to_image_type = None
    gen_type_rows = []
    for i, gen_type in enumerate(generation_types):
        gen_info = get_generation_type_info(gen_type)
        models_count = len(get_models_by_generation_type(gen_type))
        
        # Identify text-to-image type
        if gen_type == 'text-to-image':
            text_to_image_type = gen_type
            continue
            
        button_text = f"{gen_info.get('name', gen_type)} ({models_count})"
        
        if i % 2 == 0:
            gen_type_rows.append([InlineKeyboardButton(
                button_text,
                callback_data=f"gen_type:{gen_type}"
            )])
        else:
            if gen_type_rows:
                gen_type_rows[-1].append(InlineKeyboardButton(
                    button_text,
                    callback_data=f"gen_type:{gen_type}"
                ))
            else:
                gen_type_rows.append([InlineKeyboardButton(
                    button_text,
                    callback_data=f"gen_type:{gen_type}"
                )])
    
    # Add text-to-image button after free generation (if it exists)
    if text_to_image_type:
        gen_info = get_generation_type_info(text_to_image_type)
        models_count = len(get_models_by_generation_type(text_to_image_type))
        button_text = f"{gen_info.get('name', text_to_image_type)} ({models_count})"
        keyboard.append([
            InlineKeyboardButton(button_text, callback_data=f"gen_type:{text_to_image_type}")
        ])
        keyboard.append([])  # Empty row for spacing
    
    keyboard.extend(gen_type_rows)
    
    # Add "Claim Gift" button for new users who haven't claimed yet
    if is_new and not has_claimed_gift(user_id):
        if user_lang == 'ru':
            keyboard.append([
                InlineKeyboardButton("üé∞ –ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥–∞—Ä–æ–∫", callback_data="claim_gift")
            ])
        else:
            keyboard.append([
                InlineKeyboardButton("üé∞ Claim Gift", callback_data="claim_gift")
            ])
        keyboard.append([])  # Empty row for spacing
    
    # Bottom action buttons
    keyboard.append([
        InlineKeyboardButton(t('balance', lang=user_lang), callback_data="check_balance"),
        InlineKeyboardButton(t('my_generations', lang=user_lang), callback_data="my_generations")
    ])
    keyboard.append([
        InlineKeyboardButton(t('balance', lang=user_lang).replace('üí∞ ', 'üí≥ '), callback_data="topup_balance") if user_lang == 'ru' else InlineKeyboardButton("üí≥ Top up", callback_data="topup_balance"),
        InlineKeyboardButton(t('referral', lang=user_lang), callback_data="referral_info")
    ])
    
    # Add tutorial button for new users
    if is_new:
        if user_lang == 'ru':
            keyboard.append([
                InlineKeyboardButton("‚ùì –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?", callback_data="tutorial_start")
            ])
        else:
            keyboard.append([
                InlineKeyboardButton("‚ùì How it works?", callback_data="tutorial_start")
            ])
    
    keyboard.append([
        InlineKeyboardButton(t('help', lang=user_lang), callback_data="help_menu"),
        InlineKeyboardButton(t('support', lang=user_lang), callback_data="support_contact")
    ])
    
    # Add admin panel button ONLY for admin (at the end)
    if is_admin:
        keyboard.append([])  # Empty row for admin section
        if user_lang == 'ru':
            keyboard.append([
                InlineKeyboardButton("üëë –ê–î–ú–ò–ù –ü–ê–ù–ï–õ–¨", callback_data="admin_stats")
            ])
        else:
            keyboard.append([
                InlineKeyboardButton("üëë ADMIN PANEL", callback_data="admin_stats")
            ])
    
    await update.message.reply_html(
        welcome_text,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send a message when the command /help is issued."""
    await update.message.reply_text(
        'üìã <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n\n'
        '/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n'
        '/models - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π\n'
        '/generate - –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
        '/balance - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
        '/cancel - –û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é\n'
        '/search [–∑–∞–ø—Ä–æ—Å] - –ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π\n'
        '/ask [–≤–æ–ø—Ä–æ—Å] - –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å\n'
        '/add [–∑–Ω–∞–Ω–∏–µ] - –î–æ–±–∞–≤–∏—Ç—å –∑–Ω–∞–Ω–∏–µ –≤ –±–∞–∑—É\n\n'
        'üí° <b>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:</b>\n'
        '1. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /models —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏\n'
        '2. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /balance —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
        '3. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /generate —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n'
        '4. –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞\n'
        '5. –í–≤–µ–¥–∏—Ç–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n'
        '6. –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç!',
        parse_mode='HTML'
    )


async def list_models(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """List available models from static menu."""
    user_id = update.effective_user.id
    
    # Get models grouped by category
    categories = get_categories()
    
    # Create category selection keyboard
    keyboard = []
    for category in categories:
        models_in_category = get_models_by_category(category)
        emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
        keyboard.append([InlineKeyboardButton(
            f"{emoji} {category} ({len(models_in_category)})",
            callback_data=f"category:{category}"
        )])
    
    keyboard.append([InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")])
    keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    models_text = "üìã <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:</b>\n\n"
    models_text += "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–ª–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤—Å–µ –º–æ–¥–µ–ª–∏:\n\n"
    for category in categories:
        models_in_category = get_models_by_category(category)
        models_text += f"<b>{category}</b>: {len(models_in_category)} –º–æ–¥–µ–ª–µ–π\n"
    
    await update.message.reply_text(
        models_text,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )


async def start_generation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start the generation process."""
    global kie
    user_id = update.effective_user.id
    
    # Check if KIE API is configured (initialize if needed)
    if kie is None:
        kie = get_client()
    if not kie.api_key:
        await update.message.reply_text(
            '‚ùå API –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –£–∫–∞–∂–∏—Ç–µ API –∫–ª—é—á –≤ —Ñ–∞–π–ª–µ .env'
        )
        return
    
    await update.message.reply_text(
        'üöÄ –ù–∞—á–∏–Ω–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é!\n\n'
        '–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞:',
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("üìã –ü–æ–∫–∞–∑–∞—Ç—å –º–æ–¥–µ–ª–∏", callback_data="show_models")
        ]])
    )
    
    return SELECTING_MODEL


async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle button callbacks."""
    try:
        query = update.callback_query
        if not query:
            logger.error("No callback_query in update")
            return ConversationHandler.END
        
        user_id = update.effective_user.id
        data = query.data
        
        if not data:
            logger.error("No data in callback_query")
            try:
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–ø—Ä–æ—Å–µ", show_alert=True)
            except:
                pass
            return ConversationHandler.END
    except Exception as e:
        logger.error(f"Error in button_callback setup: {e}", exc_info=True)
        return ConversationHandler.END
    
    # Wrap all callback handling in try-except for error handling
    try:
        # Initialize common variables that might be used in multiple handlers
        # This prevents UnboundLocalError if variable is assigned in one branch but used in another
        categories = None
        total_models = None
        tutorial_text = None
        help_text = None
        referral_text = None
        history_text = None
        model_info_text = None
        prompt_text = None
        admin_text = None
        settings_text = None
        promocodes_text = None
        broadcast_text = None
        stats_text = None
        
        # Handle language selection
        if data.startswith("language_select:"):
            lang_code = data.split(":")[1]
            if lang_code in ['ru', 'en']:
                set_user_language(user_id, lang_code)
                user_lang = get_user_language(user_id)
                
                # Confirm button press
                if user_lang == 'ru':
                    await query.answer("‚úÖ –Ø–∑—ã–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: –†—É—Å—Å–∫–∏–π")
                else:
                    await query.answer("‚úÖ Language set: English")
                
                # After language selection, show full welcome menu (same as /start)
                # Get user info
                user = update.effective_user
                is_admin = (user_id == ADMIN_ID)
                
                # Get generation types and models count
                generation_types = get_generation_types()
                total_models = len(KIE_MODELS)
                
                # Common menu for both admin and regular users
                remaining_free = get_user_free_generations_remaining(user_id)
                is_new = is_new_user(user_id)
                referral_link = get_user_referral_link(user_id)
                referrals_count = len(get_user_referrals(user_id))
                online_count = get_fake_online_count()
                
                # Use translations for welcome message
                if is_new:
                    welcome_text = t('welcome_new', lang=user_lang,
                                    name=user.mention_html(),
                                    free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                                    models=total_models,
                                    types=len(generation_types),
                                    online=online_count,
                                    ref_bonus=REFERRAL_BONUS_GENERATIONS,
                                    ref_link=referral_link)
                else:
                    referral_bonus_text = ""
                    if referrals_count > 0:
                        if user_lang == 'ru':
                            referral_bonus_text = (
                                f"\nüéÅ <b>–û—Ç–ª–∏—á–Ω–æ!</b> –¢—ã –ø—Ä–∏–≥–ª–∞—Å–∏–ª <b>{referrals_count}</b> –¥—Ä—É–∑–µ–π\n"
                                f"   ‚Üí –ü–æ–ª—É—á–µ–Ω–æ <b>+{referrals_count * REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>! üéâ\n\n"
                            )
                        else:
                            referral_bonus_text = (
                                f"\nüéÅ <b>Great!</b> You invited <b>{referrals_count}</b> friends\n"
                                f"   ‚Üí Received <b>+{referrals_count * REFERRAL_BONUS_GENERATIONS} free generations</b>! üéâ\n\n"
                            )
                    
                    welcome_text = t('welcome_returning', lang=user_lang,
                                    name=user.mention_html(),
                                    online=online_count,
                                    free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                                    models=total_models,
                                    types=len(generation_types))
                    welcome_text += referral_bonus_text
                    
                    if user_lang == 'ru':
                        welcome_text += (
                            f'üíé <b>–ü–û–õ–ù–´–ô –§–£–ù–ö–¶–ò–û–ù–ê–õ:</b>\n\n'
                            f'<b>üì∏ –†–ê–ë–û–¢–ê –° –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø–ú–ò:</b>\n'
                            f'‚Ä¢ ‚ú® –¢–µ–∫—Å—Ç –≤ —Ñ–æ—Ç–æ - —Å–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏–∑ —Ç–µ–∫—Å—Ç–∞\n'
                            f'‚Ä¢ üé® –§–æ—Ç–æ –≤ —Ñ–æ—Ç–æ - —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –∏ —Å—Ç–∏–ª–∏–∑–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n'
                            f'‚Ä¢ üñºÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–æ—Ç–æ - —É–ª—É—á—à–µ–Ω–∏–µ, –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ, —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–æ–Ω–∞\n'
                            f'‚Ä¢ üé® –†–µ—Ñ—Ä–µ–π–º–∏–Ω–≥ - –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–∞–¥—Ä–∞ –∏ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è —Å—Ç–æ—Ä–æ–Ω\n\n'
                            f'<b>üé¨ –†–ê–ë–û–¢–ê –° –í–ò–î–ï–û:</b>\n'
                            f'‚Ä¢ üé¨ –¢–µ–∫—Å—Ç –≤ –≤–∏–¥–µ–æ - —Å–æ–∑–¥–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è\n'
                            f'‚Ä¢ üì∏ –§–æ—Ç–æ –≤ –≤–∏–¥–µ–æ - –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –¥–∏–Ω–∞–º–∏—á–Ω—ã–µ –≤–∏–¥–µ–æ\n'
                            f'‚Ä¢ üéôÔ∏è –†–µ—á—å –≤ –≤–∏–¥–µ–æ - —Å–æ–∑–¥–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∏–∑ —Ä–µ—á–∏ –∏ –∞—É–¥–∏–æ\n'
                            f'‚Ä¢ üëÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≥—É–± - –∞–≤–∞—Ç–∞—Ä—ã —Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–µ–π –≥—É–±\n'
                            f'‚Ä¢ ‚úÇÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ - —É–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞, —É–¥–∞–ª–µ–Ω–∏–µ –≤–æ–¥—è–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤\n\n'
                            f'<b>üéôÔ∏è –†–ê–ë–û–¢–ê –° –ê–£–î–ò–û:</b>\n'
                            f'‚Ä¢ üéôÔ∏è –†–µ—á—å –≤ —Ç–µ–∫—Å—Ç - –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ä–µ—á–∏ –≤ —Ç–µ–∫—Å—Ç —Å –≤—ã—Å–æ–∫–æ–π —Ç–æ—á–Ω–æ—Å—Ç—å—é\n\n'
                            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                            f'üÜì <b>–ë–ï–°–ü–õ–ê–¢–ù–´–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–´:</b>\n'
                            f'‚Ä¢ <b>Recraft Remove Background</b> - —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–æ–Ω–∞ (–±–µ—Å–ø–ª–∞—Ç–Ω–æ –∏ –±–µ–∑–ª–∏–º–∏—Ç–Ω–æ!)\n'
                            f'‚Ä¢ <b>Recraft Crisp Upscale</b> - —É–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–±–µ—Å–ø–ª–∞—Ç–Ω–æ –∏ –±–µ–∑–ª–∏–º–∏—Ç–Ω–æ!)\n'
                            f'‚Ä¢ <b>Z-Image</b> - –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π ({FREE_GENERATIONS_PER_DAY} —Ä–∞–∑ –≤ –¥–µ–Ω—å, –º–æ–∂–Ω–æ —É–≤–µ–ª–∏—á–∏—Ç—å —á–µ—Ä–µ–∑ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è!)\n\n'
                            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                            f'üìä <b>–°–¢–ê–¢–ò–°–¢–ò–ö–ê:</b>\n'
                            f'‚Ä¢ {total_models} —Ç–æ–ø–æ–≤—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π\n'
                            f'‚Ä¢ {len(generation_types)} —Ç–∏–ø–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n'
                            f'‚Ä¢ üåê –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –ë–ï–ó VPN\n'
                            f'‚Ä¢ ‚ö° –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n\n'
                            f'üí∞ <b>–¶–ï–ù–´:</b>\n'
                            f'–û—Ç 0.62 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ ‚Ä¢ –û—Ç 3.86 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ\n\n'
                            f'üí° <b>–ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ ‚Üí –ø–æ–ª—É—á–∏ +{REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π Z-Image!</b>\n'
                            f'üîó <code>{referral_link}</code>\n\n'
                            f'üéØ <b>–í—ã–±–µ—Ä–∏ —Ñ–æ—Ä–º–∞—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–∏–∂–µ –∏–ª–∏ –Ω–∞—á–Ω–∏ —Å –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π!</b>'
                        )
                    else:
                        welcome_text += (
                            f'üíé <b>FULL FUNCTIONALITY:</b>\n\n'
                            f'<b>üì∏ IMAGE GENERATION:</b>\n'
                            f'‚Ä¢ ‚ú® Text to Image - create images from text\n'
                            f'‚Ä¢ üé® Image to Image - transform and style images\n'
                            f'‚Ä¢ üñºÔ∏è Image Editing - enhance, upscale, remove background\n'
                            f'‚Ä¢ üé® Reframing - change frame and aspect ratio\n\n'
                            f'<b>üé¨ VIDEO GENERATION:</b>\n'
                            f'‚Ä¢ üé¨ Text to Video - create videos from text descriptions\n'
                            f'‚Ä¢ üì∏ Image to Video - turn images into dynamic videos\n'
                            f'‚Ä¢ üéôÔ∏è Speech to Video - create videos from speech and audio\n'
                            f'‚Ä¢ üëÑ Lip Sync - avatars with lip synchronization\n'
                            f'‚Ä¢ ‚úÇÔ∏è Video Editing - quality enhancement, watermark removal\n\n'
                            f'<b>üéôÔ∏è AUDIO PROCESSING:</b>\n'
                            f'‚Ä¢ üéôÔ∏è Speech to Text - convert speech to text with high accuracy\n\n'
                            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                            f'üÜì <b>FREE TOOLS:</b>\n'
                            f'‚Ä¢ <b>Recraft Remove Background</b> - remove background (free and unlimited!)\n'
                            f'‚Ä¢ <b>Recraft Crisp Upscale</b> - enhance image quality (free and unlimited!)\n'
                            f'‚Ä¢ <b>Z-Image</b> - image generation ({FREE_GENERATIONS_PER_DAY} times per day, can be increased by inviting users!)\n\n'
                            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                            f'üìä <b>STATISTICS:</b>\n'
                            f'‚Ä¢ {total_models} top AI models\n'
                            f'‚Ä¢ {len(generation_types)} generation types\n'
                            f'‚Ä¢ üåê Direct access WITHOUT VPN\n'
                            f'‚Ä¢ ‚ö° Instant generation\n\n'
                            f'üí∞ <b>PRICING:</b>\n'
                            f'From 0.62 ‚ÇΩ per image ‚Ä¢ From 3.86 ‚ÇΩ per video\n\n'
                            f'üí° <b>Invite a friend ‚Üí get +{REFERRAL_BONUS_GENERATIONS} free Z-Image generations!</b>\n'
                            f'üîó <code>{referral_link}</code>\n\n'
                            f'üéØ <b>Choose generation format below or start with free!</b>'
                        )
                
                # Build full keyboard (same as in start function)
                keyboard = []
                
                # Free generation button (ALWAYS prominent - biggest button)
                if remaining_free > 0:
                    if user_lang == 'ru':
                        button_text = f"üéÅ –ì–ï–ù–ï–†–ò–†–û–í–ê–¢–¨ –ë–ï–°–ü–õ–ê–¢–ù–û ({remaining_free} –æ—Å—Ç–∞–ª–æ—Å—å)"
                    else:
                        button_text = f"üéÅ GENERATE FREE ({remaining_free} left)"
                    keyboard.append([
                        InlineKeyboardButton(button_text, callback_data="select_model:z-image")
                    ])
                    keyboard.append([])  # Empty row for spacing
                
                # Generation types buttons (compact, 2 per row)
                text_to_image_type = None
                gen_type_rows = []
                for i, gen_type in enumerate(generation_types):
                    gen_info = get_generation_type_info(gen_type)
                    models_count = len(get_models_by_generation_type(gen_type))
                    
                    # Identify text-to-image type
                    if gen_type == 'text-to-image':
                        text_to_image_type = gen_type
                        continue
                        
                    button_text = f"{gen_info.get('name', gen_type)} ({models_count})"
                    
                    if i % 2 == 0:
                        gen_type_rows.append([InlineKeyboardButton(
                            button_text,
                            callback_data=f"gen_type:{gen_type}"
                        )])
                    else:
                        if gen_type_rows:
                            gen_type_rows[-1].append(InlineKeyboardButton(
                                button_text,
                                callback_data=f"gen_type:{gen_type}"
                            ))
                        else:
                            gen_type_rows.append([InlineKeyboardButton(
                                button_text,
                                callback_data=f"gen_type:{gen_type}"
                            )])
                
                # Add text-to-image button after free generation (if it exists)
                if text_to_image_type:
                    gen_info = get_generation_type_info(text_to_image_type)
                    models_count = len(get_models_by_generation_type(text_to_image_type))
                    button_text = f"{gen_info.get('name', text_to_image_type)} ({models_count})"
                    keyboard.append([
                        InlineKeyboardButton(button_text, callback_data=f"gen_type:{text_to_image_type}")
                    ])
                    keyboard.append([])  # Empty row for spacing
                
                keyboard.extend(gen_type_rows)
                
                # Add "Claim Gift" button for new users who haven't claimed yet
                if is_new and not has_claimed_gift(user_id):
                    if user_lang == 'ru':
                        keyboard.append([
                            InlineKeyboardButton("üé∞ –ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥–∞—Ä–æ–∫", callback_data="claim_gift")
                        ])
                    else:
                        keyboard.append([
                            InlineKeyboardButton("üé∞ Claim Gift", callback_data="claim_gift")
                        ])
                
                # Bottom action buttons
                keyboard.append([])  # Empty row for spacing
                if user_lang == 'ru':
                    keyboard.append([
                        InlineKeyboardButton("üí∞ –ë–∞–ª–∞–Ω—Å", callback_data="check_balance"),
                        InlineKeyboardButton("üìö –ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", callback_data="my_generations")
                    ])
                    keyboard.append([
                        InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å", callback_data="topup_balance"),
                        InlineKeyboardButton("üéÅ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–≥–∞", callback_data="referral_info")
                    ])
                else:
                    keyboard.append([
                        InlineKeyboardButton("üí∞ Balance", callback_data="check_balance"),
                        InlineKeyboardButton("üìö My Generations", callback_data="my_generations")
                    ])
                    keyboard.append([
                        InlineKeyboardButton("üí≥ Top Up", callback_data="topup_balance"),
                        InlineKeyboardButton("üéÅ Invite Friend", callback_data="referral_info")
                    ])
                
                # Add tutorial button for new users
                if is_new:
                    if user_lang == 'ru':
                        keyboard.append([
                            InlineKeyboardButton("‚ùì –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?", callback_data="tutorial_start")
                        ])
                    else:
                        keyboard.append([
                            InlineKeyboardButton("‚ùì How it works?", callback_data="tutorial_start")
                        ])
                
                if user_lang == 'ru':
                    keyboard.append([
                        InlineKeyboardButton("üÜò –ü–æ–º–æ—â—å", callback_data="help_menu"),
                        InlineKeyboardButton("üí¨ –ü–æ–¥–¥–µ—Ä–∂–∫–∞", callback_data="support_contact")
                    ])
                else:
                    keyboard.append([
                        InlineKeyboardButton("üÜò Help", callback_data="help_menu"),
                        InlineKeyboardButton("üí¨ Support", callback_data="support_contact")
                    ])
                
                # Add admin panel button ONLY for admin (at the end)
                if is_admin:
                    keyboard.append([])  # Empty row for admin section
                    if user_lang == 'ru':
                        keyboard.append([
                            InlineKeyboardButton("üëë –ê–î–ú–ò–ù –ü–ê–ù–ï–õ–¨", callback_data="admin_stats")
                        ])
                    else:
                        keyboard.append([
                            InlineKeyboardButton("üëë ADMIN PANEL", callback_data="admin_stats")
                        ])
                
                await query.edit_message_text(
                    welcome_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            else:
                await query.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —è–∑—ã–∫ / Invalid language")
                return ConversationHandler.END
        
        # Handle claim gift
        if data == "claim_gift":
            if has_claimed_gift(user_id):
                user_lang = get_user_language(user_id)
                if user_lang == 'ru':
                    await query.answer("–í—ã —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ –ø–æ–¥–∞—Ä–æ–∫! / You already claimed the gift!", show_alert=True)
                else:
                    await query.answer("You already claimed the gift!", show_alert=True)
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            
            # Show initial spinning message
            if user_lang == 'ru':
                await query.answer("üé∞ –ö—Ä—É—Ç–∏–º –∫–æ–ª–µ—Å–æ —Ñ–æ—Ä—Ç—É–Ω—ã...")
                spin_message = await query.edit_message_text(
                    "üé∞ <b>–ö–û–õ–ï–°–û –§–û–†–¢–£–ù–´</b> üé∞\n\n"
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    "üé≤ <b>–ö—Ä—É—Ç–∏–º –∫–æ–ª–µ—Å–æ...</b>\n\n"
                    "‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞—à –≤—ã–∏–≥—Ä—ã—à...",
                    parse_mode='HTML'
                )
            else:
                await query.answer("üé∞ Spinning the wheel of fortune...")
                spin_message = await query.edit_message_text(
                    "üé∞ <b>WHEEL OF FORTUNE</b> üé∞\n\n"
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    "üé≤ <b>Spinning the wheel...</b>\n\n"
                    "‚è≥ Please wait, determining your prize...",
                    parse_mode='HTML'
                )
            
            # Animate wheel spinning with different sectors
            wheel_sectors = [
                ("üéØ", "üé™", "üé®", "üé≠", "üé™", "üéØ"),
                ("üí∞", "üíé", "üéÅ", "‚≠ê", "üíé", "üí∞"),
                ("üé∞", "üé≤", "üéØ", "üé™", "üé≤", "üé∞"),
                ("üí´", "‚ú®", "üåü", "‚≠ê", "‚ú®", "üí´"),
                ("üéä", "üéâ", "üéà", "üéÅ", "üéâ", "üéä")
            ]
            
            progress_steps = [
                ("üîÑ", "üîÑ", "üîÑ", "üîÑ", "üîÑ", "üîÑ"),
                ("‚ö°", "‚ö°", "‚ö°", "‚ö°", "‚ö°", "‚ö°"),
                ("‚ú®", "‚ú®", "‚ú®", "‚ú®", "‚ú®", "‚ú®"),
                ("üí´", "üí´", "üí´", "üí´", "üí´", "üí´"),
                ("üéØ", "üéØ", "üéØ", "üéØ", "üéØ", "üéØ")
            ]
            
            # Show spinning animation
            for i in range(8):
                await asyncio.sleep(0.25)
                sector_idx = i % len(wheel_sectors)
                progress_idx = min(i, len(progress_steps) - 1)
                
                wheel_display = " ".join(wheel_sectors[sector_idx])
                progress_display = " ".join(progress_steps[progress_idx])
                
                # Progress bar simulation
                progress_percent = min((i + 1) * 12.5, 100)
                progress_bar = "‚ñà" * int(progress_percent / 5) + "‚ñë" * (20 - int(progress_percent / 5))
                
                try:
                    if user_lang == 'ru':
                        await spin_message.edit_text(
                            f"üé∞ <b>–ö–û–õ–ï–°–û –§–û–†–¢–£–ù–´</b> üé∞\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{wheel_display}\n\n"
                            f"<b>–ö—Ä—É—Ç–∏–º...</b> {progress_display}\n\n"
                            f"üìä [{progress_bar}] {progress_percent:.0f}%\n\n"
                            f"‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞—à –≤—ã–∏–≥—Ä—ã—à...",
                            parse_mode='HTML'
                        )
                    else:
                        await spin_message.edit_text(
                            f"üé∞ <b>WHEEL OF FORTUNE</b> üé∞\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{wheel_display}\n\n"
                            f"<b>Spinning...</b> {progress_display}\n\n"
                            f"üìä [{progress_bar}] {progress_percent:.0f}%\n\n"
                            f"‚è≥ Please wait, determining your prize...",
                            parse_mode='HTML'
                        )
                except:
                    pass
            
            # Final spin - slow down
            await asyncio.sleep(0.4)
            
            # Get the gift amount
            amount = spin_gift_wheel()
            add_user_balance(user_id, amount)
            set_gift_claimed(user_id)
            
            # Show result with celebration
            if user_lang == 'ru':
                gift_text = (
                    f'üéâ <b>–ü–û–ó–î–†–ê–í–õ–Ø–ï–ú!</b> üéâ\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üé∞ <b>–ö–û–õ–ï–°–û –û–°–¢–ê–ù–û–í–ò–õ–û–°–¨!</b> üé∞\n\n'
                    f'üéÅ <b>–í–∞—à –≤—ã–∏–≥—Ä—ã—à:</b>\n\n'
                    f'üí∞ <b>{amount:.2f} ‚ÇΩ</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚úÖ <b>–°—É–º–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞—á–∏—Å–ª–µ–Ω–∞ –Ω–∞ –≤–∞—à –±–∞–ª–∞–Ω—Å!</b>\n\n'
                    f'üí° –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ —Å—Ä–µ–¥—Å—Ç–≤–∞ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞.'
                )
            else:
                gift_text = (
                    f'üéâ <b>CONGRATULATIONS!</b> üéâ\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üé∞ <b>WHEEL STOPPED!</b> üé∞\n\n'
                    f'üéÅ <b>Your prize:</b>\n\n'
                    f'üí∞ <b>{amount:.2f} ‚ÇΩ</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚úÖ <b>Amount automatically added to your balance!</b>\n\n'
                    f'üí° Now you can use these funds for content generation.'
                )
            
            keyboard = [
                [InlineKeyboardButton("üí∞ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å" if user_lang == 'ru' else "üí∞ Check Balance", callback_data="check_balance")],
                [InlineKeyboardButton("‚óÄÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é" if user_lang == 'ru' else "‚óÄÔ∏è Main Menu", callback_data="back_to_menu")]
            ]
            
            await spin_message.edit_text(
                gift_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        # Handle admin user mode toggle (MUST be first, before any other checks)
        if data == "admin_user_mode":
            # Toggle user mode for admin
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            if user_id not in user_sessions:
                user_sessions[user_id] = {}
            
            current_mode = user_sessions[user_id].get('admin_user_mode', False)
            user_sessions[user_id]['admin_user_mode'] = not current_mode
            
            if not current_mode:
                # Switching to user mode - send new message directly
                await query.answer("–†–µ–∂–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–∫–ª—é—á–µ–Ω")
                user = update.effective_user
                categories = get_categories()
                total_models = len(KIE_MODELS)
                
                remaining_free = get_user_free_generations_remaining(user_id)
                free_info = ""
                if remaining_free > 0:
                    free_info = f"\nüéÅ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:</b> {remaining_free} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π Z-Image\n"
                
                welcome_text = (
                    f'‚ú® <b>–ü–†–ï–ú–ò–£–ú AI MARKETPLACE</b> ‚ú®\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üëã –ü—Ä–∏–≤–µ—Ç, {user.mention_html()}!\n\n'
                    f'üöÄ <b>–¢–æ–ø–æ–≤—ã–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ –±–µ–∑ VPN</b>\n'
                    f'üì¶ <b>{total_models} –º–æ–¥–µ–ª–µ–π</b> | <b>{len(categories)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b>{free_info}\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíé <b>–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:</b>\n'
                    f'‚Ä¢ –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ –º–∏—Ä–æ–≤—ã–º AI\n'
                    f'‚Ä¢ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ 2K/4K\n'
                    f'‚Ä¢ –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n\n'
                    f'üéØ <b>–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–ª–∏ –≤—Å–µ –º–æ–¥–µ–ª–∏</b>'
                )
                
                keyboard = []
                # All models button first
                keyboard.append([
                    InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
                ])
                
                keyboard.append([])
                for category in categories:
                    models_in_category = get_models_by_category(category)
                    emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
                    keyboard.append([InlineKeyboardButton(
                        f"{emoji} {category} ({len(models_in_category)})",
                        callback_data=f"category:{category}"
                    )])
                
                keyboard.append([
                    InlineKeyboardButton("üí∞ –ë–∞–ª–∞–Ω—Å", callback_data="check_balance")
                ])
                keyboard.append([
                    InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="topup_balance")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîô –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å", callback_data="admin_back_to_admin")
                ])
                keyboard.append([
                    InlineKeyboardButton("üÜò –ü–æ–º–æ—â—å", callback_data="help_menu"),
                    InlineKeyboardButton("üí¨ –ü–æ–¥–¥–µ—Ä–∂–∫–∞", callback_data="support_contact")
                ])
                
                await query.message.reply_text(
                    welcome_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            else:
                # Switching back to admin mode - send new message with full admin panel
                user_sessions[user_id]['admin_user_mode'] = False
                await query.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å")
                user = update.effective_user
                generation_types = get_generation_types()
                total_models = len(KIE_MODELS)
                
                welcome_text = (
                    f'üëë ‚ú® <b>–ü–ê–ù–ï–õ–¨ –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†–ê</b> ‚ú®\n\n'
                    f'–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}! üëã\n\n'
                    f'üéØ <b>–ü–û–õ–ù–´–ô –ö–û–ù–¢–†–û–õ–¨ –ù–ê–î AI MARKETPLACE</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üìä <b>–°–¢–ê–¢–ò–°–¢–ò–ö–ê –°–ò–°–¢–ï–ú–´:</b>\n\n'
                    f'‚úÖ <b>{total_models} –ø—Ä–µ–º–∏—É–º –º–æ–¥–µ–ª–µ–π</b> –≤ –∞—Ä—Å–µ–Ω–∞–ª–µ\n'
                    f'‚úÖ <b>{len(generation_types)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b> –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
                    f'‚úÖ –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—è–º\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üî• <b>–¢–û–ü–û–í–´–ï –ú–û–î–ï–õ–ò –í –°–ò–°–¢–ï–ú–ï:</b>\n\n'
                    f'üé® <b>Google Imagen 4 Ultra</b> - –§–ª–∞–≥–º–∞–Ω –æ—Ç Google DeepMind\n'
                    f'   üí∞ –ë–µ–∑–ª–∏–º–∏—Ç (—Ü–µ–Ω–∞: 4.63 ‚ÇΩ)\n'
                    f'   ‚≠êÔ∏è –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è\n\n'
                    f'üçå <b>Nano Banana Pro</b> - 4K –æ—Ç Google\n'
                    f'   üí∞ –ë–µ–∑–ª–∏–º–∏—Ç (1K/2K: 6.95 ‚ÇΩ, 4K: 9.27 ‚ÇΩ)\n'
                    f'   üéØ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è 2K/4K\n\n'
                    f'üé• <b>Sora 2</b> - –í–∏–¥–µ–æ –æ—Ç OpenAI\n'
                    f'   üí∞ –ë–µ–∑–ª–∏–º–∏—Ç (—Ü–µ–Ω–∞: 11.58 ‚ÇΩ) –∑–∞ 10-—Å–µ–∫—É–Ω–¥–Ω–æ–µ –≤–∏–¥–µ–æ\n'
                    f'   üé¨ –ö–∏–Ω–µ–º–∞—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –≤–∏–¥–µ–æ —Å –∞—É–¥–∏–æ\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚öôÔ∏è <b>–ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–´–ï –í–û–ó–ú–û–ñ–ù–û–°–¢–ò:</b>\n\n'
                    f'üìà –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏\n'
                    f'üë• –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n'
                    f'üéÅ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏\n'
                    f'üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ OCR —Å–∏—Å—Ç–µ–º—ã\n'
                    f'üíº –ü–æ–ª–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –±–æ—Ç–æ–º\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí´ <b>–ù–ê–ß–ù–ò–¢–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–õ–ò –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï!</b>'
                )
                
                keyboard = []
                # All models button first
                keyboard.append([
                    InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
                ])
                
                keyboard.append([])
                for category in categories:
                    models_in_category = get_models_by_category(category)
                    emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
                    keyboard.append([InlineKeyboardButton(
                        f"{emoji} {category} ({len(models_in_category)})",
                        callback_data=f"category:{category}"
                    )])
                
                keyboard.append([
                    InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models"),
                    InlineKeyboardButton("üí∞ –ë–∞–ª–∞–Ω—Å", callback_data="check_balance")
                ])
                keyboard.append([
                    InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin_stats"),
                    InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="admin_settings")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data="admin_search"),
                    InlineKeyboardButton("üìù –î–æ–±–∞–≤–∏—Ç—å", callback_data="admin_add")
                ])
                keyboard.append([
                    InlineKeyboardButton("üß™ –¢–µ—Å—Ç OCR", callback_data="admin_test_ocr")
                ])
                keyboard.append([
                    InlineKeyboardButton("üë§ –†–µ–∂–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", callback_data="admin_user_mode")
                ])
                keyboard.append([InlineKeyboardButton("üÜò –ü–æ–º–æ—â—å", callback_data="help_menu")])
                
                await query.message.reply_text(
                    welcome_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
        
        if data == "admin_back_to_admin":
            # Return to admin mode - send new message directly
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            if user_id in user_sessions:
                user_sessions[user_id]['admin_user_mode'] = False
            await query.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å")
            user = update.effective_user
            categories = get_categories()
            total_models = len(KIE_MODELS)
            
            welcome_text = (
                f'üëë <b>–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n'
                f'–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}! üëã\n\n'
                f'üöÄ <b>–†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ –º–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</b>\n\n'
                f'üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n'
                f'‚úÖ <b>{total_models} –º–æ–¥–µ–ª–µ–π</b> –¥–æ—Å—Ç—É–ø–Ω–æ\n'
                f'‚úÖ <b>{len(categories)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b>\n\n'
                f'‚öôÔ∏è <b>–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã</b>'
            )
            
            keyboard = []
            
            # All models button first
            keyboard.append([
                InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
            ])
            
            keyboard.append([])
            for category in categories:
                models_in_category = get_models_by_category(category)
                emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
                keyboard.append([InlineKeyboardButton(
                    f"{emoji} {category} ({len(models_in_category)})",
                    callback_data=f"category:{category}"
                )])
            
            keyboard.append([
                InlineKeyboardButton("üí∞ –ë–∞–ª–∞–Ω—Å", callback_data="check_balance")
            ])
            keyboard.append([
                InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin_stats"),
                InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="admin_settings")
            ])
            keyboard.append([
                InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data="admin_search"),
                InlineKeyboardButton("üìù –î–æ–±–∞–≤–∏—Ç—å", callback_data="admin_add")
            ])
            keyboard.append([
                InlineKeyboardButton("üß™ –¢–µ—Å—Ç OCR", callback_data="admin_test_ocr")
            ])
            keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")])
            
            await query.message.reply_text(
                welcome_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "back_to_menu":
            # Return to start menu - recreate the same menu as /start
            try:
                user = update.effective_user
                user_id = user.id
                is_admin = (user_id == ADMIN_ID)
                
                generation_types = get_generation_types()
                total_models = len(KIE_MODELS)
                remaining_free = get_user_free_generations_remaining(user_id)
                is_new = is_new_user(user_id)
                referral_link = get_user_referral_link(user_id)
                referrals_count = len(get_user_referrals(user_id))
                
                if is_new:
                    online_count = get_fake_online_count()
                    welcome_text = (
                    f'üéâ <b>–ü–†–ò–í–ï–¢, {user.mention_html()}!</b> üéâ\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üî• <b>–£ –¢–ï–ë–Ø –ï–°–¢–¨ {remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY} –ë–ï–°–ü–õ–ê–¢–ù–´–• –ì–ï–ù–ï–†–ê–¶–ò–ô!</b> üî•\n\n'
                    f'‚ú® <b>–ü–†–ï–ú–ò–£–ú AI MARKETPLACE</b> ‚ú®\n\n'
                    f'üöÄ <b>–ß—Ç–æ —ç—Ç–æ –∑–∞ –±–æ—Ç?</b>\n'
                    f'‚Ä¢ üì¶ <b>{total_models} —Ç–æ–ø–æ–≤—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π</b> –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ\n'
                    f'‚Ä¢ üéØ <b>{len(generation_types)} —Ç–∏–ø–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b> –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
                    f'‚Ä¢ üåê –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –ë–ï–ó VPN\n'
                    f'‚Ä¢ ‚ö° –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚ú® <b>Z-Image - –°–ê–ú–ê–Ø –ö–†–£–¢–ê–Ø –ù–ï–ô–†–û–°–ï–¢–¨ –î–õ–Ø –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô!</b> ‚ú®\n\n'
                    f'üíé <b>–ü–æ—á–µ–º—É Z-Image?</b>\n'
                    f'‚Ä¢ üé® –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n'
                    f'‚Ä¢ ‚ö° –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è (10-30 —Å–µ–∫—É–Ω–¥)\n'
                    f'‚Ä¢ üéØ –†–∞–±–æ—Ç–∞–µ—Ç –ë–ï–ó VPN\n'
                    f'‚Ä¢ üí∞ <b>–ü–û–õ–ù–û–°–¢–¨–Æ –ë–ï–°–ü–õ–ê–¢–ù–û –¥–ª—è —Ç–µ–±—è!</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üë• <b>–°–µ–π—á–∞—Å –≤ –±–æ—Ç–µ:</b> {online_count} —á–µ–ª–æ–≤–µ–∫ –æ–Ω–ª–∞–π–Ω\n\n'
                    f'üöÄ <b>–ß–¢–û –ú–û–ñ–ù–û –î–ï–õ–ê–¢–¨:</b>\n'
                    f'‚Ä¢ üé® –°–æ–∑–¥–∞–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ —Ç–µ–∫—Å—Ç–∞\n'
                    f'‚Ä¢ üé¨ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ\n'
                    f'‚Ä¢ ‚ú® –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç\n'
                    f'‚Ä¢ üéØ –í—Å–µ —ç—Ç–æ –ë–ï–ó VPN –∏ –ø–æ —Ü–µ–Ω–µ –∂–≤–∞—á–∫–∏!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üè¢ <b>–¢–û–ü–û–í–´–ï –ù–ï–ô–†–û–°–ï–¢–ò 2025:</b>\n\n'
                    f'ü§ñ OpenAI ‚Ä¢ Google ‚Ä¢ Black Forest Labs\n'
                    f'üé¨ ByteDance ‚Ä¢ Ideogram ‚Ä¢ Qwen\n'
                    f'‚ú® Kling ‚Ä¢ Hailuo ‚Ä¢ Topaz\n'
                    f'üé® Recraft ‚Ä¢ Grok (xAI) ‚Ä¢ Wan\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üéÅ <b>–ö–ê–ö –ù–ê–ß–ê–¢–¨?</b>\n\n'
                    f'1Ô∏è‚É£ <b>–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É "üéÅ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ"</b> –Ω–∏–∂–µ\n'
                    f'   ‚Üí –°–æ–∑–¥–∞–π —Å–≤–æ–µ –ø–µ—Ä–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞ 30 —Å–µ–∫—É–Ω–¥!\n\n'
                    f'2Ô∏è‚É£ <b>–ù–∞–ø–∏—à–∏ —á—Ç–æ —Ö–æ—á–µ—à—å —É–≤–∏–¥–µ—Ç—å</b> (–Ω–∞–ø—Ä–∏–º–µ—Ä: "–ö–æ—Ç –≤ –∫–æ—Å–º–æ—Å–µ")\n'
                    f'   ‚Üí Z-Image —Å–æ–∑–¥–∞—Å—Ç —ç—Ç–æ –¥–ª—è —Ç–µ–±—è!\n\n'
                    f'3Ô∏è‚É£ <b>–ü–æ–ª—É—á–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏ –Ω–∞—Å–ª–∞–∂–¥–∞–π—Å—è!</b> üéâ\n\n'
                    f'üí° <b>–ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ ‚Üí –ø–æ–ª—É—á–∏ +{REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π!</b>\n'
                    f'üîó <code>{referral_link}</code>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí∞ <b>–ü–æ—Å–ª–µ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π:</b>\n'
                    f'–û—Ç 0.62 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ ‚Ä¢ –û—Ç 3.86 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ'
                    )
                else:
                    online_count = get_fake_online_count()
                    referral_bonus_text = ""
                    if referrals_count > 0:
                        referral_bonus_text = (
                            f"\nüéÅ <b>–û—Ç–ª–∏—á–Ω–æ!</b> –¢—ã –ø—Ä–∏–≥–ª–∞—Å–∏–ª <b>{referrals_count}</b> –¥—Ä—É–∑–µ–π\n"
                            f"   ‚Üí –ü–æ–ª—É—á–µ–Ω–æ <b>+{referrals_count * REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>! üéâ\n\n"
                        )
                    
                    welcome_text = (
                        f'üëã <b>–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º, {user.mention_html()}!</b> ü§ñ‚ú®\n\n'
                        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        f'üë• <b>–°–µ–π—á–∞—Å –≤ –±–æ—Ç–µ:</b> {online_count} —á–µ–ª–æ–≤–µ–∫ –æ–Ω–ª–∞–π–Ω\n\n'
                    )
                    
                    if remaining_free > 0:
                        welcome_text += (
                            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                            f'üî• <b>–£ –¢–ï–ë–Ø –ï–°–¢–¨ {remaining_free} –ë–ï–°–ü–õ–ê–¢–ù–´–• –ì–ï–ù–ï–†–ê–¶–ò–ô!</b> üî•\n\n'
                            f'‚ú® <b>–ü–†–ï–ú–ò–£–ú AI MARKETPLACE</b> ‚ú®\n\n'
                            f'üöÄ <b>–ß—Ç–æ —ç—Ç–æ –∑–∞ –±–æ—Ç?</b>\n'
                            f'‚Ä¢ üì¶ <b>{total_models} —Ç–æ–ø–æ–≤—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π</b> –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ\n'
                            f'‚Ä¢ üéØ <b>{len(generation_types)} —Ç–∏–ø–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b> –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
                            f'‚Ä¢ üåê –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –ë–ï–ó VPN\n'
                            f'‚Ä¢ ‚ö° –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n\n'
                            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                            f'‚ú® <b>Z-Image - –°–ê–ú–ê–Ø –ö–†–£–¢–ê–Ø –ù–ï–ô–†–û–°–ï–¢–¨ –î–õ–Ø –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô!</b> ‚ú®\n\n'
                            f'üíé <b>–ü–æ—á–µ–º—É Z-Image?</b>\n'
                            f'‚Ä¢ üé® –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n'
                            f'‚Ä¢ ‚ö° –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è (10-30 —Å–µ–∫—É–Ω–¥)\n'
                            f'‚Ä¢ üéØ –†–∞–±–æ—Ç–∞–µ—Ç –ë–ï–ó VPN\n'
                            f'‚Ä¢ üí∞ <b>–ü–û–õ–ù–û–°–¢–¨–Æ –ë–ï–°–ü–õ–ê–¢–ù–û –¥–ª—è —Ç–µ–±—è!</b>\n\n'
                            f'üí° <b>–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É "üéÅ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ" –Ω–∏–∂–µ</b>\n\n'
                        )
                    
                    welcome_text += (
                        f'{referral_bonus_text}'
                        f'üíé <b>–î–û–°–¢–£–ü–ù–û:</b>\n'
                        f'‚Ä¢ {len(generation_types)} —Ç–∏–ø–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n'
                        f'‚Ä¢ {total_models} —Ç–æ–ø–æ–≤—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π\n'
                        f'‚Ä¢ –ë–µ–∑ VPN, –ø—Ä—è–º–æ –∑–¥–µ—Å—å!\n\n'
                        f'üí∞ <b>–ü–æ—Å–ª–µ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π:</b>\n'
                        f'–û—Ç 0.62 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ ‚Ä¢ –û—Ç 3.86 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ\n\n'
                        f'üí° <b>–ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ ‚Üí –ø–æ–ª—É—á–∏ +{REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π!</b>\n'
                        f'üîó <code>{referral_link}</code>\n\n'
                        f'üéØ <b>–í—ã–±–µ—Ä–∏ —Ñ–æ—Ä–º–∞—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–∏–∂–µ –∏–ª–∏ –Ω–∞—á–Ω–∏ —Å –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π!</b>'
                    )
                
                # Common keyboard for both admin and regular users (inside try block)
                keyboard = []
                
                # Free generation button (ALWAYS prominent - biggest button)
                if remaining_free > 0:
                    keyboard.append([
                        InlineKeyboardButton(f"üéÅ –ì–ï–ù–ï–†–ò–†–û–í–ê–¢–¨ –ë–ï–°–ü–õ–ê–¢–ù–û ({remaining_free} –æ—Å—Ç–∞–ª–æ—Å—å)", callback_data="select_model:z-image")
                    ])
                    keyboard.append([])  # Empty row for spacing
                
                # Generation types buttons (compact, 2 per row)
                gen_type_rows = []
                for i, gen_type in enumerate(generation_types):
                    gen_info = get_generation_type_info(gen_type)
                    models_count = len(get_models_by_generation_type(gen_type))
                    button_text = f"{gen_info.get('name', gen_type)} ({models_count})"
                    
                    if i % 2 == 0:
                        gen_type_rows.append([InlineKeyboardButton(
                            button_text,
                            callback_data=f"gen_type:{gen_type}"
                        )])
                    else:
                        if gen_type_rows:
                            gen_type_rows[-1].append(InlineKeyboardButton(
                                button_text,
                                callback_data=f"gen_type:{gen_type}"
                            ))
                        else:
                            gen_type_rows.append([InlineKeyboardButton(
                                button_text,
                                callback_data=f"gen_type:{gen_type}"
                            )])
                
                keyboard.extend(gen_type_rows)
                
                # Bottom action buttons
                keyboard.append([])  # Empty row for spacing
                keyboard.append([
                    InlineKeyboardButton("üí∞ –ë–∞–ª–∞–Ω—Å", callback_data="check_balance"),
                    InlineKeyboardButton("üìö –ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", callback_data="my_generations")
                ])
                keyboard.append([
                    InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å", callback_data="topup_balance"),
                    InlineKeyboardButton("üéÅ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–≥–∞", callback_data="referral_info")
                ])
                
                # Add tutorial button for new users
                if is_new:
                    keyboard.append([
                        InlineKeyboardButton("‚ùì –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?", callback_data="tutorial_start")
                    ])
                
                keyboard.append([
                    InlineKeyboardButton("üÜò –ü–æ–º–æ—â—å", callback_data="help_menu"),
                    InlineKeyboardButton("üí¨ –ü–æ–¥–¥–µ—Ä–∂–∫–∞", callback_data="support_contact")
                ])
                
                # Add admin panel button ONLY for admin (at the end)
                if is_admin:
                    keyboard.append([])  # Empty row for admin section
                    keyboard.append([
                        InlineKeyboardButton("üëë –ê–î–ú–ò–ù –ü–ê–ù–ï–õ–¨", callback_data="admin_stats")
                    ])
                
                try:
                    await query.edit_message_text(
                        welcome_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in back_to_menu: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            welcome_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    except Exception as send_error:
                        logger.error(f"Could not send new message in back_to_menu: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in back_to_menu: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
    
        if data == "generate_again":
            # Generate again - restore model and show model info, then ask for new prompt
            await query.answer()  # Acknowledge the callback
            
            logger.info(f"Generate again requested by user {user_id}")
            
            if user_id not in saved_generations:
                logger.warning(f"No saved generation data for user {user_id}")
                await query.edit_message_text(
                    "‚ùå <b>–î–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</b>\n\n"
                    "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —á–µ—Ä–µ–∑ –º–µ–Ω—é.",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            saved_data = saved_generations[user_id]
            logger.info(f"Restoring generation data for user {user_id}, model: {saved_data.get('model_id')}")
            
            # Restore session with model info, but clear params to start fresh
            if user_id not in user_sessions:
                user_sessions[user_id] = {}
            
            model_id = saved_data['model_id']
            model_info = saved_data['model_info']
            
            # Restore model info but clear params - user will enter new prompt
            user_sessions[user_id].update({
                'model_id': model_id,
                'model_info': model_info,
                'properties': saved_data['properties'].copy(),
                'required': saved_data['required'].copy(),
                'params': {}  # Clear params - start fresh
            })
            
            # Get user balance and calculate available generations (same as select_model)
            user_balance = get_user_balance(user_id)
            is_admin = get_is_admin(user_id)
            
            # Calculate price for default parameters (minimum price)
            default_params = {}
            if model_id == "nano-banana-pro":
                default_params = {"resolution": "1K"}  # Cheapest option
            elif model_id == "seedream/4.5-text-to-image" or model_id == "seedream/4.5-edit":
                default_params = {"quality": "basic"}  # Basic quality (same price, but for consistency)
            
            min_price = calculate_price_rub(model_id, default_params, is_admin)
            price_text = format_price_rub(min_price, is_admin)
            
            # Calculate how many generations available
            if is_admin:
                available_count = "–ë–µ–∑–ª–∏–º–∏—Ç"
            elif user_balance >= min_price:
                available_count = int(user_balance / min_price)
            else:
                available_count = 0
            
            # Show model info with price and available generations (same format as select_model)
            model_name = model_info.get('name', model_id)
            model_emoji = model_info.get('emoji', 'ü§ñ')
            model_desc = model_info.get('description', '')
            
            model_info_text = (
                f"{model_emoji} <b>{model_name}</b>\n\n"
                f"{model_desc}\n\n"
                f"üí∞ <b>–¶–µ–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b> {price_text} ‚ÇΩ\n"
            )
            
            if is_admin:
                model_info_text += f"‚úÖ <b>–î–æ—Å—Ç—É–ø–Ω–æ:</b> –ë–µ–∑–ª–∏–º–∏—Ç\n\n"
            else:
                if available_count > 0:
                    model_info_text += f"‚úÖ <b>–î–æ—Å—Ç—É–ø–Ω–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π:</b> {available_count}\n"
                    model_info_text += f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n\n"
                else:
                    # Not enough balance - show warning
                    model_info_text += (
                        f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>\n"
                        f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n"
                        f"üíµ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {price_text} ‚ÇΩ\n\n"
                        f"–ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏."
                    )
                    
                    keyboard = [
                        [InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="topup_balance")],
                        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –º–æ–¥–µ–ª—è–º", callback_data="back_to_menu")]
                    ]
                    
                    await query.edit_message_text(
                        model_info_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return ConversationHandler.END
            
            # Check balance before starting generation
            if not is_admin and user_balance < min_price:
                keyboard = [
                    [InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="topup_balance")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –º–æ–¥–µ–ª—è–º", callback_data="back_to_menu")]
                ]
                
                await query.edit_message_text(
                    f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                    f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n"
                    f"üíµ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º:</b> {price_text} ‚ÇΩ\n\n"
                    f"–ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Get input parameters from model info
            input_params = model_info.get('input_params', {})
            
            if not input_params:
                # If no params defined, ask for simple text input
                await query.edit_message_text(
                    f"{model_info_text}"
                    f"–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:",
                    parse_mode='HTML'
                )
                user_sessions[user_id]['params'] = {}
                user_sessions[user_id]['waiting_for'] = 'text'
                return INPUTTING_PARAMS
            
            # Store session data
            user_sessions[user_id]['params'] = {}
            user_sessions[user_id]['properties'] = input_params
            user_sessions[user_id]['required'] = [p for p, info in input_params.items() if info.get('required', False)]
            user_sessions[user_id]['current_param'] = None
            
            # Start with prompt parameter first
            if 'prompt' in input_params:
                # Check if model supports image input (image_input or image_urls)
                has_image_input = 'image_input' in input_params or 'image_urls' in input_params
                
                prompt_text = (
                    f"{model_info_text}"
                )
                
                if has_image_input:
                    prompt_text += (
                        f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                        f"–û–ø–∏—à–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å.\n\n"
                        f"üí° <i>–ü–æ—Å–ª–µ –≤–≤–æ–¥–∞ –ø—Ä–æ–º–ø—Ç–∞ –≤—ã —Å–º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</i>"
                    )
                else:
                    prompt_text += (
                        f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                        f"–û–ø–∏—à–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å:"
                    )
                
                await query.edit_message_text(
                    prompt_text,
                    parse_mode='HTML'
                )
                user_sessions[user_id]['current_param'] = 'prompt'
                user_sessions[user_id]['waiting_for'] = 'prompt'
                user_sessions[user_id]['has_image_input'] = has_image_input
            else:
                # If no prompt, start with first required parameter
                await start_next_parameter(update, context, user_id)
            
            return INPUTTING_PARAMS
        
        if data.startswith("set_language:"):
            # Handle language selection
            lang = data.split(":", 1)[1]
            if lang in ['ru', 'en']:
                set_user_language(user_id, lang)
                await query.answer(t('language_set', lang))
                # Show main menu after language selection
                await start(update, context)
                return ConversationHandler.END
            else:
                await query.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —è–∑—ã–∫ / Invalid language")
            return ConversationHandler.END
        
        if data == "claim_gift":
            # Handle gift claiming
            if has_claimed_gift(user_id):
                await query.answer("–í—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —Å–≤–æ–π –ø–æ–¥–∞—Ä–æ–∫! üéâ", show_alert=True)
                await query.edit_message_text(
                    "üéÅ <b>–ü–û–î–ê–†–û–ö –£–ñ–ï –ò–°–ü–û–õ–¨–ó–û–í–ê–ù</b> üéÅ\n\n"
                    "–¢—ã —É–∂–µ –∑–∞–±—Ä–∞–ª —Å–≤–æ–π –ø–æ–¥–∞—Ä–æ–∫! üéâ\n\n"
                    "üí° –ò—Å–ø–æ–ª—å–∑—É–π –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–ª–∏ –ø–æ–ø–æ–ª–Ω–∏ –±–∞–ª–∞–Ω—Å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞.",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Show initial spinning message
            await query.answer("üé∞ –ö—Ä—É—Ç–∏–º –∫–æ–ª–µ—Å–æ —Ñ–æ—Ä—Ç—É–Ω—ã...")
            
            spin_message = await query.edit_message_text(
                "üé∞ <b>–ö–û–õ–ï–°–û –§–û–†–¢–£–ù–´</b> üé∞\n\n"
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                "üé≤ <b>–ö—Ä—É—Ç–∏–º –∫–æ–ª–µ—Å–æ...</b>\n\n"
                "‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞—à –≤—ã–∏–≥—Ä—ã—à...",
                parse_mode='HTML'
            )
            
            # Animate wheel spinning with different sectors
            wheel_sectors = [
                ("üéØ", "üé™", "üé®", "üé≠", "üé™", "üéØ"),
                ("üí∞", "üíé", "üéÅ", "‚≠ê", "üíé", "üí∞"),
                ("üé∞", "üé≤", "üéØ", "üé™", "üé≤", "üé∞"),
                ("üí´", "‚ú®", "üåü", "‚≠ê", "‚ú®", "üí´"),
                ("üéä", "üéâ", "üéà", "üéÅ", "üéâ", "üéä")
            ]
            
            progress_steps = [
                ("üîÑ", "üîÑ", "üîÑ", "üîÑ", "üîÑ", "üîÑ"),
                ("‚ö°", "‚ö°", "‚ö°", "‚ö°", "‚ö°", "‚ö°"),
                ("‚ú®", "‚ú®", "‚ú®", "‚ú®", "‚ú®", "‚ú®"),
                ("üí´", "üí´", "üí´", "üí´", "üí´", "üí´"),
                ("üéØ", "üéØ", "üéØ", "üéØ", "üéØ", "üéØ")
            ]
            
            # Show spinning animation
            for i in range(8):
                await asyncio.sleep(0.25)
                sector_idx = i % len(wheel_sectors)
                progress_idx = min(i, len(progress_steps) - 1)
                
                wheel_display = " ".join(wheel_sectors[sector_idx])
                progress_display = " ".join(progress_steps[progress_idx])
                
                # Progress bar simulation
                progress_percent = min((i + 1) * 12.5, 100)
                progress_bar = "‚ñà" * int(progress_percent / 5) + "‚ñë" * (20 - int(progress_percent / 5))
                
                try:
                    await spin_message.edit_text(
                        f"üé∞ <b>–ö–û–õ–ï–°–û –§–û–†–¢–£–ù–´</b> üé∞\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"{wheel_display}\n\n"
                        f"<b>–ö—Ä—É—Ç–∏–º...</b> {progress_display}\n\n"
                        f"üìä [{progress_bar}] {progress_percent:.0f}%\n\n"
                        f"‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞—à –≤—ã–∏–≥—Ä—ã—à...",
                        parse_mode='HTML'
                    )
                except:
                    pass
            
            # Final spin - slow down
            await asyncio.sleep(0.4)
            
            # Get random gift amount
            gift_amount = spin_gift_wheel()
            
            # Add to user balance
            add_user_balance(user_id, gift_amount)
            set_gift_claimed(user_id)
            
            # Show result with celebration
            keyboard = [
                [InlineKeyboardButton("üéÅ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ", callback_data="select_model:z-image")],
                [InlineKeyboardButton("ü§ñ –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="show_models")],
                [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
            ]
            
            await spin_message.edit_text(
                f"üéâ <b>–ü–û–ó–î–†–ê–í–õ–Ø–ï–ú!</b> üéâ\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üé∞ <b>–ö–û–õ–ï–°–û –û–°–¢–ê–ù–û–í–ò–õ–û–°–¨!</b> üé∞\n\n"
                f"üí∞ <b>–¢–í–û–ô –í–´–ò–ì–†–´–®:</b> {gift_amount:.2f} ‚ÇΩ\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"‚úÖ <b>–ë–∞–ª–∞–Ω—Å —É—Å–ø–µ—à–Ω–æ –ø–æ–ø–æ–ª–Ω–µ–Ω!</b>\n\n"
                f"üéØ –¢–µ–ø–µ—Ä—å —Ç—ã –º–æ–∂–µ—à—å:\n"
                f"‚Ä¢ –°–æ–∑–¥–∞–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\n"
                f"‚Ä¢ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ\n"
                f"‚Ä¢ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ –º–æ–¥–µ–ª–∏!\n\n"
                f"üí° <b>–£–¥–∞—á–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏!</b> ‚ú®",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "cancel":
            await query.answer("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
            if user_id in user_sessions:
                del user_sessions[user_id]
            try:
                keyboard = [[InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]]
                await query.edit_message_text(
                    "‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.\n\n"
                    "–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            except Exception as e:
                logger.error(f"Error editing message on cancel: {e}")
                try:
                    keyboard = [[InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]]
                    await query.message.reply_text(
                        "‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                except:
                    pass
            return ConversationHandler.END
        
        if data.startswith("retry_generate:"):
            # Retry generation with same parameters
            await query.answer("–ü–æ–≤—Ç–æ—Ä—è—é –ø–æ–ø—ã—Ç–∫—É...")
            
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            session = user_sessions[user_id]
            
            # Show confirmation again with same parameters
            model_name = session.get('model_info', {}).get('name', 'Unknown')
            params = session.get('params', {})
            params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in params.items()])
            
            keyboard = [
                [InlineKeyboardButton("‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="confirm_generate")],
                [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
            ]
            
            await query.edit_message_text(
                f"üîÑ <b>–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞:</b>\n\n"
                f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return CONFIRMING_GENERATION
        
        # Handle category selection (can be called from main menu)
        if data.startswith("gen_type:"):
            # User selected a generation type
            gen_type = data.split(":", 1)[1]
            gen_info = get_generation_type_info(gen_type)
            models = get_models_by_generation_type(gen_type)
            
            if not models:
                await query.edit_message_text(
                    f"‚ùå –ú–æ–¥–µ–ª–∏ –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Get admin status for price calculations
            is_admin = get_is_admin(user_id)
            
            # Show generation type info and models with marketing text
            remaining_free = get_user_free_generations_remaining(user_id)
            
            gen_type_text = (
                f"üé® <b>{gen_info.get('name', gen_type)}</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n"
                f"{gen_info.get('description', '')}\n\n"
            )
            
            if remaining_free > 0 and gen_type == "text-to-image":
                gen_type_text += (
                    f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–û:</b> {remaining_free} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π Z-Image –¥–æ—Å—Ç—É–ø–Ω–æ!\n"
                    f"üí° –ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ ‚Üí –ø–æ–ª—É—á–∏ +{REFERRAL_BONUS_GENERATIONS} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n\n"
                )
            
            gen_type_text += (
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"ü§ñ <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ ({len(models)}):</b>\n\n"
                f"üí° <b>–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –Ω–∏–∂–µ</b>"
            )
            
            # Create keyboard with models (2 per row for compact display)
            keyboard = []
            
            # Free generation button if available and this is text-to-image
            if remaining_free > 0 and gen_type == "text-to-image":
                keyboard.append([
                    InlineKeyboardButton(f"üéÅ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ ({remaining_free} –æ—Å—Ç–∞–ª–æ—Å—å)", callback_data="select_model:z-image")
                ])
                keyboard.append([])  # Empty row
            
            # Show models in compact format with prices (2 per row)
            model_rows = []
            for i, model in enumerate(models):
                model_name = model.get('name', model.get('id', 'Unknown'))
                model_emoji = model.get('emoji', 'ü§ñ')
                model_id = model.get('id')
                
                # Calculate price for display
                default_params = {}
                if model_id == "nano-banana-pro":
                    default_params = {"resolution": "1K"}
                elif model_id in ["seedream/4.5-text-to-image", "seedream/4.5-edit"]:
                    default_params = {"quality": "basic"}
                
                min_price = calculate_price_rub(model_id, default_params, is_admin)
                price_text = get_model_price_text(model_id, default_params, is_admin, user_id)
                
                # Extract price number from price_text for compact display
                import re
                price_match = re.search(r'(\d+\.?\d*)\s*‚ÇΩ', price_text)
                if price_match:
                    price_display = price_match.group(1)
                    # Check if it's "–û—Ç" (from) or fixed price
                    if "–û—Ç" in price_text or "–æ—Ç" in price_text.lower():
                        price_display = f"–æ—Ç {price_display} ‚ÇΩ"
                    else:
                        price_display = f"{price_display} ‚ÇΩ"
                elif "–ë–ï–°–ü–õ–ê–¢–ù–û" in price_text or "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ" in price_text:
                    price_display = "–±–µ—Å–ø–ª–∞—Ç–Ω–æ"
                else:
                    # Fallback: show calculated price
                    price_display = f"{min_price:.2f} ‚ÇΩ"
                
                # Compact button text (shorten if too long)
                button_text = f"{model_emoji} {model_name}"
                if len(button_text) > 30:
                    # Truncate model name if too long
                    button_text = f"{model_emoji} {model_name[:25]}..."
                
                button_text_with_price = f"{button_text} ‚Ä¢ {price_display}"
                
                if i % 2 == 0:
                    # First button in row
                    model_rows.append([InlineKeyboardButton(
                        button_text_with_price,
                        callback_data=f"select_model:{model_id}"
                    )])
                else:
                    # Second button in row - add to last row
                    if model_rows:
                        model_rows[-1].append(InlineKeyboardButton(
                            button_text_with_price,
                            callback_data=f"select_model:{model_id}"
                        ))
                    else:
                        model_rows.append([InlineKeyboardButton(
                            button_text_with_price,
                            callback_data=f"select_model:{model_id}"
                        )])
            
            keyboard.extend(model_rows)
            keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")])
            
            try:
                await query.edit_message_text(
                    gen_type_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in gen_type: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        gen_type_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as e2:
                    logger.error(f"Error sending new message in gen_type: {e2}", exc_info=True)
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
            
            return ConversationHandler.END
        
        if data.startswith("category:"):
            category = data.split(":", 1)[1]
            models = get_models_by_category(category)
            
            if not models:
                await query.edit_message_text(f"‚ùå –í –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category} –Ω–µ—Ç –º–æ–¥–µ–ª–µ–π.")
                return ConversationHandler.END
            
            # Get user balance for showing available generations
            user_balance = get_user_balance(user_id)
            is_admin = get_is_admin(user_id)
            
            keyboard = []
            for model in models:
                # Calculate price for display
                default_params = {}
                if model['id'] == "nano-banana-pro":
                    default_params = {"resolution": "1K"}
                elif model['id'] in ["seedream/4.5-text-to-image", "seedream/4.5-edit"]:
                    default_params = {"quality": "basic"}
                
                min_price = calculate_price_rub(model['id'], default_params, is_admin)
                price_text = get_model_price_text(model['id'], default_params, is_admin, user_id)
                
                # Extract price number from price_text for compact display
                import re
                price_match = re.search(r'(\d+\.?\d*)\s*‚ÇΩ', price_text)
                if price_match:
                    price_display = price_match.group(1)
                    # Check if it's "–û—Ç" (from) or fixed price
                    if "–û—Ç" in price_text or "–æ—Ç" in price_text.lower():
                        price_display = f"–æ—Ç {price_display} ‚ÇΩ"
                    else:
                        price_display = f"{price_display} ‚ÇΩ"
                elif "–ë–ï–°–ü–õ–ê–¢–ù–û" in price_text or "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ" in price_text:
                    price_display = "–±–µ—Å–ø–ª–∞—Ç–Ω–æ"
                else:
                    # Fallback: show calculated price
                    price_display = f"{min_price:.2f} ‚ÇΩ"
                
                # Compact button text with price (limit name to 20 chars for mobile display)
                model_name_short = model['name'][:20] + "..." if len(model['name']) > 20 else model['name']
                button_text = f"{model['emoji']} {model_name_short} ‚Ä¢ {price_display}"
                
                # Telegram button text limit is ~64 chars, ensure we don't exceed
                if len(button_text) > 60:
                    model_name_short = model['name'][:15] + "..."
                    button_text = f"{model['emoji']} {model_name_short} ‚Ä¢ {price_display}"
                if len(button_text) > 60:
                    # If still too long, remove emoji from price part
                    price_display_short = price_display.replace("‚ÇΩ", "‚ÇΩ")[:8]
                    button_text = f"{model['emoji']} {model_name_short} {price_display_short}"
                
                keyboard.append([InlineKeyboardButton(
                    button_text,
                    callback_data=f"select_model:{model['id']}"
                )])
            keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º", callback_data="show_models")])
            keyboard.append([InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")])
            
            # Premium formatted header
            category_emoji = {
                "–í–∏–¥–µ–æ": "üé¨",
                "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è": "üñºÔ∏è",
                "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ": "‚úèÔ∏è"
            }.get(category, "üìÅ")
            
            models_text = (
                f"‚ú® <b>–ü–†–ï–ú–ò–£–ú –ö–ê–¢–ê–õ–û–ì</b> ‚ú®\n\n"
                f"{category_emoji} <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {category}</b>\n"
                f"üì¶ <b>–î–æ—Å—Ç—É–ø–Ω–æ –º–æ–¥–µ–ª–µ–π:</b> {len(models)}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üí° <i>–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞ –Ω–∏–∂–µ</i>\n"
                f"<i>–ü–æ–¥—Ä–æ–±–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—Å—è –ø—Ä–∏ –≤—ã–±–æ—Ä–µ</i>"
            )
            
            await query.edit_message_text(
                models_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_MODEL
        
        if data == "show_models" or data == "all_models":
            # Show generation types instead of all models with marketing text
            generation_types = get_generation_types()
            remaining_free = get_user_free_generations_remaining(user_id)
            
            models_text = (
                f"üé® <b>–í–´–ë–ï–†–ò–¢–ï –§–û–†–ú–ê–¢ –ì–ï–ù–ï–†–ê–¶–ò–ò</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üí∞ <b>–ì–ï–ù–ï–†–ê–¶–ò–Ø –ü–û –¶–ï–ù–ï –ñ–í–ê–ß–ö–ò!</b>\n\n"
                f"üíº <b>–ò–î–ï–ê–õ–¨–ù–û –î–õ–Ø:</b>\n"
                f"‚Ä¢ –ú–∞—Ä–∫–µ—Ç–æ–ª–æ–≥–æ–≤ ‚Ä¢ SMM-—â–∏–∫–æ–≤ ‚Ä¢ –î–∏–∑–∞–π–Ω–µ—Ä–æ–≤\n"
                f"‚Ä¢ –§—Ä–∏–ª–∞–Ω—Å–µ—Ä–æ–≤ ‚Ä¢ –ö—Ä–µ–∞—Ç–æ—Ä–æ–≤ ‚Ä¢ –ö–æ–Ω—Ç–µ–Ω—Ç-–º–µ–π–∫–µ—Ä–æ–≤\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üí° <b>–ö–ê–ö –≠–¢–û –†–ê–ë–û–¢–ê–ï–¢:</b>\n"
                f"1Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n"
                f"2Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω—É –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π\n"
                f"3Ô∏è‚É£ –°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∫—Ä—É—Ç–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç! üöÄ\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )
            
            if remaining_free > 0:
                models_text += (
                    f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–û:</b> {remaining_free} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π Z-Image –¥–æ—Å—Ç—É–ø–Ω–æ!\n"
                    f"üí° –ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ ‚Üí –ø–æ–ª—É—á–∏ +{REFERRAL_BONUS_GENERATIONS} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n\n"
                )
            
            models_text += (
                f"üì¶ <b>–î–æ—Å—Ç—É–ø–Ω–æ:</b> {len(generation_types)} —Ç–∏–ø–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n"
                f"ü§ñ <b>–ú–æ–¥–µ–ª–µ–π:</b> {len(KIE_MODELS)} —Ç–æ–ø–æ–≤—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π"
            )
            
            keyboard = []
            
            # Free generation button if available
            if remaining_free > 0:
                keyboard.append([
                    InlineKeyboardButton(f"üéÅ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ ({remaining_free} –æ—Å—Ç–∞–ª–æ—Å—å)", callback_data="select_model:z-image")
                ])
                keyboard.append([])  # Empty row
            
            # Generation types buttons (2 per row for compact display)
            # Sort generation types: text-to-image first, then others
            sorted_gen_types = []
            if "text-to-image" in generation_types:
                sorted_gen_types.append("text-to-image")
            for gen_type in generation_types:
                if gen_type != "text-to-image":
                    sorted_gen_types.append(gen_type)
            
            gen_type_rows = []
            for i, gen_type in enumerate(sorted_gen_types):
                gen_info = get_generation_type_info(gen_type)
                models_count = len(get_models_by_generation_type(gen_type))
                button_text = f"{gen_info.get('name', gen_type)} ({models_count})"
                
                if i % 2 == 0:
                    # First button in row
                    gen_type_rows.append([InlineKeyboardButton(
                        button_text,
                        callback_data=f"gen_type:{gen_type}"
                    )])
                else:
                    # Second button in row - add to last row
                    if gen_type_rows:
                        gen_type_rows[-1].append(InlineKeyboardButton(
                            button_text,
                            callback_data=f"gen_type:{gen_type}"
                        ))
                    else:
                        gen_type_rows.append([InlineKeyboardButton(
                            button_text,
                            callback_data=f"gen_type:{gen_type}"
                        )])
            
            keyboard.extend(gen_type_rows)
            keyboard.append([InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")])
            keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")])
            
            await query.edit_message_text(
                models_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_MODEL
        
        if data == "add_image":
            await query.edit_message_text(
                "üì∑ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n"
                "–ú–æ–∂–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–æ 8 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.",
                parse_mode='HTML'
            )
            session = user_sessions.get(user_id, {})
            # Determine which parameter name to use (image_input or image_urls)
            model_info = session.get('model_info', {})
            input_params = model_info.get('input_params', {})
            if 'image_urls' in input_params:
                image_param_name = 'image_urls'
            else:
                image_param_name = 'image_input'
            session['waiting_for'] = image_param_name
            session[image_param_name] = []  # Initialize as array
            return INPUTTING_PARAMS
        
        if data == "image_done":
            session = user_sessions.get(user_id, {})
            image_param_name = session.get('waiting_for', 'image_input')
            if image_param_name in session and session[image_param_name]:
                session['params'][image_param_name] = session[image_param_name]
                await query.edit_message_text(
                    f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {len(session[image_param_name])}\n\n"
                    f"–ü—Ä–æ–¥–æ–ª–∂–∞—é..."
                )
            session['waiting_for'] = None
            
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                    
                    keyboard = [
                        [InlineKeyboardButton("‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="confirm_generate")],
                        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
                    ]
                    
                    await query.edit_message_text(
                        f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                        f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                        f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after image done: {e}")
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
                return INPUTTING_PARAMS
        
        if data == "add_audio":
            # User wants to add audio file
            await query.answer()
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            session = user_sessions[user_id]
            model_info = session.get('model_info', {})
            input_params = model_info.get('input_params', {})
            
            audio_param_name = 'audio_url' if 'audio_url' in input_params else 'audio_input'
            
            keyboard = [
                [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")],
                [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_audio")]
            ]
            
            await query.edit_message_text(
                "üé§ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏.\n\n"
                "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG\n"
                "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            
            session['waiting_for'] = audio_param_name
            session['current_param'] = audio_param_name
            return INPUTTING_PARAMS
        
        if data == "skip_audio":
            # User wants to skip audio upload
            await query.answer("–ê—É–¥–∏–æ –ø—Ä–æ–ø—É—â–µ–Ω–æ")
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            session = user_sessions[user_id]
            session['waiting_for'] = None
            session['current_param'] = None
            
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected, show confirmation
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in params.items()])
                    
                    keyboard = [
                        [InlineKeyboardButton("‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="confirm_generate")],
                        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
                    ]
                    
                    await query.edit_message_text(
                        f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                        f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                        f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after skipping audio: {e}", exc_info=True)
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
            
            return INPUTTING_PARAMS
        
        if data == "skip_image":
            await query.answer("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ")
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected
                    session = user_sessions[user_id]
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                    
                    keyboard = [
                        [InlineKeyboardButton("‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="confirm_generate")],
                        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
                    ]
                
                await query.edit_message_text(
                    f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                    f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                    f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after skipping image: {e}")
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
                return INPUTTING_PARAMS
        
        if data.startswith("set_param:"):
            # Handle parameter setting via button
            parts = data.split(":", 2)
            if len(parts) == 3:
                param_name = parts[1]
                param_value = parts[2]
                
                if user_id not in user_sessions:
                    await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                    return ConversationHandler.END
                
                session = user_sessions[user_id]
                properties = session.get('properties', {})
                param_info = properties.get(param_name, {})
                param_type = param_info.get('type', 'string')
                
                # Convert boolean string to actual boolean
                if param_type == 'boolean':
                    if param_value.lower() == 'true':
                        param_value = True
                    elif param_value.lower() == 'false':
                        param_value = False
                    else:
                        # Use default if invalid
                        param_value = param_info.get('default', True)
                
                session['params'][param_name] = param_value
                session['current_param'] = None
                
                # Check if there are more parameters
                required = session.get('required', [])
                params = session.get('params', {})
                missing = [p for p in required if p not in params]
                
                if missing:
                    await query.edit_message_text(f"‚úÖ {param_name} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {param_value}")
                    # Move to next parameter
                    try:
                        next_param_result = await start_next_parameter(update, context, user_id)
                        if next_param_result:
                            return next_param_result
                    except Exception as e:
                        logger.error(f"Error starting next parameter: {e}")
                        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
                        return INPUTTING_PARAMS
                else:
                    # All parameters collected
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {v}" for k, v in params.items()])
                    
                    keyboard = [
                        [InlineKeyboardButton("‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="confirm_generate")],
                        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
                    ]
                    
                    await query.edit_message_text(
                        f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                        f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                        f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
        
        if data == "check_balance":
            # Check user's personal balance (NOT KIE balance)
            user_balance = get_user_balance(user_id)
            balance_str = f"{user_balance:.2f}".rstrip('0').rstrip('.')
            is_admin = get_is_admin(user_id)
            
            keyboard = [
                [InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="topup_balance")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
            ]
            
            balance_text = (
                f'üí≥ <b>–í–ê–® –ë–ê–õ–ê–ù–°</b> üí≥\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üí∞ <b>–î–æ—Å—Ç—É–ø–Ω–æ:</b> {balance_str} ‚ÇΩ\n\n'
            )
            
            if is_admin:
                balance_text += (
                    f'üëë <b>–°—Ç–∞—Ç—É—Å:</b> –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä\n'
                    f'‚úÖ –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –º–æ–¥–µ–ª—è–º\n\n'
                )
            else:
                if user_balance > 0:
                    balance_text += (
                        f'üí° <b>–î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b>\n'
                        f'‚Ä¢ ~{int(user_balance / 0.62)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (Z-Image)\n'
                        f'‚Ä¢ ~{int(user_balance / 3.86)} –≤–∏–¥–µ–æ (–±–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å)\n\n'
                    )
                else:
                    balance_text += (
                        f'üí° <b>–ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞</b>\n\n'
                    )
            
            balance_text += (
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üéÅ <b>–ù–µ –∑–∞–±—É–¥—å—Ç–µ:</b> –£ –≤–∞—Å –µ—Å—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Z-Image!'
            )
            
            await query.edit_message_text(
                balance_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "topup_balance":
            # Check if user is blocked
            if is_user_blocked(user_id):
                await query.edit_message_text(
                    "‚ùå <b>–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
                    "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Get payment details to show immediately
            payment_details = get_payment_details()
            
            # Show amount selection - focus on small amounts with marketing
            keyboard = [
                [
                    InlineKeyboardButton("üíé 50 ‚ÇΩ", callback_data="topup_amount:50"),
                    InlineKeyboardButton("üíé 100 ‚ÇΩ", callback_data="topup_amount:100"),
                    InlineKeyboardButton("üíé 150 ‚ÇΩ", callback_data="topup_amount:150")
                ],
                [
                    InlineKeyboardButton("üí∞ –°–≤–æ—è —Å—É–º–º–∞", callback_data="topup_custom")
                ],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
            ]
            
            current_balance = get_user_balance(user_id)
            balance_str = f"{current_balance:.2f}".rstrip('0').rstrip('.')
            
            await query.edit_message_text(
                f'üí≥ <b>–ü–û–ü–û–õ–ù–ï–ù–ò–ï –ë–ê–õ–ê–ù–°–ê</b> üí≥\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üí∞ <b>–¢–≤–æ–π —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'{payment_details}\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üí° <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:</b>\n'
                f'‚Ä¢ –û—Ç 3.86 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ\n'
                f'‚Ä¢ –û—Ç 0.62 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n'
                f'‚Ä¢ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç 0.5 ‚ÇΩ\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üöÄ <b>–í–´–ë–ï–†–ò –°–£–ú–ú–£:</b>\n'
                f'‚Ä¢ –ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä: 50, 100, 150 ‚ÇΩ\n'
                f'‚Ä¢ –ò–ª–∏ —É–∫–∞–∂–∏ —Å–≤–æ—é —Å—É–º–º—É\n\n'
                f'üìù <b>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:</b>\n'
                f'–ú–∏–Ω–∏–º—É–º: 50 ‚ÇΩ | –ú–∞–∫—Å–∏–º—É–º: 50000 ‚ÇΩ',
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_AMOUNT
        
        if data.startswith("topup_amount:"):
            # User selected a preset amount
            amount = float(data.split(":")[1])
            user_lang = get_user_language(user_id)
            
            # Calculate what user can generate
            examples_count = int(amount / 0.62)  # Z-Image price
            video_count = int(amount / 3.86)  # Basic video price
            
            # Show payment method selection
            if user_lang == 'ru':
                payment_text = (
                    f'üí≥ <b>–û–ü–õ–ê–¢–ê {amount:.0f} ‚ÇΩ</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>–ß–¢–û –¢–´ –ü–û–õ–£–ß–ò–®–¨:</b>\n'
                    f'‚Ä¢ ~{examples_count} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π Z-Image\n'
                    f'‚Ä¢ ~{video_count} –≤–∏–¥–µ–æ (–±–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å)\n'
                    f'‚Ä¢ –ò–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>–í–´–ë–ï–†–ò –°–ü–û–°–û–ë –û–ü–õ–ê–¢–´:</b>'
                )
            else:
                payment_text = (
                    f'üí≥ <b>PAYMENT {amount:.0f} ‚ÇΩ</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>Amount to pay:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>WHAT YOU WILL GET:</b>\n'
                    f'‚Ä¢ ~{examples_count} Z-Image images\n'
                    f'‚Ä¢ ~{video_count} videos (basic model)\n'
                    f'‚Ä¢ Or a combination of different models!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>CHOOSE PAYMENT METHOD:</b>'
                )
            
            # Store amount in session
            user_sessions[user_id] = {
                'topup_amount': amount,
                'waiting_for': 'payment_method'
            }
            
            # For English users - only Telegram Stars, no SBP
            if user_lang == 'en':
                keyboard = [
                    [InlineKeyboardButton("‚≠ê Telegram Stars", callback_data=f"pay_stars:{amount}")],
                    [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel")]
                ]
            else:
                # For Russian users - both options
                keyboard = [
                    [
                        InlineKeyboardButton("‚≠ê Telegram Stars", callback_data=f"pay_stars:{amount}"),
                        InlineKeyboardButton("üí≥ –°–ë–ü / SBP", callback_data=f"pay_sbp:{amount}")
                    ],
                    [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
                ]
            
            await query.edit_message_text(
                payment_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_AMOUNT
        
        # Handle payment method selection
        if data.startswith("pay_stars:"):
            # User chose Telegram Stars payment
            amount = float(data.split(":")[1])
            user_lang = get_user_language(user_id)
            
            # Convert rubles to stars using exchange rate 1.6
            # 1 ruble = 1.6 stars
            # Telegram Stars are integers, so we round to nearest integer
            stars_amount = int(round(amount * 1.6))
            
            if stars_amount < 1:
                stars_amount = 1  # Minimum 1 star
            
            try:
                # Create invoice for Telegram Stars
                # Note: Invoice prices are in XTR (XTR is the currency for Telegram Stars)
                # 1 XTR = 1 Star
                from telegram import LabeledPrice
                
                invoice_text_ru = f"–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –Ω–∞ {amount:.2f} ‚ÇΩ"
                invoice_text_en = f"Balance top-up for {amount:.2f} ‚ÇΩ"
                invoice_text = invoice_text_ru if user_lang == 'ru' else invoice_text_en
                
                # Store payment info in session
                user_sessions[user_id] = {
                    'topup_amount': amount,
                    'payment_method': 'stars',
                    'stars_amount': stars_amount,
                    'invoice_payload': f"topup_{user_id}_{int(time.time())}"
                }
                
                # Send invoice directly (Telegram Stars payment)
                # Note: provider_token is not needed for Telegram Stars (use empty string or None)
                await context.bot.send_invoice(
                    chat_id=query.message.chat_id,
                    title=invoice_text,
                    description=invoice_text,
                    payload=f"topup_{user_id}_{int(time.time())}",
                    provider_token="",  # Empty for Telegram Stars
                    currency="XTR",  # XTR is the currency code for Telegram Stars
                    prices=[LabeledPrice(invoice_text, stars_amount)],
                )
                
                invoice = None  # Will be sent as message
                
                # Invoice is sent directly, just answer the query
                await query.answer()
                if user_lang == 'ru':
                    await query.edit_message_text(
                        f'‚≠ê <b>–û–ü–õ–ê–¢–ê –ß–ï–†–ï–ó TELEGRAM STARS</b> ‚≠ê\n\n'
                        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        f'üí∞ <b>–°—É–º–º–∞:</b> {amount:.2f} ‚ÇΩ ({stars_amount} ‚≠ê)\n\n'
                        f'üí° <b>–°—á–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤—ã—à–µ. –û–ø–ª–∞—Ç–∏—Ç–µ —á–µ—Ä–µ–∑ Telegram Stars.</b>'
                    )
                else:
                    await query.edit_message_text(
                        f'‚≠ê <b>PAYMENT VIA TELEGRAM STARS</b> ‚≠ê\n\n'
                        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        f'üí∞ <b>Amount:</b> {amount:.2f} ‚ÇΩ ({stars_amount} ‚≠ê)\n\n'
                        f'üí° <b>Invoice sent above. Pay via Telegram Stars.</b>'
                    )
                    
            except Exception as e:
                logger.error(f"Error creating Stars invoice: {e}", exc_info=True)
                user_lang = get_user_language(user_id)
                if user_lang == 'ru':
                    await query.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—á–µ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", show_alert=True)
                else:
                    await query.answer("Error creating invoice. Please try later.", show_alert=True)
            
            return SELECTING_AMOUNT
        
        if data.startswith("pay_sbp:"):
            # User chose SBP payment
            amount = float(data.split(":")[1])
            user_lang = get_user_language(user_id)
            
            # English users can only pay via Telegram Stars
            if user_lang == 'en':
                # Redirect to Stars payment
                await query.answer("For English users, only Telegram Stars payment is available.", show_alert=True)
                # Trigger Stars payment instead
                # Convert rubles to stars using exchange rate 1.6
                # 1 ruble = 1.6 stars
                stars_amount = int(round(amount * 1.6))
                if stars_amount < 1:
                    stars_amount = 1
                
                try:
                    from telegram import LabeledPrice
                    invoice_text = f"Balance top-up for {amount:.2f} ‚ÇΩ"
                    
                    user_sessions[user_id] = {
                        'topup_amount': amount,
                        'payment_method': 'stars',
                        'stars_amount': stars_amount,
                        'invoice_payload': f"topup_{user_id}_{int(time.time())}"
                    }
                    
                    await context.bot.send_invoice(
                        chat_id=query.message.chat_id,
                        title=invoice_text,
                        description=invoice_text,
                        payload=f"topup_{user_id}_{int(time.time())}",
                        provider_token="",
                        currency="XTR",
                        prices=[LabeledPrice(invoice_text, stars_amount)],
                    )
                    
                    await query.edit_message_text(
                        f'‚≠ê <b>PAYMENT VIA TELEGRAM STARS</b> ‚≠ê\n\n'
                        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        f'üí∞ <b>Amount:</b> {amount:.2f} ‚ÇΩ ({stars_amount} ‚≠ê)\n\n'
                        f'üí° <b>Invoice sent above. Pay via Telegram Stars.</b>'
                    )
                except Exception as e:
                    logger.error(f"Error creating Stars invoice: {e}", exc_info=True)
                    await query.answer("Error creating invoice. Please try later.", show_alert=True)
                
                return SELECTING_AMOUNT
            
            user_sessions[user_id] = {
                'topup_amount': amount,
                'waiting_for': 'payment_screenshot',
                'payment_method': 'sbp'
            }
            
            payment_details = get_payment_details()
            
            # Calculate what user can generate
            examples_count = int(amount / 0.62)  # Z-Image price
            video_count = int(amount / 3.86)  # Basic video price
            
            keyboard = [
                [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞" if user_lang == 'ru' else "‚ùå Cancel", callback_data="cancel")]
            ]
            
            if user_lang == 'ru':
                sbp_text = (
                    f'üí≥ <b>–û–ü–õ–ê–¢–ê {amount:.0f} ‚ÇΩ (–°–ë–ü)</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'{payment_details}\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>–ß–¢–û –¢–´ –ü–û–õ–£–ß–ò–®–¨:</b>\n'
                    f'‚Ä¢ ~{examples_count} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π Z-Image\n'
                    f'‚Ä¢ ~{video_count} –≤–∏–¥–µ–æ (–±–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å)\n'
                    f'‚Ä¢ –ò–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üì∏ <b>–ö–ê–ö –û–ü–õ–ê–¢–ò–¢–¨:</b>\n'
                    f'1Ô∏è‚É£ –ü–µ—Ä–µ–≤–µ–¥–∏ {amount:.2f} ‚ÇΩ –ø–æ —Ä–µ–∫–≤–∏–∑–∏—Ç–∞–º –≤—ã—à–µ\n'
                    f'2Ô∏è‚É£ –°–¥–µ–ª–∞–π —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞\n'
                    f'3Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å —Å–∫—Ä–∏–Ω—à–æ—Ç —Å—é–¥–∞\n'
                    f'4Ô∏è‚É£ –ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏! ‚ö°\n\n'
                    f'‚úÖ <b>–í—Å–µ –ø—Ä–æ—Å—Ç–æ –∏ –±—ã—Å—Ç—Ä–æ!</b>'
                )
            else:
                sbp_text = (
                    f'üí≥ <b>PAYMENT {amount:.0f} ‚ÇΩ (SBP)</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'{payment_details}\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>Amount to pay:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>WHAT YOU WILL GET:</b>\n'
                    f'‚Ä¢ ~{examples_count} Z-Image images\n'
                    f'‚Ä¢ ~{video_count} videos (basic model)\n'
                    f'‚Ä¢ Or a combination of different models!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üì∏ <b>HOW TO PAY:</b>\n'
                    f'1Ô∏è‚É£ Transfer {amount:.2f} ‚ÇΩ using details above\n'
                    f'2Ô∏è‚É£ Take a screenshot of the transfer\n'
                    f'3Ô∏è‚É£ Send screenshot here\n'
                    f'4Ô∏è‚É£ Balance will be added automatically! ‚ö°\n\n'
                    f'‚úÖ <b>Simple and fast!</b>'
                )
            
            await query.edit_message_text(
                sbp_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return WAITING_PAYMENT_SCREENSHOT
        
        if data == "topup_custom":
            # User wants to enter custom amount
            await query.edit_message_text(
                f'üí∞ <b>–í–í–ï–î–ò –°–í–û–Æ –°–£–ú–ú–£</b> üí∞\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üìù <b>–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å —á–∏—Å–ª–æ</b> (–Ω–∞–ø—Ä–∏–º–µ—Ä: 250)\n\n'
                f'üí° <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:</b>\n'
                f'‚Ä¢ –û—Ç 3.86 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ\n'
                f'‚Ä¢ –û—Ç 0.62 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n'
                f'‚Ä¢ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç 0.5 ‚ÇΩ\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üìã <b>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:</b>\n'
                f'‚Ä¢ –ú–∏–Ω–∏–º—É–º: 50 ‚ÇΩ\n'
                f'‚Ä¢ –ú–∞–∫—Å–∏–º—É–º: 50000 ‚ÇΩ\n\n'
                f'üí¨ <b>–û—Ç–ø—Ä–∞–≤—å —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏</b> (–Ω–∞–ø—Ä–∏–º–µ—Ä: 250)',
                parse_mode='HTML'
            )
            user_sessions[user_id] = {
                'waiting_for': 'topup_amount_input'
            }
            return SELECTING_AMOUNT
        
        # Admin functions (only for admin)
        if user_id == ADMIN_ID:
            if data == "admin_stats":
                # Show full admin panel menu with extended statistics
                generation_types = get_generation_types()
                total_models = len(KIE_MODELS)
                
                # Get extended statistics
                stats = get_extended_admin_stats()
                
                # Get KIE API balance (for admin info only)
                kie_balance_info = ""
                try:
                    balance_result = await kie.get_credits()
                    if balance_result.get('ok'):
                        balance = balance_result.get('credits', 0)
                        balance_rub = balance * CREDIT_TO_USD * USD_TO_RUB
                        balance_rub_str = f"{balance_rub:.2f}".rstrip('0').rstrip('.')
                        kie_balance_info = f"üí∞ <b>–ë–∞–ª–∞–Ω—Å KIE API:</b> {balance_rub_str} ‚ÇΩ ({balance} –∫—Ä–µ–¥–∏—Ç–æ–≤)\n\n"
                except Exception as e:
                    logger.error(f"Error getting KIE balance: {e}")
                    kie_balance_info = "üí∞ <b>–ë–∞–ª–∞–Ω—Å KIE API:</b> –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω\n\n"
                
                # Format top models
                top_models_text = ""
                if stats['top_models']:
                    top_models_text = "\n<b>–¢–æ–ø-5 –º–æ–¥–µ–ª–µ–π:</b>\n"
                    for i, model in enumerate(stats['top_models'], 1):
                        top_models_text += f"{i}. {model['name']}: {model['count']} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π\n"
                    top_models_text += "\n"
                else:
                    top_models_text = "\n<b>–¢–æ–ø-5 –º–æ–¥–µ–ª–µ–π:</b> –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö\n\n"
                
                admin_text = (
                    f'üëë <b>–ü–ê–ù–ï–õ–¨ –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†–ê</b> üëë\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'{kie_balance_info}'
                    f'üìä <b>–†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê:</b>\n\n'
                    f'üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b>\n'
                    f'   ‚Ä¢ –í—Å–µ–≥–æ: <b>{stats["total_users"]}</b>\n'
                    f'   ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ–≥–æ–¥–Ω—è: <b>{stats["active_today"]}</b>\n'
                    f'   ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞ –Ω–µ–¥–µ–ª—é: <b>{stats["active_week"]}</b>\n'
                    f'   ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞ –º–µ—Å—è—Ü: <b>{stats["active_month"]}</b>\n\n'
                    f'üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b>\n'
                    f'   ‚Ä¢ –í—Å–µ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π: <b>{stats["total_generations"]}</b>\n'
                    f'{top_models_text}'
                    f'üí∞ <b>–§–∏–Ω–∞–Ω—Å—ã:</b>\n'
                    f'   ‚Ä¢ –û–±—â–∏–π –¥–æ—Ö–æ–¥: <b>{stats["total_revenue"]:.2f} ‚ÇΩ</b>\n'
                    f'   ‚Ä¢ –î–æ—Ö–æ–¥ —Å–µ–≥–æ–¥–Ω—è: <b>{stats["revenue_today"]:.2f} ‚ÇΩ</b>\n'
                    f'   ‚Ä¢ –î–æ—Ö–æ–¥ –∑–∞ –Ω–µ–¥–µ–ª—é: <b>{stats["revenue_week"]:.2f} ‚ÇΩ</b>\n'
                    f'   ‚Ä¢ –î–æ—Ö–æ–¥ –∑–∞ –º–µ—Å—è—Ü: <b>{stats["revenue_month"]:.2f} ‚ÇΩ</b>\n'
                    f'   ‚Ä¢ –í—Å–µ–≥–æ –ø–ª–∞—Ç–µ–∂–µ–π: <b>{stats["total_payments"]}</b>\n'
                    f'   ‚Ä¢ –°—Ä–µ–¥–Ω–∏–π —á–µ–∫: <b>{stats["avg_check"]:.2f} ‚ÇΩ</b>\n'
                    f'   ‚Ä¢ –ö–æ–Ω–≤–µ—Ä—Å–∏—è –≤ –æ–ø–ª–∞—Ç—É: <b>{stats["conversion_rate"]:.1f}%</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üìä <b>–°–ò–°–¢–ï–ú–ê:</b>\n\n'
                    f'‚úÖ <b>{total_models} –ø—Ä–µ–º–∏—É–º –º–æ–¥–µ–ª–µ–π</b> –≤ –∞—Ä—Å–µ–Ω–∞–ª–µ\n'
                    f'‚úÖ <b>{len(generation_types)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b> –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
                    f'‚úÖ –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—è–º\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚öôÔ∏è <b>–ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–´–ï –§–£–ù–ö–¶–ò–ò:</b>\n\n'
                    f'üìà –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏\n'
                    f'üë• –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n'
                    f'üéÅ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏\n'
                    f'üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ OCR —Å–∏—Å—Ç–µ–º—ã\n'
                    f'üíº –ü–æ–ª–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –±–æ—Ç–æ–º\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí´ <b>–í–´–ë–ï–†–ò–¢–ï –î–ï–ô–°–¢–í–ò–ï:</b>'
                )
                
                keyboard = [
                    [InlineKeyboardButton("üìä –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É", callback_data="admin_stats")],
                    [InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="admin_settings")],
                    [InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data="admin_search")],
                    [InlineKeyboardButton("üìù –î–æ–±–∞–≤–∏—Ç—å", callback_data="admin_add")],
                    [InlineKeyboardButton("üß™ –¢–µ—Å—Ç OCR", callback_data="admin_test_ocr")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                await query.edit_message_text(
                    admin_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
        
        if data == "admin_settings":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Get support contact info
            support_telegram = os.getenv('SUPPORT_TELEGRAM', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
            
            settings_text = (
                f'‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:</b>\n\n'
                f'üîß <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:</b>\n\n'
                f'‚úÖ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª—è–º–∏\n'
                f'‚úÖ –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n'
                f'‚úÖ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n'
                f'‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ API\n\n'
                f'üí° <b>–ö–æ–º–∞–Ω–¥—ã:</b>\n'
                f'/models - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª—è–º–∏\n'
                f'/balance - –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞\n'
                f'/search - –ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π\n'
                f'/add - –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏–π\n'
                f'/payments - –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–ª–∞—Ç–µ–∂–µ–π\n'
                f'/block_user - –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                f'/unblock_user - –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                f'/user_balance - –ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n'
                f'üí¨ <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏:</b>\n\n'
                f'üí¨ Telegram: {support_telegram if support_telegram != "–ù–µ —É–∫–∞–∑–∞–Ω–æ" else "–ù–µ —É–∫–∞–∑–∞–Ω–æ"}\n\n'
                f'üí° –î–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ —Ñ–∞–π–ª .env'
            )
            
            keyboard = [
                [InlineKeyboardButton("üì¢ –†–∞—Å—Å—ã–ª–∫–∞", callback_data="admin_broadcast")],
                [InlineKeyboardButton("üéÅ –ü—Ä–æ–º–æ–∫–æ–¥—ã", callback_data="admin_promocodes")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
            ]
            
            await query.edit_message_text(
                settings_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_promocodes":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Show promocodes menu
            promocodes = load_promocodes()
            active_promo = get_active_promocode()
            
            promocodes_text = "üéÅ <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏</b>\n\n"
            
            if active_promo:
                promo_code = active_promo.get('code', 'N/A')
                promo_value = active_promo.get('value', 0)
                promo_expires = active_promo.get('expires', 'N/A')
                promo_used = active_promo.get('used_count', 0)
                
                promocodes_text += (
                    f"‚úÖ <b>–ê–∫—Ç–∏–≤–Ω—ã–π –ø—Ä–æ–º–æ–∫–æ–¥:</b>\n"
                    f"üîë <b>–ö–æ–¥:</b> <code>{promo_code}</code>\n"
                    f"üí∞ <b>–ó–Ω–∞—á–µ–Ω–∏–µ:</b> {promo_value} ‚ÇΩ\n"
                    f"üìÖ <b>–î–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –¥–æ:</b> {promo_expires}\n"
                    f"üë• <b>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Ä–∞–∑:</b> {promo_used}\n\n"
                )
            else:
                promocodes_text += "‚ùå <b>–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–º–æ–∫–æ–¥–∞</b>\n\n"
            
            # Show all promocodes
            if promocodes:
                promocodes_text += f"üìã <b>–í—Å–µ –ø—Ä–æ–º–æ–∫–æ–¥—ã ({len(promocodes)}):</b>\n\n"
                for i, promo in enumerate(promocodes, 1):
                    promo_code = promo.get('code', 'N/A')
                    promo_value = promo.get('value', 0)
                    promo_expires = promo.get('expires', 'N/A')
                    promo_used = promo.get('used_count', 0)
                    is_active = promo.get('active', False)
                    
                    status = "‚úÖ –ê–∫—Ç–∏–≤–µ–Ω" if is_active else "‚ùå –ù–µ–∞–∫—Ç–∏–≤–µ–Ω"
                    
                    promocodes_text += (
                        f"{i}. <b>{status}</b>\n"
                        f"   üîë <code>{promo_code}</code>\n"
                        f"   üí∞ {promo_value} ‚ÇΩ | üë• {promo_used} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π\n"
                        f"   üìÖ –î–æ: {promo_expires}\n\n"
                    )
            else:
                promocodes_text += "üìã <b>–ù–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤</b>\n\n"
            
            promocodes_text += "üí° <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è:</b>\n"
            promocodes_text += "‚Ä¢ –ü—Ä–æ—Å–º–æ—Ç—Ä –≤—Å–µ—Ö –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤\n"
            promocodes_text += "‚Ä¢ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–∫—Ç–∏–≤–Ω–æ–º –ø—Ä–æ–º–æ–∫–æ–¥–µ\n"
            
            keyboard = [
                [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="admin_promocodes")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_settings")]
            ]
            
            await query.edit_message_text(
                promocodes_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_broadcast":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Show broadcast menu
            broadcasts = get_broadcasts()
            total_users = len(get_all_users())
            
            broadcast_text = "üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π</b>\n\n"
            broadcast_text += f"üë• <b>–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</b> {total_users}\n\n"
            
            if broadcasts:
                broadcast_text += f"üìã <b>–ò—Å—Ç–æ—Ä–∏—è —Ä–∞—Å—Å—ã–ª–æ–∫ ({len(broadcasts)}):</b>\n\n"
                # Show last 5 broadcasts
                sorted_broadcasts = sorted(
                    broadcasts.items(),
                    key=lambda x: x[1].get('created_at', 0),
                    reverse=True
                )[:5]
                
                for broadcast_id, broadcast in sorted_broadcasts:
                    created_at = broadcast.get('created_at', 0)
                    sent = broadcast.get('sent', 0)
                    delivered = broadcast.get('delivered', 0)
                    failed = broadcast.get('failed', 0)
                    message_preview = broadcast.get('message', '')[:30] + '...' if len(broadcast.get('message', '')) > 30 else broadcast.get('message', '')
                    
                    from datetime import datetime
                    if created_at:
                        date_str = datetime.fromtimestamp(created_at).strftime('%Y-%m-%d %H:%M')
                    else:
                        date_str = 'N/A'
                    
                    broadcast_text += (
                        f"üì® <b>#{broadcast_id}</b> ({date_str})\n"
                        f"   üìù {message_preview}\n"
                        f"   ‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent} | üì¨ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {delivered} | ‚ùå –û—à–∏–±–æ–∫: {failed}\n\n"
                    )
            else:
                broadcast_text += "üìã <b>–ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞—Å—Å—ã–ª–æ–∫</b>\n\n"
            
            broadcast_text += "üí° <b>–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Ä–∞—Å—Å—ã–ª–∫—É:</b>\n"
            broadcast_text += "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏."
            
            keyboard = [
                [InlineKeyboardButton("üì¢ –°–æ–∑–¥–∞—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É", callback_data="admin_create_broadcast")],
                [InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin_broadcast_stats")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_settings")]
            ]
            
            await query.edit_message_text(
                broadcast_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_create_broadcast":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Start broadcast creation
            await query.edit_message_text(
                "üì¢ <b>–°–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Ä–∞–∑–æ—Å–ª–∞—Ç—å –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.\n\n"
                "üí° <b>–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è:</b>\n"
                "‚Ä¢ –¢–µ–∫—Å—Ç\n"
                "‚Ä¢ HTML —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ\n"
                "‚Ä¢ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            user_sessions[user_id] = {
                'waiting_for': 'broadcast_message'
            }
            return WAITING_BROADCAST_MESSAGE
        
        if data == "admin_broadcast_stats":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Show detailed broadcast statistics
            broadcasts = get_broadcasts()
            total_users = len(get_all_users())
            
            if not broadcasts:
                await query.edit_message_text(
                    "üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞—Å—Å—ã–ª–æ–∫</b>\n\n"
                    "‚ùå –ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞—Å—Å—ã–ª–æ–∫",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_broadcast")]
                    ]),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Calculate totals
            total_sent = sum(b.get('sent', 0) for b in broadcasts.values())
            total_delivered = sum(b.get('delivered', 0) for b in broadcasts.values())
            total_failed = sum(b.get('failed', 0) for b in broadcasts.values())
            
            stats_text = (
                f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞—Å—Å—ã–ª–æ–∫</b>\n\n"
                f"üë• <b>–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</b> {total_users}\n"
                f"üì® <b>–í—Å–µ–≥–æ —Ä–∞—Å—Å—ã–ª–æ–∫:</b> {len(broadcasts)}\n\n"
                f"üìà <b>–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
                f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {total_sent}\n"
                f"üì¨ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {total_delivered}\n"
                f"‚ùå –û—à–∏–±–æ–∫: {total_failed}\n\n"
            )
            
            if total_sent > 0:
                success_rate = (total_delivered / total_sent) * 100
                stats_text += f"üìä <b>–£—Å–ø–µ—à–Ω–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏:</b> {success_rate:.1f}%\n"
            
            keyboard = [
                [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="admin_broadcast_stats")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_broadcast")]
            ]
            
            await query.edit_message_text(
                stats_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_search":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            await query.edit_message_text(
                'üîç <b>–ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π</b>\n\n'
                '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n'
                '<code>/search [–∑–∞–ø—Ä–æ—Å]</code>\n\n'
                '–ü—Ä–∏–º–µ—Ä:\n'
                '<code>/search –Ω–µ–π—Ä–æ—Å–µ—Ç–∏</code>',
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_add":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            await query.edit_message_text(
                'üìù <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏–π</b>\n\n'
                '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n'
                '<code>/add [–∑–∞–≥–æ–ª–æ–≤–æ–∫] | [—Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ]</code>\n\n'
                '–ü—Ä–∏–º–µ—Ä:\n'
                '<code>/add AI | –ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç - —ç—Ç–æ...</code>',
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_test_ocr":
            # Check admin access
            if user_id != ADMIN_ID:
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            if not OCR_AVAILABLE or not PIL_AVAILABLE:
                await query.edit_message_text(
                    '‚ùå <b>OCR –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω</b>\n\n'
                    'Tesseract OCR –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.\n\n'
                    '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ:\n'
                    '1. pip install Pillow pytesseract\n'
                    '2. Tesseract OCR (—Å–º. TESSERACT_INSTALL.txt)',
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            await query.edit_message_text(
                'üß™ <b>–¢–µ—Å—Ç OCR</b>\n\n'
                '–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–º –ø–ª–∞—Ç–µ–∂–∞.\n\n'
                '–°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç:\n'
                '‚úÖ –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞\n'
                '‚úÖ –ü–æ–∏—Å–∫ —Å—É–º–º\n'
                '‚úÖ –†–∞–±–æ—Ç–∞ Tesseract OCR\n\n'
                '–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.',
                parse_mode='HTML'
            )
            user_sessions[user_id] = {
                'waiting_for': 'admin_test_ocr'
            }
            return ADMIN_TEST_OCR
        
        if data == "tutorial_start":
            # Interactive tutorial for new users
            tutorial_text = (
                'üéì <b>–ò–ù–¢–ï–†–ê–ö–¢–ò–í–ù–´–ô –¢–£–¢–û–†–ò–ê–õ</b>\n\n'
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                'üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º—Å—è, –∫–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º.\n\n'
                'üìö <b>–ß—Ç–æ –≤—ã —É–∑–Ω–∞–µ—Ç–µ:</b>\n'
                '‚Ä¢ –ß—Ç–æ —Ç–∞–∫–æ–µ AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n'
                '‚Ä¢ –ö–∞–∫ –≤—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å\n'
                '‚Ä¢ –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç\n'
                '‚Ä¢ –ö–∞–∫ –ø–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å\n\n'
                'üí° <b>–≠—Ç–æ –∑–∞–π–º–µ—Ç 2 –º–∏–Ω—É—Ç—ã!</b>'
            )
            
            keyboard = [
                [InlineKeyboardButton("‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å —Ç—É—Ç–æ—Ä–∏–∞–ª", callback_data="tutorial_step1")],
                [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="back_to_menu")]
            ]
            
            await query.edit_message_text(
                tutorial_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "tutorial_step1":
            tutorial_text = (
                'üìñ <b>–®–ê–ì 1: –ß—Ç–æ —Ç–∞–∫–æ–µ AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è?</b>\n\n'
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                'ü§ñ <b>–ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç</b> –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å:\n\n'
                'üé® <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</b>\n'
                '–û–ø–∏—à–∏—Ç–µ –∫–∞—Ä—Ç–∏–Ω–∫—É —Å–ª–æ–≤–∞–º–∏, –∏ AI —Å–æ–∑–¥–∞—Å—Ç –µ—ë!\n'
                '–ü—Ä–∏–º–µ—Ä: "–ö–æ—Ç –≤ –∫–æ—Å–º–æ—Å–µ, –ø–∏–∫—Å–µ–ª—å-–∞—Ä—Ç"\n\n'
                'üé¨ <b>–í–∏–¥–µ–æ</b>\n'
                '–°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–µ –≤–∏–¥–µ–æ –∏–∑ —Ç–µ–∫—Å—Ç–∞\n'
                '–ü—Ä–∏–º–µ—Ä: "–õ–µ—Ç—è—â–∏–π –¥—Ä–∞–∫–æ–Ω –Ω–∞–¥ –≥–æ—Ä–æ–¥–æ–º"\n\n'
                'üñºÔ∏è <b>–£–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞</b>\n'
                '–£–≤–µ–ª–∏—á–∏–≤–∞–π—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ —Ñ–æ—Ç–æ –≤ 4-8 —Ä–∞–∑\n\n'
                'üí° <b>–í—Å–µ —ç—Ç–æ –±–µ–∑ VPN!</b> –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ –ª—É—á—à–∏–º AI-–º–æ–¥–µ–ª—è–º.'
            )
            
            keyboard = [
                [InlineKeyboardButton("‚ñ∂Ô∏è –î–∞–ª–µ–µ", callback_data="tutorial_step2")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_start")],
                [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
            ]
            
            await query.edit_message_text(
                tutorial_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "tutorial_step2":
            categories = get_categories()
            total_models = len(KIE_MODELS)
            tutorial_text = (
                f'üìñ <b>–®–ê–ì 2: –ö–∞–∫ –≤—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å?</b>\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üéØ <b>–£ –Ω–∞—Å {total_models} –º–æ–¥–µ–ª–µ–π –≤ {len(categories)} –∫–∞—Ç–µ–≥–æ—Ä–∏—è—Ö:</b>\n\n'
                f'üñºÔ∏è <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</b>\n'
                f'‚Ä¢ Z-Image - –±—ã—Å—Ç—Ä–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è (–±–µ—Å–ø–ª–∞—Ç–Ω–æ 5 —Ä–∞–∑ –≤ –¥–µ–Ω—å!)\n'
                f'‚Ä¢ Nano Banana Pro - –∫–∞—á–µ—Å—Ç–≤–æ 2K/4K\n'
                f'‚Ä¢ Imagen 4 Ultra - –Ω–æ–≤–µ–π—à–∞—è –æ—Ç Google\n\n'
                f'üé¨ <b>–í–∏–¥–µ–æ</b>\n'
                f'‚Ä¢ Sora 2 - —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ –≤–∏–¥–µ–æ\n'
                f'‚Ä¢ Grok Imagine - –º—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å\n\n'
                f'üí° <b>–°–æ–≤–µ—Ç:</b> –ù–∞—á–Ω–∏—Ç–µ —Å Z-Image - –æ–Ω–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è!'
            )
            
            keyboard = [
                [InlineKeyboardButton("‚ñ∂Ô∏è –î–∞–ª–µ–µ", callback_data="tutorial_step3")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_step1")],
                [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
            ]
            
            await query.edit_message_text(
                tutorial_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "tutorial_step3":
            tutorial_text = (
                'üìñ <b>–®–ê–ì 3: –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç?</b>\n\n'
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                'üìù <b>–ü—Ä–æ—Å—Ç–æ–π –ø—Ä–æ—Ü–µ—Å—Å:</b>\n\n'
                '1Ô∏è‚É£ –ù–∞–∂–º–∏—Ç–µ "üìã –í—Å–µ –º–æ–¥–µ–ª–∏"\n'
                '2Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, Z-Image)\n'
                '3Ô∏è‚É£ –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–ø—Ä–æ–º–ø—Ç)\n'
                '   –ü—Ä–∏–º–µ—Ä: "–ö—Ä–∞—Å–∏–≤—ã–π –∑–∞–∫–∞—Ç –Ω–∞–¥ –æ–∫–µ–∞–Ω–æ–º"\n'
                '4Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (—Ä–∞–∑–º–µ—Ä, —Å—Ç–∏–ª—å –∏ —Ç.–¥.)\n'
                '5Ô∏è‚É£ –ù–∞–∂–º–∏—Ç–µ "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å"\n'
                '6Ô∏è‚É£ –ü–æ–¥–æ–∂–¥–∏—Ç–µ 10-60 —Å–µ–∫—É–Ω–¥\n'
                '7Ô∏è‚É£ –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç! üéâ\n\n'
                'üí° <b>–°–æ–≤–µ—Ç:</b> –ß–µ–º –ø–æ–¥—Ä–æ–±–Ω–µ–µ –æ–ø–∏—Å–∞–Ω–∏–µ, —Ç–µ–º –ª—É—á—à–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç!'
            )
            
            keyboard = [
                [InlineKeyboardButton("‚ñ∂Ô∏è –î–∞–ª–µ–µ", callback_data="tutorial_step4")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_step2")],
                [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
            ]
            
            await query.edit_message_text(
                tutorial_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "tutorial_step4":
            remaining_free = get_user_free_generations_remaining(user_id)
            tutorial_text = (
                'üìñ <b>–®–ê–ì 4: –ë–∞–ª–∞–Ω—Å –∏ –æ–ø–ª–∞—Ç–∞</b>\n\n'
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                'üí∞ <b>–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:</b>\n\n'
                'üéÅ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:</b>\n'
                f'‚Ä¢ {remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π Z-Image –≤ –¥–µ–Ω—å\n'
                '‚Ä¢ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–≥–∞ - –ø–æ–ª—É—á–∏—Ç–µ +5 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π!\n\n'
                'üí≥ <b>–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞:</b>\n'
                '‚Ä¢ –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: 50 ‚ÇΩ\n'
                '‚Ä¢ –ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä: 50, 100, 150 ‚ÇΩ\n'
                '‚Ä¢ –ò–ª–∏ —É–∫–∞–∂–∏—Ç–µ —Å–≤–æ—é —Å—É–º–º—É\n'
                '‚Ä¢ –û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ –°–ë–ü (–°–∏—Å—Ç–µ–º–∞ –±—ã—Å—Ç—Ä—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π)\n\n'
                'üí° <b>–°–æ–≤–µ—Ç:</b> –ù–∞—á–Ω–∏—Ç–µ —Å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π!'
            )
            
            keyboard = [
                [InlineKeyboardButton("‚ñ∂Ô∏è –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data="tutorial_complete")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_step3")],
                [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
            ]
            
            await query.edit_message_text(
                tutorial_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "tutorial_complete":
            tutorial_text = (
                'üéâ <b>–¢–£–¢–û–†–ò–ê–õ –ó–ê–í–ï–†–®–ï–ù!</b>\n\n'
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                '‚úÖ –¢–µ–ø–µ—Ä—å –≤—ã –∑–Ω–∞–µ—Ç–µ:\n'
                '‚Ä¢ –ß—Ç–æ —Ç–∞–∫–æ–µ AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n'
                '‚Ä¢ –ö–∞–∫ –≤—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å\n'
                '‚Ä¢ –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç\n'
                '‚Ä¢ –ö–∞–∫ –ø–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å\n\n'
                'üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b>\n\n'
                'üí° <b>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:</b>\n'
                '–ù–∞—á–Ω–∏—Ç–µ —Å –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Z-Image!\n'
                '–ü—Ä–æ—Å—Ç–æ –≤—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏ –æ–ø–∏—à–∏—Ç–µ, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å.'
            )
            
            keyboard = [
                [InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")],
                [InlineKeyboardButton("üñºÔ∏è Z-Image (–±–µ—Å–ø–ª–∞—Ç–Ω–æ)", callback_data="select_model:z-image")],
                [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
            ]
            
            await query.edit_message_text(
                tutorial_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "help_menu":
            is_new = is_new_user(user_id)
            
            if is_new:
                help_text = (
                    'üìã <b>–ü–û–ú–û–©–¨ –î–õ–Ø –ù–û–í–´–• –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ô</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'üëã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</b>\n\n'
                    'üéØ <b>–ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç:</b>\n'
                    '1. –ù–∞–∂–º–∏—Ç–µ "üìã –í—Å–µ –º–æ–¥–µ–ª–∏"\n'
                    '2. –í—ã–±–µ—Ä–∏—Ç–µ "üñºÔ∏è Z-Image" (–æ–Ω–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è!)\n'
                    '3. –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä: "–ö–æ—Ç –≤ –∫–æ—Å–º–æ—Å–µ"\n'
                    '4. –ù–∞–∂–º–∏—Ç–µ "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å"\n'
                    '5. –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ 10-30 —Å–µ–∫—É–Ω–¥!\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'üí° <b>–ü–æ–ª–µ–∑–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n'
                    '/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n'
                    '/models - –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –º–æ–¥–µ–ª–∏\n'
                    '/balance - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
                    '/help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n'
                    '‚ùì <b>–ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å?</b>\n'
                    '–ù–∞–∂–º–∏—Ç–µ "‚ùì –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?" –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç—É—Ç–æ—Ä–∏–∞–ª–∞!'
                )
            else:
                help_text = (
                    'üìã <b>–î–û–°–¢–£–ü–ù–´–ï –ö–û–ú–ê–ù–î–´</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'üîπ <b>–û—Å–Ω–æ–≤–Ω—ã–µ:</b>\n'
                    '/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n'
                    '/models - –ü–æ–∫–∞–∑–∞—Ç—å –º–æ–¥–µ–ª–∏\n'
                    '/balance - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
                    '/generate - –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n'
                    '/help - –°–ø—Ä–∞–≤–∫–∞\n\n'
                )
                
                if user_id == ADMIN_ID:
                    help_text += (
                        'üëë <b>–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–µ:</b>\n'
                        '/search - –ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π\n'
                        '/add - –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏–π\n'
                        '/payments - –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–ª–∞—Ç–µ–∂–µ–π\n'
                        '/block_user - –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                        '/unblock_user - –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                        '/user_balance - –ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n'
                    )
                
                help_text += (
                    'üí° <b>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:</b>\n'
                    '1. –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ –º–µ–Ω—é\n'
                    '2. –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç (–æ–ø–∏—Å–∞–Ω–∏–µ)\n'
                    '3. –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏\n'
                    '4. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n'
                    '5. –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç!\n\n'
                    'üìö <b>–ü–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:</b>\n'
                    '‚Ä¢ "üìö –ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏" - –ø—Ä–æ—Å–º–æ—Ç—Ä –∏—Å—Ç–æ—Ä–∏–∏\n'
                    '‚Ä¢ "üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å" - —Å–æ–∑–¥–∞—Ç—å —Å —Ç–µ–º–∏ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏\n'
                    '‚Ä¢ "üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å" - –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞'
                )
            
            keyboard = []
            if is_new:
                keyboard.append([InlineKeyboardButton("‚ùì –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?", callback_data="tutorial_start")])
            keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")])
            
            await query.edit_message_text(
                help_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "support_contact":
            support_info = get_support_contact()
            keyboard = [[InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")]]
            
            await query.edit_message_text(
                support_info,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "referral_info":
            # Show referral information
            referral_link = get_user_referral_link(user_id)
            referrals_count = len(get_user_referrals(user_id))
            remaining_free = get_user_free_generations_remaining(user_id)
            
            referral_text = (
                f'üéÅ <b>–†–ï–§–ï–†–ê–õ–¨–ù–ê–Ø –°–ò–°–¢–ï–ú–ê</b> üéÅ\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üí° <b>–ö–ê–ö –≠–¢–û –†–ê–ë–û–¢–ê–ï–¢:</b>\n\n'
                f'1Ô∏è‚É£ –ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–≥–∞ –ø–æ –≤–∞—à–µ–π —Å—Å—ã–ª–∫–µ\n'
                f'2Ô∏è‚É£ –û–Ω –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç—Å—è —á–µ—Ä–µ–∑ –±–æ—Ç–∞\n'
                f'3Ô∏è‚É£ –í—ã –ø–æ–ª—É—á–∏—Ç–µ <b>+{REFERRAL_BONUS_GENERATIONS} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –≤ Z-Image</b>!\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üìä <b>–í–ê–®–ê –°–¢–ê–¢–ò–°–¢–ò–ö–ê:</b>\n'
                f'‚Ä¢ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ –¥—Ä—É–∑–µ–π: <b>{referrals_count}</b>\n'
                f'‚Ä¢ –ü–æ–ª—É—á–µ–Ω–æ –±–æ–Ω—É—Å–æ–≤: <b>{referrals_count * REFERRAL_BONUS_GENERATIONS}</b> –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n'
                f'‚Ä¢ –î–æ—Å—Ç—É–ø–Ω–æ –±–µ—Å–ø–ª–∞—Ç–Ω–æ: <b>{remaining_free}</b> –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –≤ Z-Image\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'‚ö†Ô∏è <b>–í–ê–ñ–ù–û:</b> –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –¥–ª—è –º–æ–¥–µ–ª–∏ <b>Z-Image</b>!\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üîó <b>–í–ê–®–ê –†–ï–§–ï–†–ê–õ–¨–ù–ê–Ø –°–°–´–õ–ö–ê:</b>\n\n'
                f'<code>{referral_link}</code>\n\n'
                f'üí¨ <b>–û—Ç–ø—Ä–∞–≤—å—Ç–µ —ç—Ç—É —Å—Å—ã–ª–∫—É –¥—Ä—É–≥—É!</b>\n'
                f'–ü–æ—Å–ª–µ –µ–≥–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –±–æ–Ω—É—Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.'
            )
            
            keyboard = [
                [InlineKeyboardButton("üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É", url=referral_link)],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
            ]
            
            await query.edit_message_text(
                referral_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "my_generations":
            # Show user's generation history
            history = get_user_generations_history(user_id, limit=20)
            
            if not history:
                keyboard = [[InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]]
                await query.edit_message_text(
                    "üìö <b>–ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                    "‚ùå –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.\n\n"
                    "üí° –ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –≤—Å–µ –≤–∞—à–∏ —Ä–∞–±–æ—Ç—ã –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –∑–¥–µ—Å—å.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Show first generation with navigation
            from datetime import datetime
            
            gen = history[0]
            timestamp = gen.get('timestamp', 0)
            if timestamp:
                date_str = datetime.fromtimestamp(timestamp).strftime('%d.%m.%Y %H:%M')
            else:
                date_str = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
            
            model_name = gen.get('model_name', gen.get('model_id', 'Unknown'))
            result_urls = gen.get('result_urls', [])
            price = gen.get('price', 0)
            is_free = gen.get('is_free', False)
            
            history_text = (
                f"üìö <b>–ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üìä <b>–í—Å–µ–≥–æ:</b> {len(history)} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è #{gen.get('id', 1)}</b>\n"
                f"üìÖ <b>–î–∞—Ç–∞:</b> {date_str}\n"
                f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n"
                f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {'üéÅ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ' if is_free else f'{price:.2f} ‚ÇΩ'}\n"
                f"üì¶ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:</b> {len(result_urls)}\n\n"
            )
            
            if len(history) > 1:
                history_text += f"üí° <b>–ü–æ–∫–∞–∑–∞–Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—è—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n"
                history_text += f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏\n\n"
            
            keyboard = []
            
            # Navigation buttons if more than 1 generation
            if len(history) > 1:
                keyboard.append([
                    InlineKeyboardButton("‚óÄÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"gen_history:{gen.get('id', 1)}:prev"),
                    InlineKeyboardButton("–°–ª–µ–¥—É—é—â–∞—è ‚ñ∂Ô∏è", callback_data=f"gen_history:{gen.get('id', 1)}:next")
                ])
            
            # Action buttons
            if result_urls:
                keyboard.append([
                    InlineKeyboardButton("üëÅÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç", callback_data=f"gen_view:{gen.get('id', 1)}")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data=f"gen_repeat:{gen.get('id', 1)}")
                ])
            
            keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")])
            
            await query.edit_message_text(
                history_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data.startswith("gen_view:"):
            # View specific generation result
            gen_id = int(data.split(":")[1])
            gen = get_generation_by_id(user_id, gen_id)
            
            if not gen:
                await query.answer("‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                return ConversationHandler.END
            
            result_urls = gen.get('result_urls', [])
            if not result_urls:
                await query.answer("‚ùå –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", show_alert=True)
                return ConversationHandler.END
            
            # Send media
            session_http = await get_http_client()
            for i, url in enumerate(result_urls[:5]):
                try:
                    async with session_http.get(url) as resp:
                            if resp.status == 200:
                                media_data = await resp.read()
                                
                                is_last = (i == len(result_urls[:5]) - 1)
                                is_video = gen.get('model_id', '') in ['sora-2-text-to-video', 'sora-watermark-remover', 'kling-2.6/image-to-video', 'kling-2.6/text-to-video', 'kling/v2-5-turbo-text-to-video-pro', 'kling/v2-5-turbo-image-to-video-pro', 'wan/2-5-image-to-video', 'wan/2-5-text-to-video', 'wan/2-2-animate-move', 'wan/2-2-animate-replace', 'hailuo/02-text-to-video-pro', 'hailuo/02-image-to-video-pro', 'hailuo/02-text-to-video-standard', 'hailuo/02-image-to-video-standard']
                                
                                keyboard = []
                                if is_last:
                                    keyboard = [
                                        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∏—Å—Ç–æ—Ä–∏–∏", callback_data="my_generations")],
                                        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                                    ]
                                
                                if is_video:
                                    video_file = io.BytesIO(media_data)
                                    video_file.name = f"generated_video_{i+1}.mp4"
                                    await context.bot.send_video(
                                        chat_id=update.effective_chat.id,
                                        video=video_file,
                                        reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
                                    )
                                else:
                                    photo_file = io.BytesIO(media_data)
                                    photo_file.name = f"generated_image_{i+1}.png"
                                    await context.bot.send_photo(
                                        chat_id=update.effective_chat.id,
                                        photo=photo_file,
                                        reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
                                    )
                except Exception as e:
                    logger.error(f"Error sending generation result: {e}")
            
            await query.answer("‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã")
            return ConversationHandler.END
        
        if data.startswith("gen_repeat:"):
            # Repeat generation with same parameters
            gen_id = int(data.split(":")[1])
            gen = get_generation_by_id(user_id, gen_id)
            
            if not gen:
                await query.answer("‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                return ConversationHandler.END
            
            # Restore session from history
            model_id = gen.get('model_id')
            params = gen.get('params', {})
            model_info = get_model_by_id(model_id)
            
            if not model_info:
                await query.answer("‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                return ConversationHandler.END
            
            user_sessions[user_id] = {
                'model_id': model_id,
                'model_info': model_info,
                'params': params.copy(),
                'properties': model_info.get('input_params', {}),
                'required': []
            }
            
            # Go directly to confirmation
            await query.answer("‚úÖ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")
            await query.edit_message_text(
                "üîÑ <b>–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n\n"
                f"–ú–æ–¥–µ–ª—å: <b>{model_info.get('name', model_id)}</b>\n"
                f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏.\n\n"
                "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é:",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="confirm_generate")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∏—Å—Ç–æ—Ä–∏–∏", callback_data="my_generations")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]),
                parse_mode='HTML'
            )
            return CONFIRMING_GENERATION
        
        if data.startswith("gen_history:"):
            # Navigate through generation history
            parts = data.split(":")
            if len(parts) < 3:
                await query.answer("‚ùå –û—à–∏–±–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏", show_alert=True)
                return ConversationHandler.END
            
            current_gen_id = int(parts[1])
            direction = parts[2]  # prev or next
            
            history = get_user_generations_history(user_id, limit=100)
            if not history:
                await query.answer("‚ùå –ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞", show_alert=True)
                return ConversationHandler.END
            
            # Find current generation index
            current_index = -1
            for i, gen in enumerate(history):
                if gen.get('id') == current_gen_id:
                    current_index = i
                    break
            
            if current_index == -1:
                await query.answer("‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                return ConversationHandler.END
            
            # Navigate
            if direction == 'prev' and current_index < len(history) - 1:
                new_index = current_index + 1
            elif direction == 'next' and current_index > 0:
                new_index = current_index - 1
            else:
                await query.answer("‚ö†Ô∏è –≠—Ç–æ –ø–µ—Ä–≤–∞—è/–ø–æ—Å–ª–µ–¥–Ω—è—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è", show_alert=True)
                return ConversationHandler.END
            
            gen = history[new_index]
            from datetime import datetime
            
            timestamp = gen.get('timestamp', 0)
            if timestamp:
                date_str = datetime.fromtimestamp(timestamp).strftime('%d.%m.%Y %H:%M')
            else:
                date_str = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
            
            model_name = gen.get('model_name', gen.get('model_id', 'Unknown'))
            result_urls = gen.get('result_urls', [])
            price = gen.get('price', 0)
            is_free = gen.get('is_free', False)
            
            history_text = (
                f"üìö <b>–ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üìä <b>–í—Å–µ–≥–æ:</b> {len(history)} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n"
                f"üìç <b>–ü–æ–∫–∞–∑–∞–Ω–∞:</b> {new_index + 1} –∏–∑ {len(history)}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è #{gen.get('id', 1)}</b>\n"
                f"üìÖ <b>–î–∞—Ç–∞:</b> {date_str}\n"
                f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n"
                f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {'üéÅ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ' if is_free else f'{price:.2f} ‚ÇΩ'}\n"
                f"üì¶ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:</b> {len(result_urls)}\n\n"
            )
            
            keyboard = []
            
            # Navigation buttons
            keyboard.append([
                InlineKeyboardButton("‚óÄÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"gen_history:{gen.get('id', 1)}:prev"),
                InlineKeyboardButton("–°–ª–µ–¥—É—é—â–∞—è ‚ñ∂Ô∏è", callback_data=f"gen_history:{gen.get('id', 1)}:next")
            ])
            
            # Action buttons
            if result_urls:
                keyboard.append([
                    InlineKeyboardButton("üëÅÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç", callback_data=f"gen_view:{gen.get('id', 1)}")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data=f"gen_repeat:{gen.get('id', 1)}")
                ])
            
            keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")])
            
            await query.edit_message_text(
                history_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data.startswith("select_model:"):
            model_id = data.split(":", 1)[1]
            
            # Get model from static list
            model_info = get_model_by_id(model_id)
            
            if not model_info:
                await query.edit_message_text(f"‚ùå –ú–æ–¥–µ–ª—å {model_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                return
            
            # Check user balance and calculate available generations
            user_balance = get_user_balance(user_id)
            is_admin = get_is_admin(user_id)
            
            # Calculate price for default parameters (minimum price)
            default_params = {}
            if model_id == "nano-banana-pro":
                default_params = {"resolution": "1K"}  # Cheapest option
            elif model_id == "seedream/4.5-text-to-image" or model_id == "seedream/4.5-edit":
                default_params = {"quality": "basic"}  # Basic quality (same price, but for consistency)
            elif model_id == "topaz/image-upscale":
                default_params = {"upscale_factor": "1"}  # Cheapest option (1x = ‚â§2K)
            
            min_price = calculate_price_rub(model_id, default_params, is_admin)
            price_text = get_model_price_text(model_id, default_params, is_admin, user_id)
            
            # Check for free generations for z-image
            is_free_available = is_free_generation_available(user_id, model_id)
            remaining_free = get_user_free_generations_remaining(user_id) if model_id == FREE_MODEL_ID else 0
            
            # Calculate how many generations available
            if is_admin:
                available_count = "–ë–µ–∑–ª–∏–º–∏—Ç"
            elif is_free_available:
                # For z-image with free generations, show free count
                available_count = f"üéÅ {remaining_free} –±–µ—Å–ø–ª–∞—Ç–Ω–æ –≤ –¥–µ–Ω—å"
            elif user_balance >= min_price:
                available_count = int(user_balance / min_price)
            else:
                available_count = 0
            
            # Show model info with premium formatting
            model_name = model_info.get('name', model_id)
            model_emoji = model_info.get('emoji', 'ü§ñ')
            model_desc = model_info.get('description', '')
            model_category = model_info.get('category', '–û–±—â–µ–µ')
            
            # Check if new user for hints
            is_new = is_new_user(user_id)
            
            # Premium formatted model info (optimized for mobile - shorter lines)
            model_info_text = (
                f"‚ú® <b>–ü–†–ï–ú–ò–£–ú –ú–û–î–ï–õ–¨</b> ‚ú®\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"{model_emoji} <b>{model_name}</b>\n"
                f"üìÅ {model_category}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n"
                f"<i>{model_desc}</i>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )
            
            # Format price text properly (optimize for mobile display)
            import re
            
            # For hailuo models with multiple resolutions, show formatted version
            if model_id == "hailuo/02-image-to-video-standard" or model_id == "hailuo/02-image-to-video-pro":
                # Remove emoji and HTML, but keep the structure
                price_display_clean = price_text.replace("üí∞", "").strip()
                price_display_clean = re.sub(r'<b>(.*?)</b>', r'\1', price_display_clean)
                # Replace (512P: with (–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 512p: to make it clearer
                price_display_clean = price_display_clean.replace("512P:", "üì∫ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 512p:")
                price_display_clean = price_display_clean.replace("768P:", "üì∫ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ 768p:")
                price_display_clean = price_display_clean.replace(" | ", "\n")
                price_display_clean = price_display_clean.replace("‚ÇΩ/6—Å", "‚ÇΩ (6—Å)").replace("‚ÇΩ/10—Å", "‚ÇΩ (10—Å)")
                model_info_text += f"\n{price_display_clean}\n"
            else:
                # For other models, use simple format
                price_display = price_text
                if price_text.startswith("üí∞"):
                    price_display = price_text.replace("üí∞", "").strip()
                # Remove HTML tags if present but keep the content
                price_display = re.sub(r'<b>(.*?)</b>', r'\1', price_display)
                price_display = price_display.strip()
                
                # Shorten price display for mobile
                if len(price_display) > 50:
                    # Extract just the number and currency
                    price_match = re.search(r'(\d+\.?\d*)\s*‚ÇΩ', price_display)
                    if price_match:
                        price_display = f"{price_match.group(1)} ‚ÇΩ"
                
                model_info_text += f"üí∞ <b>–¶–µ–Ω–∞:</b> {price_display}\n"
            
            # Add hint for new users
            if is_new and model_id == FREE_MODEL_ID:
                model_info_text += (
                    f"\nüí° <b>–û—Ç–ª–∏—á–Ω–æ –¥–ª—è –Ω–∞—á–∞–ª–∞!</b>\n"
                    f"–≠—Ç–∞ –º–æ–¥–µ–ª—å –±–µ—Å–ø–ª–∞—Ç–Ω–∞ –¥–ª—è –ø–µ—Ä–≤—ã—Ö {FREE_GENERATIONS_PER_DAY} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –≤ –¥–µ–Ω—å.\n"
                    f"–ü—Ä–æ—Å—Ç–æ –æ–ø–∏—à–∏—Ç–µ, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å, –∏ –Ω–∞–∂–º–∏—Ç–µ \"–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å\"!\n\n"
                )
            
            if is_admin:
                model_info_text += (
                    f"‚úÖ <b>–î–æ—Å—Ç—É–ø:</b> <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n"
                    f"üëë <b>–°—Ç–∞—Ç—É—Å:</b> –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä\n\n"
                )
            else:
                if is_free_available:
                    model_info_text += (
                        f"üéÅ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:</b> {remaining_free}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å\n"
                    )
                    if user_balance >= min_price:
                        paid_count = int(user_balance / min_price)
                        model_info_text += f"üí≥ <b>–ü–ª–∞—Ç–Ω—ã—Ö:</b> {paid_count} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n"
                    model_info_text += f"üíµ <b>–ë–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n\n"
                elif available_count > 0:
                    model_info_text += (
                        f"‚úÖ <b>–î–æ—Å—Ç—É–ø–Ω–æ:</b> {available_count} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n"
                        f"üíµ <b>–ë–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n\n"
                    )
                else:
                    # Not enough balance - show warning
                    model_info_text += (
                        f"\n‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>\n\n"
                        f"üíµ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n"
                        f"üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {format_price_rub(min_price, is_admin)} ‚ÇΩ\n\n"
                        f"üí° –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏"
                    )
                    
                    keyboard = [
                        [InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="topup_balance")],
                        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –º–æ–¥–µ–ª—è–º", callback_data="back_to_menu")]
                    ]
                    
                    await query.edit_message_text(
                        model_info_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return ConversationHandler.END
            
            # Check balance before starting generation (but allow free generations)
            if not is_admin and not is_free_available and user_balance < min_price:
                keyboard = [
                    [InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="topup_balance")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –º–æ–¥–µ–ª—è–º", callback_data="back_to_menu")]
                ]
                
                await query.edit_message_text(
                    f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                    f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)} ‚ÇΩ\n"
                    f"üíµ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º:</b> {price_text} ‚ÇΩ\n\n"
                    f"–ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Store selected model
            if user_id not in user_sessions:
                user_sessions[user_id] = {}
            user_sessions[user_id]['model_id'] = model_id
            user_sessions[user_id]['model_info'] = model_info
            
            # Get input parameters from static definition
            input_params = model_info.get('input_params', {})
            
            if not input_params:
                # If no params defined, ask for simple text input
                keyboard = [
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                await query.edit_message_text(
                    f"{model_info_text}"
                    f"–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                user_sessions[user_id]['params'] = {}
                user_sessions[user_id]['waiting_for'] = 'text'
                return INPUTTING_PARAMS
            
            # Store session data
            user_sessions[user_id]['params'] = {}
            user_sessions[user_id]['properties'] = input_params
            user_sessions[user_id]['required'] = [p for p, info in input_params.items() if info.get('required', False)]
            user_sessions[user_id]['current_param'] = None
            
            # Start with prompt parameter first (if exists)
            # Or start with audio_url if no prompt and audio_url is required
            if 'prompt' in input_params:
                # Check if model supports image input (image_input or image_urls)
                has_image_input = 'image_input' in input_params or 'image_urls' in input_params
                has_audio_input = 'audio_url' in input_params or 'audio_input' in input_params
                
                prompt_text = (
                    f"{model_info_text}"
                )
                
                if has_image_input:
                    prompt_text += (
                        f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                        f"–û–ø–∏—à–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏.\n\n"
                        f"üí° –ü–æ—Å–ª–µ –≤–≤–æ–¥–∞ –ø—Ä–æ–º–ø—Ç–∞ –≤—ã —Å–º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)"
                    )
                elif has_audio_input:
                    prompt_text += (
                        f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</b>\n\n"
                        f"–î–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –ø—Ä–æ–º–ø—Ç –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω.\n\n"
                        f"üí° –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –≤—ã —Å–º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª"
                    )
                else:
                    prompt_text += (
                        f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                        f"–û–ø–∏—à–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:"
                    )
                
                keyboard = [
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")],
                    [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
                ]
                
                await query.edit_message_text(
                    prompt_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                user_sessions[user_id]['current_param'] = 'prompt'
                user_sessions[user_id]['waiting_for'] = 'prompt'
                user_sessions[user_id]['has_image_input'] = has_image_input
                user_sessions[user_id]['has_audio_input'] = has_audio_input
            elif 'audio_url' in input_params and input_params['audio_url'].get('required', False):
                # If no prompt but audio_url is required, start with audio_url
                keyboard = [
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                await query.edit_message_text(
                    f"{model_info_text}"
                    f"üìù <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª</b>\n\n"
                    f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏.\n\n"
                    f"–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG\n"
                    f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                user_sessions[user_id]['current_param'] = 'audio_url'
                user_sessions[user_id]['waiting_for'] = 'audio_url'
            else:
                # If no prompt, start with first required parameter
                await start_next_parameter(update, context, user_id)
            
            return INPUTTING_PARAMS
    
    # If we get here and no handler matched, log and return END
    except Exception as e:
        logger.error(f"Error in button_callback for data '{data}': {e}", exc_info=True)
        try:
            await query.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start", show_alert=True)
        except:
            pass
        return ConversationHandler.END
    
    # Fallback - should never reach here if all handlers work correctly
    logger.warning(f"Unhandled callback data: {data} from user {user_id}")
    try:
        await query.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start", show_alert=True)
    except:
        pass
    return ConversationHandler.END


async def start_next_parameter(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: int):
    """Start input for next parameter."""
    session = user_sessions[user_id]
    properties = session.get('properties', {})
    params = session.get('params', {})
    required = session.get('required', [])
    
    # For elevenlabs/speech-to-text, also show optional parameters
    model_id = session.get('model_id', '')
    all_params_to_check = required.copy()
    if model_id == "elevenlabs/speech-to-text":
        # Add optional parameters that should be shown to user
        for param_name in ['language_code', 'tag_audio_events', 'diarize']:
            if param_name in properties and param_name not in all_params_to_check:
                all_params_to_check.append(param_name)
    
    # Find next unset parameter (skip prompt, image_input, image_urls, audio_url, audio_input as they're handled separately)
    for param_name in all_params_to_check:
        if param_name in ['prompt', 'image_input', 'image_urls', 'audio_url', 'audio_input']:
            continue
        if param_name not in params:
            param_info = properties.get(param_name, {})
            param_type = param_info.get('type', 'string')
            enum_values = param_info.get('enum')
            
            session['current_param'] = param_name
            
            # Handle boolean parameters
            if param_type == 'boolean':
                default_value = param_info.get('default', False)
                is_optional = not param_info.get('required', False)
                
                keyboard = [
                    [
                        InlineKeyboardButton("‚úÖ –î–∞ (true)", callback_data=f"set_param:{param_name}:true"),
                        InlineKeyboardButton("‚ùå –ù–µ—Ç (false)", callback_data=f"set_param:{param_name}:false")
                    ]
                ]
                
                # For optional parameters, add "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å" button
                if is_optional:
                    keyboard.append([InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)", callback_data=f"set_param:{param_name}:{str(default_value).lower()}")])
                
                keyboard.append([InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")])
                keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")])
                
                param_desc = param_info.get('description', '')
                default_text = f"\n\n–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: {'–î–∞' if default_value else '–ù–µ—Ç'}" if is_optional else ""
                chat_id = None
                if hasattr(update, 'effective_chat') and update.effective_chat:
                    chat_id = update.effective_chat.id
                elif hasattr(update, 'message') and update.message:
                    chat_id = update.message.chat_id
                elif hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
                    chat_id = update.callback_query.message.chat_id
                
                if not chat_id:
                    logger.error("Cannot determine chat_id in start_next_parameter")
                    return None
                
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"üìù <b>–í—ã–±–µ—Ä–∏—Ç–µ {param_name}:</b>\n\n{param_desc}{default_text}",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                session['waiting_for'] = param_name
                return INPUTTING_PARAMS
            # If parameter has enum values, show buttons
            elif enum_values:
                keyboard = []
                # Create buttons in rows of 2
                for i in range(0, len(enum_values), 2):
                    row = []
                    row.append(InlineKeyboardButton(
                        enum_values[i],
                        callback_data=f"set_param:{param_name}:{enum_values[i]}"
                    ))
                    if i + 1 < len(enum_values):
                        row.append(InlineKeyboardButton(
                            enum_values[i + 1],
                            callback_data=f"set_param:{param_name}:{enum_values[i + 1]}"
                        ))
                    keyboard.append(row)
                keyboard.append([InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")])
                keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")])
                
                param_desc = param_info.get('description', '')
                # Get chat_id from update
                chat_id = None
                if hasattr(update, 'effective_chat') and update.effective_chat:
                    chat_id = update.effective_chat.id
                elif hasattr(update, 'message') and update.message:
                    chat_id = update.message.chat_id
                elif hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
                    chat_id = update.callback_query.message.chat_id
                
                if not chat_id:
                    logger.error("Cannot determine chat_id in start_next_parameter")
                    return None
                
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"üìù <b>–í—ã–±–µ—Ä–∏—Ç–µ {param_name}:</b>\n\n{param_desc}",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            else:
                # Text input
                param_desc = param_info.get('description', '')
                max_length = param_info.get('max_length')
                max_text = f"\n\n–ú–∞–∫—Å–∏–º—É–º {max_length} —Å–∏–º–≤–æ–ª–æ–≤." if max_length else ""
                is_optional = not param_info.get('required', False)
                default_value = param_info.get('default')
                
                # Get chat_id from update
                chat_id = None
                if hasattr(update, 'effective_chat') and update.effective_chat:
                    chat_id = update.effective_chat.id
                elif hasattr(update, 'message') and update.message:
                    chat_id = update.message.chat_id
                elif hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
                    chat_id = update.callback_query.message.chat_id
                
                if not chat_id:
                    logger.error("Cannot determine chat_id in start_next_parameter")
                    return None
                
                keyboard = []
                # For optional text parameters, add skip button with default value info
                if is_optional:
                    if default_value:
                        # Special handling for language_code - show quick select buttons
                        if param_name == 'language_code' and default_value == 'ru':
                            keyboard.append([
                                InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π (ru)", callback_data=f"set_param:{param_name}:ru"),
                                InlineKeyboardButton("üá∫üá∏ English (en)", callback_data=f"set_param:{param_name}:en")
                            ])
                            keyboard.append([
                                InlineKeyboardButton("üá©üá™ Deutsch (de)", callback_data=f"set_param:{param_name}:de"),
                                InlineKeyboardButton("üá´üá∑ Fran√ßais (fr)", callback_data=f"set_param:{param_name}:fr")
                            ])
                            keyboard.append([InlineKeyboardButton("‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (ru)", callback_data=f"set_param:{param_name}:ru")])
                            keyboard.append([InlineKeyboardButton("‚úèÔ∏è –í–≤–µ—Å—Ç–∏ –¥—Ä—É–≥–æ–π –∫–æ–¥", callback_data=f"set_param:{param_name}:custom")])
                        else:
                            default_text = f" (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: {default_value})" if default_value else ""
                            keyboard.append([InlineKeyboardButton(f"‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é{default_text}", callback_data=f"set_param:{param_name}:{default_value}")])
                    else:
                        keyboard.append([InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", callback_data=f"set_param:{param_name}:")])
                keyboard.append([InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")])
                keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")])
                
                default_info = f"\n\n–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: {default_value}" if default_value and is_optional else ""
                optional_text = "\n\n(–≠—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π)" if is_optional else ""
                
                message_text = f"üìù <b>–í–≤–µ–¥–∏—Ç–µ {param_name}:</b>\n\n{param_desc}{max_text}{default_info}{optional_text}"
                
                # If language_code with quick select, modify message
                if param_name == 'language_code' and default_value == 'ru':
                    message_text = (
                        f"üåç <b>–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –∞—É–¥–∏–æ:</b>\n\n"
                        f"{param_desc}\n\n"
                        f"–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: <b>–†—É—Å—Å–∫–∏–π (ru)</b>\n\n"
                        f"–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –∏–∑ —Å–ø–∏—Å–∫–∞ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∫–æ–¥ —è–∑—ã–∫–∞ –≤—Ä—É—á–Ω—É—é."
                    )
                
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=message_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                
                # If custom input requested, set waiting state
                if param_name == 'language_code' and default_value == 'ru':
                    # Don't set waiting_for yet - wait for button or text input
                    session['language_code_custom'] = False
                else:
                    session['waiting_for'] = param_name
                return INPUTTING_PARAMS
    
    # All parameters collected
    return None


async def input_parameters(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle parameter input."""
    user_id = update.effective_user.id
    
    # Handle admin OCR test
    if user_id == ADMIN_ID and user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'admin_test_ocr':
        if update.message.photo:
            photo = update.message.photo[-1]
            loading_msg = await update.message.reply_text("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...")
            
            try:
                file = await context.bot.get_file(photo.file_id)
                image_data = await file.download_as_bytearray()
                
                # Test OCR - extract text
                try:
                    image = Image.open(BytesIO(image_data))
                    try:
                        extracted_text = pytesseract.image_to_string(image, lang='rus+eng')
                    except Exception as e:
                        logger.warning(f"Error with rus+eng, trying eng only: {e}")
                        try:
                            extracted_text = pytesseract.image_to_string(image, lang='eng')
                        except Exception as e2:
                            logger.warning(f"Error with eng, trying default: {e2}")
                            extracted_text = pytesseract.image_to_string(image)
                except Exception as e:
                    error_msg = str(e)
                    if "tesseract is not installed" in error_msg.lower() or "not in your path" in error_msg.lower():
                        raise Exception("Tesseract OCR –Ω–µ –Ω–∞–π–¥–µ–Ω. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏ –¥–æ–±–∞–≤–ª–µ–Ω –≤ PATH.")
                    else:
                        raise Exception(f"–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞: {error_msg}")
                
                extracted_text_lower = extracted_text.lower()
                
                # Find amounts in text (improved patterns)
                amount_patterns = [
                    # With currency symbols
                    r'(\d+[.,]\d+)\s*[‚ÇΩ—Ä—É–±–†]',
                    r'(\d+)\s*[‚ÇΩ—Ä—É–±–†]',
                    r'[‚ÇΩ—Ä—É–±–†]\s*(\d+[.,]\d+)',
                    r'[‚ÇΩ—Ä—É–±–†]\s*(\d+)',
                    # Near payment keywords
                    r'(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)[:\s]+(\d+[.,]?\d*)',
                    r'(\d+[.,]?\d*)\s*(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)',
                    # Misrecognized currency (B instead of –†, 2 instead of –†)
                    r'(\d+)\s*[B2]',
                    r'(\d+)\s*[‚ÇΩ—Ä—É–±–†B2]',
                    # Standalone numbers (filtered later)
                    r'\b(\d{2,6})\b',
                ]
                
                found_amounts = []
                for pattern in amount_patterns:
                    matches = re.findall(pattern, extracted_text, re.IGNORECASE)
                    for match in matches:
                        try:
                            amount = float(match.replace(',', '.'))
                            # Filter reasonable amounts (10-100000 rubles)
                            if 10 <= amount <= 100000:
                                found_amounts.append(amount)
                        except:
                            continue
                
                # Check for payment keywords
                payment_keywords = [
                    '–ø–µ—Ä–µ–≤–æ–¥', '–æ–ø–ª–∞—Ç–∞', '–ø–ª–∞—Ç–µ–∂', '—Å–ø–±', '—Å–±–ø', 'payment', 'transfer',
                    '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ', '—É—Å–ø–µ—à–Ω–æ', 'success', '–ø–æ–ª—É—á–∞—Ç–µ–ª—å', '—Å—É–º–º–∞', '–∏—Ç–æ–≥–æ',
                    '–∫–≤–∏—Ç–∞–Ω—Ü–∏—è', 'receipt', '—Å—Ç–∞—Ç—É—Å', 'status', '–∫–æ–º–∏—Å—Å–∏—è', 'commission'
                ]
                has_keywords = any(keyword in extracted_text_lower for keyword in payment_keywords)
                
                # Prepare result
                result_text = "üß™ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∞ OCR:</b>\n\n"
                
                result_text += f"üìù <b>–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (–ø–µ—Ä–≤—ã–µ 300 —Å–∏–º–≤–æ–ª–æ–≤):</b>\n"
                result_text += f"<code>{extracted_text[:300].replace('<', '&lt;').replace('>', '&gt;')}</code>\n\n"
                
                if found_amounts:
                    result_text += f"üí∞ <b>–ù–∞–π–¥–µ–Ω–Ω—ã–µ —Å—É–º–º—ã:</b>\n"
                    for amt in sorted(set(found_amounts), reverse=True)[:5]:
                        result_text += f"  ‚Ä¢ {amt:.2f} ‚ÇΩ\n"
                    result_text += "\n"
                else:
                    result_text += "‚ö†Ô∏è <b>–°—É–º–º—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</b>\n\n"
                
                if has_keywords:
                    result_text += "‚úÖ <b>–ü—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã</b>\n"
                else:
                    result_text += "‚ö†Ô∏è <b>–ü—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã</b>\n"
                
                result_text += f"\nüìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
                result_text += f"  ‚Ä¢ –°–∏–º–≤–æ–ª–æ–≤ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: {len(extracted_text)}\n"
                result_text += f"  ‚Ä¢ –°—É–º–º –Ω–∞–π–¥–µ–Ω–æ: {len(found_amounts)}\n"
                result_text += f"  ‚Ä¢ –ö–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤: {'–î–∞' if has_keywords else '–ù–µ—Ç'}\n"
                
                try:
                    await loading_msg.delete()
                except:
                    pass
                
                keyboard = [
                    [InlineKeyboardButton("üîÑ –¢–µ—Å—Ç –µ—â–µ —Ä–∞–∑", callback_data="admin_test_ocr")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
                ]
                
                await update.message.reply_text(
                    result_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                
                # Clean up session
                if user_id in user_sessions:
                    del user_sessions[user_id]
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in admin OCR test: {e}", exc_info=True)
                try:
                    await loading_msg.delete()
                except:
                    pass
                
                error_msg = str(e)
                help_text = ""
                if "tesseract is not installed" in error_msg.lower() or "not in your path" in error_msg.lower() or "tesseract" in error_msg.lower():
                    help_text = (
                        "\n\nüí° <b>–†–µ—à–µ–Ω–∏–µ:</b>\n"
                        "1. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ Tesseract —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\n"
                        "2. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—É—Ç—å: C:\\Program Files\\Tesseract-OCR\\tesseract.exe\n"
                        "3. –ò–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ Tesseract –≤ PATH —Å–∏—Å—Ç–µ–º—ã\n"
                        "4. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞ –ø–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏"
                    )
                
                keyboard = [
                    [InlineKeyboardButton("üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ —Ä–∞–∑", callback_data="admin_test_ocr")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
                ]
                
                await update.message.reply_text(
                    f"‚ùå <b>–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ OCR:</b>\n\n{error_msg}{help_text}\n\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ADMIN_TEST_OCR
        else:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (—Ñ–æ—Ç–æ).\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
            )
            return ADMIN_TEST_OCR
    
    # Handle broadcast message
    if user_id == ADMIN_ID and user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'broadcast_message':
        import time
        from datetime import datetime
        
        # Get message content
        message_text = None
        message_photo = None
        
        if update.message.text:
            message_text = update.message.text
        elif update.message.caption:
            message_text = update.message.caption
        
        if update.message.photo:
            message_photo = update.message.photo[-1]
        
        if not message_text and not message_photo:
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            return WAITING_BROADCAST_MESSAGE
        
        # Get all users
        all_users = get_all_users()
        total_users = len(all_users)
        
        if total_users == 0:
            await update.message.reply_text(
                "‚ùå <b>–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏</b>\n\n"
                "–í –±–∞–∑–µ –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.",
                parse_mode='HTML'
            )
            if user_id in user_sessions:
                del user_sessions[user_id]['waiting_for']
            return ConversationHandler.END
        
        # Create broadcast record
        broadcast_data = {
            'id': len(get_broadcasts()) + 1,
            'message': message_text or '[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ]',
            'created_at': int(time.time()),
            'created_by': user_id,
            'total_users': total_users,
            'sent': 0,
            'delivered': 0,
            'failed': 0,
            'user_ids': []
        }
        
        broadcast_id = save_broadcast(broadcast_data)
        
        # Confirm and start sending
        await update.message.reply_text(
            f"üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
            f"üë• <b>–ü–æ–ª—É—á–∞—Ç–µ–ª–µ–π:</b> {total_users}\n"
            f"üìù <b>–°–æ–æ–±—â–µ–Ω–∏–µ:</b> {message_text[:50] + '...' if message_text and len(message_text) > 50 else message_text or '[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ]'}\n\n"
            f"‚è≥ –ù–∞—á–∏–Ω–∞—é –æ—Ç–ø—Ä–∞–≤–∫—É...",
            parse_mode='HTML'
        )
        
        # Clear waiting state
        if user_id in user_sessions:
            del user_sessions[user_id]['waiting_for']
        
        # Start broadcast in background
        asyncio.create_task(send_broadcast(context, broadcast_id, all_users, message_text, message_photo))
        
        return ConversationHandler.END
    
    # Handle payment screenshot
    if user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'payment_screenshot':
        if update.message.photo:
            # User sent payment screenshot
            photo = update.message.photo[-1]
            screenshot_file_id = photo.file_id
            
            session = user_sessions[user_id]
            amount = session.get('topup_amount', 0)
            
            # Download and analyze screenshot (if OCR available)
            if OCR_AVAILABLE and PIL_AVAILABLE:
                loading_msg = await update.message.reply_text("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å–∫—Ä–∏–Ω—à–æ—Ç...")
            else:
                loading_msg = await update.message.reply_text("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –ø–ª–∞—Ç–µ–∂...")
            
            try:
                # Check for duplicate screenshot
                if check_duplicate_payment(screenshot_file_id):
                    await update.message.reply_text(
                        f"‚ö†Ô∏è <b>–≠—Ç–æ—Ç —Å–∫—Ä–∏–Ω—à–æ—Ç —É–∂–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω</b>\n\n"
                        f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞.\n\n"
                        f"–ï—Å–ª–∏ –≤—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —ç—Ç–æ –Ω–æ–≤—ã–π –ø–ª–∞—Ç–µ–∂, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.",
                        parse_mode='HTML'
                    )
                    return WAITING_PAYMENT_SCREENSHOT
                
                file = await context.bot.get_file(photo.file_id)
                image_data = await file.download_as_bytearray()
                
                # Get expected phone from .env
                expected_phone = os.getenv('PAYMENT_PHONE', '')
                
                # Analyze screenshot (only if OCR available)
                analysis_msg = None
                if OCR_AVAILABLE and PIL_AVAILABLE:
                    analysis = await analyze_payment_screenshot(image_data, amount, expected_phone if expected_phone else None)
                    
                    # Delete loading message
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                    
                    # Check if screenshot is valid - STRICT CHECK (default False)
                    if not analysis.get('valid', False):
                        support_info = get_support_contact()
                        await update.message.reply_text(
                            f"‚ùå <b>–°–∫—Ä–∏–Ω—à–æ—Ç –Ω–µ –ø—Ä–æ—à–µ–ª –ø—Ä–æ–≤–µ—Ä–∫—É</b>\n\n"
                            f"{analysis.get('message', '')}\n\n"
                            f"üòî <b>–ò–∑–≤–∏–Ω–∏—Ç–µ!</b> –ï—Å–ª–∏ –Ω–∞—à–∞ —Å–∏—Å—Ç–µ–º–∞ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–ª–∞ –≤–∞—à—É –æ–ø–ª–∞—Ç—É, –Ω–∞–ø–∏—à–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É - –æ–Ω –ø–æ—Å—Ç–∞—Ä–∞–µ—Ç—Å—è –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ –Ω–∞—á–∏—Å–ª–∏—Ç—å –±–∞–ª–∞–Ω—Å.\n\n"
                            f"{support_info}",
                            parse_mode='HTML'
                        )
                        return WAITING_PAYMENT_SCREENSHOT
                    
                    # Show analysis results
                    analysis_msg = await update.message.reply_text(
                        f"üîç <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–æ–≤–µ—Ä–∫–∏:</b>\n\n"
                        f"{analysis.get('message', '')}\n\n"
                        f"‚è≥ –ù–∞—á–∏—Å–ª—è—é –±–∞–ª–∞–Ω—Å...",
                        parse_mode='HTML'
                    )
                else:
                    # OCR not available - skip analysis and credit balance directly
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                
                # Add payment and auto-credit balance
                payment = add_payment(user_id, amount, screenshot_file_id)
                new_balance = get_user_balance(user_id)
                balance_str = f"{new_balance:.2f}".rstrip('0').rstrip('.')
                
                # Delete analysis message (if exists)
                if analysis_msg:
                    try:
                        await analysis_msg.delete()
                    except:
                        pass
                
                # Clean up session
                del user_sessions[user_id]
                
                # Create keyboard with main menu button
                keyboard = [
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                await update.message.reply_text(
                    f"‚úÖ <b>–û–ø–ª–∞—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∞!</b>\n\n"
                    f"üíµ <b>–°—É–º–º–∞:</b> {amount:.2f} ‚ÇΩ\n"
                    f"üí∞ <b>–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n\n"
                    f"–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ! –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–∞–ª–∞–Ω—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
                
            except Exception as e:
                logger.error(f"Error processing payment screenshot: {e}", exc_info=True)
                try:
                    await loading_msg.delete()
                except:
                    pass
                await update.message.reply_text(
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞</b>\n\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç –µ—â–µ —Ä–∞–∑.\n"
                    f"–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                    parse_mode='HTML'
                )
                return WAITING_PAYMENT_SCREENSHOT
        else:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞ (—Ñ–æ—Ç–æ).\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
            )
            return WAITING_PAYMENT_SCREENSHOT
    
    # Handle custom topup amount input
    if user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'topup_amount_input':
        try:
            amount = float(update.message.text.replace(',', '.'))
            user_lang = get_user_language(user_id)
            
            if amount < 50:
                if user_lang == 'ru':
                    await update.message.reply_text("‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: 50 ‚ÇΩ")
                else:
                    await update.message.reply_text("‚ùå Minimum top-up amount: 50 ‚ÇΩ")
                return SELECTING_AMOUNT
            
            if amount > 50000:
                if user_lang == 'ru':
                    await update.message.reply_text("‚ùå –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: 50000 ‚ÇΩ")
                else:
                    await update.message.reply_text("‚ùå Maximum top-up amount: 50000 ‚ÇΩ")
                return SELECTING_AMOUNT
            
            # Calculate what user can generate
            examples_count = int(amount / 0.62)  # Z-Image price
            video_count = int(amount / 3.86)  # Basic video price
            
            # Show payment method selection
            if user_lang == 'ru':
                payment_text = (
                    f'üí≥ <b>–û–ü–õ–ê–¢–ê {amount:.0f} ‚ÇΩ</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>–ß–¢–û –¢–´ –ü–û–õ–£–ß–ò–®–¨:</b>\n'
                    f'‚Ä¢ ~{examples_count} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π Z-Image\n'
                    f'‚Ä¢ ~{video_count} –≤–∏–¥–µ–æ (–±–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å)\n'
                    f'‚Ä¢ –ò–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>–í–´–ë–ï–†–ò –°–ü–û–°–û–ë –û–ü–õ–ê–¢–´:</b>'
                )
            else:
                payment_text = (
                    f'üí≥ <b>PAYMENT {amount:.0f} ‚ÇΩ</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>Amount to pay:</b> {amount:.2f} ‚ÇΩ\n\n'
                    f'üéØ <b>WHAT YOU WILL GET:</b>\n'
                    f'‚Ä¢ ~{examples_count} Z-Image images\n'
                    f'‚Ä¢ ~{video_count} videos (basic model)\n'
                    f'‚Ä¢ Or a combination of different models!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>CHOOSE PAYMENT METHOD:</b>'
                )
            
            # Store amount in session
            user_sessions[user_id] = {
                'topup_amount': amount,
                'waiting_for': 'payment_method'
            }
            
            # For English users - only Telegram Stars, no SBP
            if user_lang == 'en':
                keyboard = [
                    [InlineKeyboardButton("‚≠ê Telegram Stars", callback_data=f"pay_stars:{amount}")],
                    [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel")]
                ]
            else:
                # For Russian users - both options
                keyboard = [
                    [
                        InlineKeyboardButton("‚≠ê Telegram Stars", callback_data=f"pay_stars:{amount}"),
                        InlineKeyboardButton("üí≥ –°–ë–ü / SBP", callback_data=f"pay_sbp:{amount}")
                    ],
                    [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
                ]
            
            await update.message.reply_text(
                payment_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_AMOUNT
        except ValueError:
            user_lang = get_user_language(user_id)
            if user_lang == 'ru':
                await update.message.reply_text(
                    "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 1500)\n\n"
                    "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
                )
            else:
                await update.message.reply_text(
                    "‚ùå Please enter a number (e.g., 1500)\n\n"
                    "Or press /cancel to cancel."
                )
            return SELECTING_AMOUNT
    
    if user_id not in user_sessions:
        await update.message.reply_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start")
        return ConversationHandler.END
    
    session = user_sessions[user_id]
    properties = session.get('properties', {})
    
    # Handle audio input (for audio_url or audio_input)
    waiting_for_audio = session.get('waiting_for') in ['audio_url', 'audio_input']
    if (update.message.audio or update.message.voice or (update.message.document and update.message.document.mime_type and update.message.document.mime_type.startswith('audio/'))) and waiting_for_audio:
        # Get audio file
        audio_file = None
        if update.message.audio:
            audio_file = update.message.audio
        elif update.message.voice:
            audio_file = update.message.voice
        elif update.message.document:
            audio_file = update.message.document
        
        if not audio_file:
            await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
            return INPUTTING_PARAMS
        
        file = await context.bot.get_file(audio_file.file_id)
        
        # Download audio from Telegram
        loading_msg = None
        try:
            # Show loading message
            loading_msg = await update.message.reply_text("üì§ –ó–∞–≥—Ä—É–∑–∫–∞ –∞—É–¥–∏–æ...")
            
            # Download audio
            try:
                audio_data = await file.download_as_bytearray()
            except Exception as e:
                logger.error(f"Error downloading audio file from Telegram: {e}", exc_info=True)
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª –∏–∑ Telegram.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Check file size (max 200MB as per API)
            if len(audio_data) > 200 * 1024 * 1024:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π</b>\n\n"
                    "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            if len(audio_data) == 0:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ê—É–¥–∏–æ-—Ñ–∞–π–ª –ø—É—Å—Ç–æ–π.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"Downloaded audio: {len(audio_data)} bytes")
            
            # Determine file extension
            file_extension = "mp3"
            if update.message.audio:
                if update.message.audio.mime_type:
                    if "wav" in update.message.audio.mime_type:
                        file_extension = "wav"
                    elif "ogg" in update.message.audio.mime_type:
                        file_extension = "ogg"
                    elif "aac" in update.message.audio.mime_type:
                        file_extension = "aac"
                    elif "mp4" in update.message.audio.mime_type:
                        file_extension = "m4a"
            elif update.message.document and update.message.document.mime_type:
                if "wav" in update.message.document.mime_type:
                    file_extension = "wav"
                elif "ogg" in update.message.document.mime_type:
                    file_extension = "ogg"
                elif "aac" in update.message.document.mime_type:
                    file_extension = "aac"
                elif "mp4" in update.message.document.mime_type:
                    file_extension = "m4a"
            
            # Upload to public hosting
            filename = f"audio_{user_id}_{audio_file.file_id[:8]}.{file_extension}"
            public_url = await upload_image_to_hosting(audio_data, filename=filename)
            
            # Delete loading message
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            if not public_url:
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"Successfully uploaded audio to: {public_url}")
            
            # Set audio_url parameter
            audio_param_name = session.get('waiting_for', 'audio_url')
            session['params'][audio_param_name] = public_url
            session[audio_param_name] = public_url  # Also store in session for consistency
            session['waiting_for'] = None
            session['current_param'] = None
            
            # Confirm audio was set
            await update.message.reply_text(
                f"‚úÖ <b>–ê—É–¥–∏–æ-—Ñ–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω!</b>\n\n"
                f"–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...",
                parse_mode='HTML'
            )
            
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected, show confirmation
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in params.items()])
                    
                    keyboard = [
                        [InlineKeyboardButton("‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="confirm_generate")],
                        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
                    ]
                    
                    await update.message.reply_text(
                        f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                        f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                        f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after audio input: {e}", exc_info=True)
                await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
            
            return INPUTTING_PARAMS
            
        except Exception as e:
            logger.error(f"Error processing audio: {e}", exc_info=True)
            # Try to delete loading message if exists
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏</b>\n\n"
                "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª.\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                parse_mode='HTML'
            )
            return INPUTTING_PARAMS
    
    # Handle image input (for image_input or image_urls)
    waiting_for_image = session.get('waiting_for') in ['image_input', 'image_urls']
    if update.message.photo and waiting_for_image:
        photo = update.message.photo[-1]  # Get largest photo
        file = await context.bot.get_file(photo.file_id)
        
        # Download image from Telegram
        loading_msg = None
        try:
            # Show loading message
            loading_msg = await update.message.reply_text("üì§ –ó–∞–≥—Ä—É–∑–∫–∞...")
            
            # Download image
            try:
                image_data = await file.download_as_bytearray()
            except Exception as e:
                logger.error(f"Error downloading file from Telegram: {e}", exc_info=True)
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ Telegram.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Check file size (max 30MB as per KIE API)
            if len(image_data) > 30 * 1024 * 1024:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π</b>\n\n"
                    "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 30 MB.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            if len(image_data) == 0:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—É—Å—Ç–æ–µ.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"Downloaded image: {len(image_data)} bytes")
            
            # Upload to public hosting
            public_url = await upload_image_to_hosting(image_data, filename=f"image_{user_id}_{photo.file_id[:8]}.jpg")
            
            # Delete loading message
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            if not public_url:
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"Successfully uploaded image to: {public_url}")
            
            # Add to image_input array
            # Determine which parameter name to use
            image_param_name = session.get('waiting_for', 'image_input')  # image_input or image_urls
            if image_param_name not in session:
                session[image_param_name] = []
            session[image_param_name].append(public_url)
            
        except Exception as e:
            logger.error(f"Error processing image: {e}", exc_info=True)
            # Try to delete loading message if exists
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏</b>\n\n"
                "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                parse_mode='HTML'
            )
            return INPUTTING_PARAMS
        
        image_param_name = session.get('waiting_for', 'image_input')
        image_count = len(session[image_param_name])
        
        if image_count < 8:
            keyboard = [
                [InlineKeyboardButton("üì∑ –î–æ–±–∞–≤–∏—Ç—å –µ—â–µ", callback_data="add_image")],
                [InlineKeyboardButton("‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="image_done")]
            ]
            await update.message.reply_text(
                f"‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ {image_count} –¥–æ–±–∞–≤–ª–µ–Ω–æ!\n\n"
                f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ: {image_count}/8\n\n"
                f"–î–æ–±–∞–≤–∏—Ç—å –µ—â–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å?",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await update.message.reply_text(
                f"‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ {image_count} –¥–æ–±–∞–≤–ª–µ–Ω–æ!\n\n"
                f"–î–æ—Å—Ç–∏–≥–Ω—É—Ç –º–∞–∫—Å–∏–º—É–º (8 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π). –ü—Ä–æ–¥–æ–ª–∂–∞—é..."
            )
            session['params'][image_param_name] = session[image_param_name]
            session['waiting_for'] = None
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
            except Exception as e:
                logger.error(f"Error after image input: {e}")
        
        return INPUTTING_PARAMS
    
    # Handle text input
    if not update.message.text:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
        return INPUTTING_PARAMS
    
    text = update.message.text.strip()
    
    # If waiting for text input (prompt or other text parameter)
    waiting_for = session.get('waiting_for')
    if waiting_for:
        current_param = session.get('current_param', waiting_for)
        param_info = properties.get(current_param, {})
        max_length = param_info.get('max_length')
        
        # Validate max length
        if max_length and len(text) > max_length:
            await update.message.reply_text(
                f"‚ùå –¢–µ–∫—Å—Ç —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. {max_length} —Å–∏–º–≤–æ–ª–æ–≤). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
            )
            return INPUTTING_PARAMS
        
        # For language_code, convert common language names to codes
        if current_param == 'language_code':
            lang_lower = text.lower()
            lang_map = {
                '—Ä—É—Å—Å–∫–∏–π': 'ru',
                'russian': 'ru',
                '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π': 'en',
                'english': 'en',
                'eng': 'en',
                '–Ω–µ–º–µ—Ü–∫–∏–π': 'de',
                'german': 'de',
                '—Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π': 'fr',
                'french': 'fr',
                '–∏—Å–ø–∞–Ω—Å–∫–∏–π': 'es',
                'spanish': 'es',
                '–∏—Ç–∞–ª—å—è–Ω—Å–∫–∏–π': 'it',
                'italian': 'it',
                '–∫–∏—Ç–∞–π—Å–∫–∏–π': 'zh',
                'chinese': 'zh',
                '—è–ø–æ–Ω—Å–∫–∏–π': 'ja',
                'japanese': 'ja',
                '–∫–æ—Ä–µ–π—Å–∫–∏–π': 'ko',
                'korean': 'ko'
            }
            if lang_lower in lang_map:
                text = lang_map[lang_lower]
            # If it's already a code (2-3 letters), convert to lowercase
            elif len(text) <= 5 and text.replace('-', '').replace('_', '').isalpha():
                text = text.lower()
        
        # For video_url in sora-watermark-remover, validate URL format
        model_id = session.get('model_id', '')
        if current_param == 'video_url' and model_id == 'sora-watermark-remover':
            # Validate URL format (should contain sora.chatgpt.com)
            if 'sora.chatgpt.com' not in text:
                await update.message.reply_text(
                    f"‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç URL</b>\n\n"
                    f"URL –≤–∏–¥–µ–æ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç OpenAI Sora 2 (–¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å sora.chatgpt.com).\n\n"
                    f"–ü—Ä–∏–º–µ—Ä: https://sora.chatgpt.com/p/s_...\n\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Additional validation: check if URL starts with http:// or https://
            if not (text.startswith('http://') or text.startswith('https://')):
                await update.message.reply_text(
                    f"‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç URL</b>\n\n"
                    f"URL –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://\n\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
        
        # Set parameter value
        session['params'][current_param] = text
        session['waiting_for'] = None
        session['current_param'] = None
        session['language_code_custom'] = False
        
        # Confirm parameter was set
        display_value = text[:100] + '...' if len(text) > 100 else text
        await update.message.reply_text(
            f"‚úÖ <b>{current_param}</b> —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!\n\n"
            f"–ó–Ω–∞—á–µ–Ω–∏–µ: {display_value}",
            parse_mode='HTML'
        )
        
        # If prompt was entered and model supports image input, offer to add image
        # Or if prompt was entered and model supports audio input, offer to add audio
        if current_param == 'prompt':
            model_info = session.get('model_info', {})
            input_params = model_info.get('input_params', {})
            
            # Check for audio_url requirement
            if 'audio_url' in input_params or 'audio_input' in input_params:
                audio_param_name = 'audio_url' if 'audio_url' in input_params else 'audio_input'
                audio_required = input_params.get(audio_param_name, {}).get('required', False)
                
                if audio_required:
                    # Audio is required
                    keyboard = [
                        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                    ]
                    await update.message.reply_text(
                        "üé§ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏</b>\n\n"
                        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª (MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG).\n"
                        "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    session['waiting_for'] = audio_param_name
                    session['current_param'] = audio_param_name
                    return INPUTTING_PARAMS
                else:
                    # Audio is optional - show buttons
                    keyboard = [
                        [InlineKeyboardButton("üé§ –ó–∞–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", callback_data="add_audio")],
                        [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_audio")],
                        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                    ]
                    await update.message.reply_text(
                        "üé§ <b>–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</b>\n\n"
                        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å', —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    session['waiting_for'] = None  # Will be set when user clicks button or sends audio
                    return INPUTTING_PARAMS
            
            # Check if image is required (for image_urls or image_input)
            if session.get('has_image_input'):
                image_required = False
                if 'image_urls' in input_params:
                    image_required = input_params['image_urls'].get('required', False)
                elif 'image_input' in input_params:
                    image_required = input_params['image_input'].get('required', False)
                
                if image_required:
                    # Image is required - show button without skip option
                    keyboard = [
                    [InlineKeyboardButton("üì∑ –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", callback_data="add_image")]
                ]
                await update.message.reply_text(
                    "üì∑ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è</b>\n\n"
                    "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            else:
                # Image is optional - show button with skip option
                keyboard = [
                    [InlineKeyboardButton("üì∑ –î–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", callback_data="add_image")],
                    [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_image")]
                ]
                await update.message.reply_text(
                    "üì∑ <b>–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ?</b>\n\n"
                    "–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n"
                    "–ò–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                session['waiting_for'] = None
                return INPUTTING_PARAMS
        
        # Check if there are more parameters
        required = session.get('required', [])
        params = session.get('params', {})
        missing = [p for p in required if p not in params and p not in ['prompt', 'image_input', 'image_urls', 'audio_url', 'audio_input']]
        
        # For elevenlabs/speech-to-text, also check optional parameters
        model_id = session.get('model_id', '')
        if model_id == "elevenlabs/speech-to-text":
            # Check optional parameters that haven't been set yet
            properties = session.get('properties', {})
            for opt_param in ['language_code', 'tag_audio_events', 'diarize']:
                if opt_param in properties and opt_param not in params:
                    missing.append(opt_param)
        
        if missing:
            # Move to next parameter
            try:
                # Small delay to show confirmation
                await asyncio.sleep(0.5)
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
            except Exception as e:
                logger.error(f"Error starting next parameter: {e}", exc_info=True)
                await update.message.reply_text(
                    f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É: {str(e)}"
                )
                return INPUTTING_PARAMS
        else:
            # All parameters collected, show confirmation
            model_name = session.get('model_info', {}).get('name', 'Unknown')
            model_id = session.get('model_id', '')
            params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
            
            # Check for free generation
            is_admin_user = get_is_admin(user_id)
            is_free = is_free_generation_available(user_id, model_id)
            free_info = ""
            if is_free:
                remaining = get_user_free_generations_remaining(user_id)
                free_info = f"\n\nüéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n"
                free_info += f"–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
            else:
                price = calculate_price_rub(model_id, params, is_admin_user)
                price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                free_info = f"\n\nüí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str} ‚ÇΩ"
            
            keyboard = [
                [InlineKeyboardButton("‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="confirm_generate")],
                [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
            ]
            
            await update.message.reply_text(
                f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}{free_info}\n\n"
                f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return CONFIRMING_GENERATION
    
    # If we get here and waiting_for is not set, something went wrong
    if not waiting_for:
        await update.message.reply_text(
            "‚ùå –û—à–∏–±–∫–∞: –Ω–µ –æ–∂–∏–¥–∞–µ—Ç—Å—è –≤–≤–æ–¥ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /models"
        )
        return ConversationHandler.END
    
    return INPUTTING_PARAMS


async def confirm_generation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle generation confirmation."""
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    is_admin_user = get_is_admin(user_id)
    
    # Check if user is blocked
    if not is_admin_user and is_user_blocked(user_id):
        await query.edit_message_text(
            "‚ùå <b>–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
            "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.",
            parse_mode='HTML'
        )
        return ConversationHandler.END
    
    if user_id not in user_sessions:
        await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return ConversationHandler.END
    
    session = user_sessions[user_id]
    model_id = session.get('model_id')
    params = session.get('params', {})
    model_info = session.get('model_info', {})
    
    # Apply default values for parameters that are not set
    input_params = model_info.get('input_params', {})
    for param_name, param_info in input_params.items():
        if param_name not in params and not param_info.get('required', False):
            default_value = param_info.get('default')
            if default_value is not None:
                params[param_name] = default_value
    
    # Convert string boolean values to actual booleans
    for param_name, param_value in params.items():
        if param_name in input_params:
            param_info = input_params[param_name]
            if param_info.get('type') == 'boolean':
                if isinstance(param_value, str):
                    if param_value.lower() == 'true':
                        params[param_name] = True
                    elif param_value.lower() == 'false':
                        params[param_name] = False
    
    # Check if this is a free generation
    is_free = is_free_generation_available(user_id, model_id)
    
    # Calculate price (admins pay admin price, users pay user price)
    price = calculate_price_rub(model_id, params, is_admin_user)
    
    # For free generations, price is 0
    if is_free:
        price = 0.0
    
    # Check balance/limit before generation
    if not is_admin_user:
        # Regular user - check balance (unless free generation)
        if not is_free:
            user_balance = get_user_balance(user_id)
            if user_balance < price:
                price_str = f"{price:.2f}".rstrip('0').rstrip('.')
                balance_str = f"{user_balance:.2f}".rstrip('0').rstrip('.')
                remaining_free = get_user_free_generations_remaining(user_id)
                
                error_text = (
                    f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>\n\n"
                    f"üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {price_str} ‚ÇΩ\n"
                    f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n\n"
                )
                
                if model_id == FREE_MODEL_ID and remaining_free > 0:
                    error_text += f"üéÅ <b>–ù–æ —É –≤–∞—Å –µ—Å—Ç—å {remaining_free} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π!</b>\n\n"
                    error_text += "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ - –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏."
                else:
                    error_text += "–ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è."
                
                await query.edit_message_text(
                    error_text,
                    parse_mode='HTML'
                )
                return ConversationHandler.END
    elif user_id != ADMIN_ID:
        # Limited admin - check limit
        remaining = get_admin_remaining(user_id)
        if remaining < price:
            price_str = f"{price:.2f}".rstrip('0').rstrip('.')
            remaining_str = f"{remaining:.2f}".rstrip('0').rstrip('.')
            limit = get_admin_limit(user_id)
            spent = get_admin_spent(user_id)
            await query.edit_message_text(
                f"‚ùå <b>–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç</b>\n\n"
                f"üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {price_str} ‚ÇΩ\n"
                f"üí≥ <b>–õ–∏–º–∏—Ç:</b> {limit:.2f} ‚ÇΩ\n"
                f"üí∏ <b>–ü–æ—Ç—Ä–∞—á–µ–Ω–æ:</b> {spent:.2f} ‚ÇΩ\n"
                f"‚úÖ <b>–û—Å—Ç–∞–ª–æ—Å—å:</b> {remaining_str} ‚ÇΩ\n\n"
                f"–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –≥–ª–∞–≤–Ω–æ–º—É –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è –ª–∏–º–∏—Ç–∞.",
                parse_mode='HTML'
            )
            return ConversationHandler.END
    
    await query.edit_message_text("üîÑ –°–æ–∑–¥–∞—é –∑–∞–¥–∞—á—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏... –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ.")
    
    try:
        # Prepare params for API (convert image_input to appropriate parameter name if needed)
        api_params = params.copy()
        if model_id == "seedream/4.5-edit" and 'image_input' in api_params:
            # Convert image_input to image_urls for seedream/4.5-edit
            api_params['image_urls'] = api_params.pop('image_input')
        elif model_id == "kling-2.6/image-to-video" and 'image_input' in api_params:
            # Convert image_input to image_urls for kling-2.6/image-to-video
            api_params['image_urls'] = api_params.pop('image_input')
        elif model_id == "flux-2/pro-image-to-image" and 'image_input' in api_params:
            # Convert image_input to input_urls for flux-2/pro-image-to-image
            api_params['input_urls'] = api_params.pop('image_input')
        elif model_id == "flux-2/flex-image-to-image" and 'image_input' in api_params:
            # Convert image_input to input_urls for flux-2/flex-image-to-image
            api_params['input_urls'] = api_params.pop('image_input')
        elif model_id == "topaz/image-upscale" and 'image_input' in api_params:
            # Convert image_input to image_url for topaz/image-upscale (single image, not array)
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image_url'] = image_input[0]  # Take first image
            elif isinstance(image_input, str):
                api_params['image_url'] = image_input
        elif model_id == "kling/v2-5-turbo-image-to-video-pro" and 'image_input' in api_params:
            # Convert image_input to image_url for kling/v2-5-turbo-image-to-video-pro
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image_url'] = image_input[0]  # Take first image
            elif isinstance(image_input, str):
                api_params['image_url'] = image_input
        elif model_id == "wan/2-5-image-to-video" and 'image_input' in api_params:
            # Convert image_input to image_url for wan/2-5-image-to-video
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image_url'] = image_input[0]  # Take first image
            elif isinstance(image_input, str):
                api_params['image_url'] = image_input
        elif model_id == "hailuo/02-image-to-video-pro" and 'image_input' in api_params:
            # Convert image_input to image_url for hailuo/02-image-to-video-pro
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image_url'] = image_input[0]  # Take first image
            elif isinstance(image_input, str):
                api_params['image_url'] = image_input
        elif model_id == "hailuo/02-image-to-video-standard" and 'image_input' in api_params:
            # Convert image_input to image_url for hailuo/02-image-to-video-standard
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image_url'] = image_input[0]  # Take first image
            elif isinstance(image_input, str):
                api_params['image_url'] = image_input
        elif model_id == "bytedance/seedream-v4-edit" and 'image_input' in api_params:
            # Convert image_input to image_urls for bytedance/seedream-v4-edit
            api_params['image_urls'] = api_params.pop('image_input')
        elif model_id == "topaz/video-upscale" and 'video_input' in api_params:
            # Convert video_input to video_url for topaz/video-upscale
            video_input = api_params.pop('video_input')
            if isinstance(video_input, list) and len(video_input) > 0:
                api_params['video_url'] = video_input[0]  # Take first video
            elif isinstance(video_input, str):
                api_params['video_url'] = video_input
        elif model_id == "wan/2-2-animate-move" or model_id == "wan/2-2-animate-replace":
            # Convert video_input and image_input for wan/2-2-animate models
            if 'video_input' in api_params:
                video_input = api_params.pop('video_input')
                if isinstance(video_input, list) and len(video_input) > 0:
                    api_params['video_url'] = video_input[0]
                elif isinstance(video_input, str):
                    api_params['video_url'] = video_input
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
        elif model_id == "kling/v1-avatar-standard" or model_id == "kling/ai-avatar-v1-pro":
            # Convert image_input and audio_input for kling avatar models
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
            if 'audio_input' in api_params:
                audio_input = api_params.pop('audio_input')
                if isinstance(audio_input, list) and len(audio_input) > 0:
                    api_params['audio_url'] = audio_input[0]
                elif isinstance(audio_input, str):
                    api_params['audio_url'] = audio_input
        elif model_id == "infinitalk/from-audio":
            # Convert image_input and audio_input for infinitalk/from-audio
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
            if 'audio_input' in api_params:
                audio_input = api_params.pop('audio_input')
                if isinstance(audio_input, list) and len(audio_input) > 0:
                    api_params['audio_url'] = audio_input[0]
                elif isinstance(audio_input, str):
                    api_params['audio_url'] = audio_input
        elif model_id == "recraft/remove-background" and 'image_input' in api_params:
            # Convert image_input to image for recraft/remove-background
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image'] = image_input[0]
            elif isinstance(image_input, str):
                api_params['image'] = image_input
        elif model_id == "recraft/crisp-upscale" and 'image_input' in api_params:
            # Convert image_input to image for recraft/crisp-upscale
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image'] = image_input[0]
            elif isinstance(image_input, str):
                api_params['image'] = image_input
        elif model_id == "ideogram/v3-reframe" and 'image_input' in api_params:
            # Convert image_input to image_url for ideogram/v3-reframe
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image_url'] = image_input[0]
            elif isinstance(image_input, str):
                api_params['image_url'] = image_input
        elif model_id == "ideogram/v3-edit":
            # Convert image_input and mask_input for ideogram/v3-edit
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
            if 'mask_input' in api_params:
                mask_input = api_params.pop('mask_input')
                if isinstance(mask_input, list) and len(mask_input) > 0:
                    api_params['mask_url'] = mask_input[0]
                elif isinstance(mask_input, str):
                    api_params['mask_url'] = mask_input
        elif model_id == "ideogram/v3-remix":
            # Convert image_input to image_url for ideogram/v3-remix
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
        elif model_id == "bytedance/v1-pro-fast-image-to-video":
            # Convert image_input to image_url for bytedance/v1-pro-fast-image-to-video
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
        elif model_id == "bytedance/v1-lite-image-to-video" and 'image_input' in api_params:
            # Convert image_input to image_url for bytedance/v1-lite-image-to-video
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image_url'] = image_input[0]
            elif isinstance(image_input, str):
                api_params['image_url'] = image_input
        elif model_id == "bytedance/v1-pro-image-to-video" and 'image_input' in api_params:
            # Convert image_input to image_url for bytedance/v1-pro-image-to-video
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image_url'] = image_input[0]
            elif isinstance(image_input, str):
                api_params['image_url'] = image_input
        elif model_id == "kling/v2-1-master-image-to-video" or model_id == "kling/v2-1-standard" or model_id == "kling/v2-1-pro":
            # Convert image_input to image_url for kling/v2-1 models
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
        elif model_id == "wan/2-2-a14b-image-to-video-turbo":
            # Convert image_input to image_url for wan/2-2-a14b-image-to-video-turbo
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
        elif model_id == "wan/2-2-a14b-speech-to-video-turbo":
            # Convert image_input and audio_input for wan/2-2-a14b-speech-to-video-turbo
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
            if 'audio_input' in api_params:
                audio_input = api_params.pop('audio_input')
                if isinstance(audio_input, list) and len(audio_input) > 0:
                    api_params['audio_url'] = audio_input[0]
                elif isinstance(audio_input, str):
                    api_params['audio_url'] = audio_input
        elif model_id == "qwen/image-to-image" and 'image_input' in api_params:
            # Convert image_input to image_url for qwen/image-to-image
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image_url'] = image_input[0]
            elif isinstance(image_input, str):
                api_params['image_url'] = image_input
        elif model_id == "qwen/image-edit" and 'image_input' in api_params:
            # Convert image_input to image_url for qwen/image-edit
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list) and len(image_input) > 0:
                api_params['image_url'] = image_input[0]
            elif isinstance(image_input, str):
                api_params['image_url'] = image_input
        elif model_id == "google/nano-banana-edit" and 'image_input' in api_params:
            # Convert image_input to image_urls for google/nano-banana-edit
            image_input = api_params.pop('image_input')
            if isinstance(image_input, list):
                api_params['image_urls'] = image_input
            elif isinstance(image_input, str):
                api_params['image_urls'] = [image_input]
        elif model_id == "ideogram/character-edit":
            # Convert image_input, mask_input, and reference_image_input for ideogram/character-edit
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
            if 'mask_input' in api_params:
                mask_input = api_params.pop('mask_input')
                if isinstance(mask_input, list) and len(mask_input) > 0:
                    api_params['mask_url'] = mask_input[0]
                elif isinstance(mask_input, str):
                    api_params['mask_url'] = mask_input
            if 'reference_image_input' in api_params:
                reference_image_input = api_params.pop('reference_image_input')
                if isinstance(reference_image_input, list):
                    api_params['reference_image_urls'] = reference_image_input
                elif isinstance(reference_image_input, str):
                    api_params['reference_image_urls'] = [reference_image_input]
        elif model_id == "ideogram/character-remix":
            # Convert image_input and reference_image_input for ideogram/character-remix
            if 'image_input' in api_params:
                image_input = api_params.pop('image_input')
                if isinstance(image_input, list) and len(image_input) > 0:
                    api_params['image_url'] = image_input[0]
                elif isinstance(image_input, str):
                    api_params['image_url'] = image_input
            if 'reference_image_input' in api_params:
                reference_image_input = api_params.pop('reference_image_input')
                if isinstance(reference_image_input, list):
                    api_params['reference_image_urls'] = reference_image_input
                elif isinstance(reference_image_input, str):
                    api_params['reference_image_urls'] = [reference_image_input]
        elif model_id == "ideogram/character":
            # Convert reference_image_input for ideogram/character
            if 'reference_image_input' in api_params:
                reference_image_input = api_params.pop('reference_image_input')
                if isinstance(reference_image_input, list):
                    api_params['reference_image_urls'] = reference_image_input
                elif isinstance(reference_image_input, str):
                    api_params['reference_image_urls'] = [reference_image_input]
        elif model_id == "elevenlabs/speech-to-text" and 'audio_input' in api_params:
            # Convert audio_input to audio_url for elevenlabs/speech-to-text
            audio_input = api_params.pop('audio_input')
            if isinstance(audio_input, list) and len(audio_input) > 0:
                api_params['audio_url'] = audio_input[0]
            elif isinstance(audio_input, str):
                api_params['audio_url'] = audio_input
        
        # For seedream/4.5-text-to-image, validate and normalize parameters
        # NOTE: Price calculation - Currently fixed at 6.5 credits regardless of quality/aspect_ratio
        # If API pricing changes based on quality (basic=2K, high=4K), update calculate_price_rub() accordingly
        if model_id == "seedream/4.5-text-to-image":
            # Validate prompt (required, max 3000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ seedream/4.5-text-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for seedream/4.5-text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 3000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 3000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for seedream/4.5-text-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (required, enum values)
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "2:3", "3:2", "21:9"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for seedream/4.5-text-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate and normalize quality (required, enum values: basic/high)
            # NOTE: Quality affects output (basic=2K, high=4K) but currently doesn't affect price
            # If API pricing changes, update calculate_price_rub() to use params.get('quality')
            # API accepts "basic" or "high" (lowercase), but user might send "Basic" or "High"
            valid_qualities = ["basic", "high"]
            if 'quality' not in api_params or not api_params.get('quality'):
                # Use default if not set
                api_params['quality'] = "basic"
            else:
                quality = str(api_params['quality']).strip().lower()
                # Normalize: Basic/High -> basic/high (already lowercased above)
                if quality not in valid_qualities:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ quality.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: basic, high\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('quality')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid quality for seedream/4.5-text-to-image: {api_params.get('quality')}")
                    return ConversationHandler.END
                api_params['quality'] = quality
        
        # For seedream/4.5-edit, validate and normalize parameters
        # NOTE: Price calculation - Currently fixed at 6.5 credits regardless of quality/aspect_ratio
        # If API pricing changes based on quality (basic=2K, high=4K), update calculate_price_rub() accordingly
        if model_id == "seedream/4.5-edit":
            # Validate prompt (required, max 3000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ seedream/4.5-edit."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for seedream/4.5-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 3000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 3000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for seedream/4.5-edit: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs)
            # Note: image_input is converted to image_urls earlier in the code
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ seedream/4.5-edit."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_urls for seedream/4.5-edit")
                return ConversationHandler.END
            
            # Ensure image_urls is a list
            image_urls = api_params['image_urls']
            if not isinstance(image_urls, list):
                # Convert single URL to list
                if isinstance(image_urls, str):
                    image_urls = [image_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(image_urls).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_urls type for seedream/4.5-edit: {type(image_urls)}")
                    return ConversationHandler.END
            
            # Validate that list is not empty
            if len(image_urls) == 0:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_urls array for seedream/4.5-edit")
                return ConversationHandler.END
            
            # Validate each URL is a string
            for i, url in enumerate(image_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ image_urls –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_urls[{i}] for seedream/4.5-edit: {url}")
                    return ConversationHandler.END
            
            api_params['image_urls'] = [url.strip() for url in image_urls]
            
            # Validate aspect_ratio (required, enum values)
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "2:3", "3:2", "21:9"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for seedream/4.5-edit: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate and normalize quality (required, enum values: basic/high)
            # NOTE: Quality affects output (basic=2K, high=4K) but currently doesn't affect price
            # If API pricing changes, update calculate_price_rub() to use params.get('quality')
            # API accepts "basic" or "high" (lowercase), but user might send "Basic" or "High"
            valid_qualities = ["basic", "high"]
            if 'quality' not in api_params or not api_params.get('quality'):
                # Use default if not set
                api_params['quality'] = "basic"
            else:
                quality = str(api_params['quality']).strip().lower()
                # Normalize: Basic/High -> basic/high (already lowercased above)
                if quality not in valid_qualities:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ quality.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: basic, high\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('quality')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid quality for seedream/4.5-edit: {api_params.get('quality')}")
                    return ConversationHandler.END
                api_params['quality'] = quality
        
        # For kling-2.6/image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on duration and sound parameters
        # 5s no-audio: 55 credits, 10s no-audio: 110 credits
        # 5s with audio: 110 credits, 10s with audio: 220 credits
        if model_id == "kling-2.6/image-to-video":
            # Validate prompt (required, max 1000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling-2.6/image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling-2.6/image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 1000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 1000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for kling-2.6/image-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs)
            # Note: image_input is converted to image_urls earlier in the code
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling-2.6/image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_urls for kling-2.6/image-to-video")
                return ConversationHandler.END
            
            # Ensure image_urls is a list
            image_urls = api_params['image_urls']
            if not isinstance(image_urls, list):
                # Convert single URL to list
                if isinstance(image_urls, str):
                    image_urls = [image_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(image_urls).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_urls type for kling-2.6/image-to-video: {type(image_urls)}")
                    return ConversationHandler.END
            
            # Validate that list is not empty
            if len(image_urls) == 0:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_urls array for kling-2.6/image-to-video")
                return ConversationHandler.END
            
            # Validate each URL is a string
            for i, url in enumerate(image_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ image_urls –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_urls[{i}] for kling-2.6/image-to-video: {url}")
                    return ConversationHandler.END
            
            api_params['image_urls'] = [url.strip() for url in image_urls]
            
            # Validate sound (required, boolean)
            # NOTE: This parameter affects price - with sound costs more
            if 'sound' not in api_params:
                # Use default if not set
                api_params['sound'] = False
            else:
                sound = api_params.get('sound')
                # Normalize boolean: convert string "true"/"false" to boolean if needed
                if isinstance(sound, str):
                    sound_lower = sound.lower().strip()
                    if sound_lower in ['true', '1', 'yes', 'on']:
                        sound = True
                    elif sound_lower in ['false', '0', 'no', 'off', '']:
                        sound = False
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ sound.\n"
                            f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: true, false\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {sound}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid sound value for kling-2.6/image-to-video: {sound}")
                        return ConversationHandler.END
                elif not isinstance(sound, bool):
                    # Convert to boolean if it's a number
                    if isinstance(sound, (int, float)):
                        sound = bool(sound)
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä sound –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(sound).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid sound type for kling-2.6/image-to-video: {type(sound)}")
                        return ConversationHandler.END
                api_params['sound'] = sound
            
            # Validate duration (required, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' not in api_params or not api_params.get('duration'):
                # Use default if not set
                api_params['duration'] = "5"
            else:
                duration = str(api_params['duration']).strip()
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ duration.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_durations)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {duration}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for kling-2.6/image-to-video: {duration}")
                    return ConversationHandler.END
                api_params['duration'] = duration
        
        # For kling-2.6/text-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on duration and sound parameters (same as image-to-video)
        # 5s no-audio: 55 credits, 10s no-audio: 110 credits
        # 5s with audio: 110 credits, 10s with audio: 220 credits
        # aspect_ratio does NOT affect price
        if model_id == "kling-2.6/text-to-video":
            # Validate prompt (required, max 1000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling-2.6/text-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling-2.6/text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 1000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 1000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for kling-2.6/text-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate sound (required, boolean)
            # NOTE: This parameter affects price - with sound costs more
            if 'sound' not in api_params:
                # Use default if not set
                api_params['sound'] = False
            else:
                sound = api_params.get('sound')
                # Normalize boolean: convert string "true"/"false" to boolean if needed
                if isinstance(sound, str):
                    sound_lower = sound.lower().strip()
                    if sound_lower in ['true', '1', 'yes', 'on']:
                        sound = True
                    elif sound_lower in ['false', '0', 'no', 'off', '']:
                        sound = False
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ sound.\n"
                            f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: true, false\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {sound}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid sound value for kling-2.6/text-to-video: {sound}")
                        return ConversationHandler.END
                elif not isinstance(sound, bool):
                    # Convert to boolean if it's a number
                    if isinstance(sound, (int, float)):
                        sound = bool(sound)
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä sound –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(sound).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid sound type for kling-2.6/text-to-video: {type(sound)}")
                        return ConversationHandler.END
                api_params['sound'] = sound
            
            # Validate aspect_ratio (required, enum values: "1:1", "16:9", "9:16")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "16:9", "9:16"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for kling-2.6/text-to-video: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate duration (required, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' not in api_params or not api_params.get('duration'):
                # Use default if not set
                api_params['duration'] = "5"
            else:
                duration = str(api_params['duration']).strip()
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ duration.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_durations)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {duration}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for kling-2.6/text-to-video: {duration}")
                    return ConversationHandler.END
                api_params['duration'] = duration
        
        # For z-image, validate and normalize parameters
        # NOTE: Price calculation - Fixed at 0.8 credits per image (doesn't depend on parameters)
        if model_id == "z-image":
            # Validate prompt (required, max 1000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ z-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for z-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 1000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 1000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for z-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (required, enum values)
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for z-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
        
        # For flux-2/pro-image-to-image, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution parameter
        # 1K: 5 credits, 2K: 7 credits
        if model_id == "flux-2/pro-image-to-image":
            # Validate prompt (required, min 3, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/pro-image-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for flux-2/pro-image-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) < 3:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω. 3 —Å–∏–º–≤–æ–ª–∞).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too short for flux-2/pro-image-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for flux-2/pro-image-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate input_urls (required, array of URLs, 1-8 images)
            # Note: image_input is converted to input_urls earlier in the code
            if 'input_urls' not in api_params or not api_params.get('input_urls'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>input_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/pro-image-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter input_urls for flux-2/pro-image-to-image")
                return ConversationHandler.END
            
            # Ensure input_urls is a list
            input_urls = api_params['input_urls']
            if not isinstance(input_urls, list):
                # Convert single URL to list
                if isinstance(input_urls, str):
                    input_urls = [input_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä input_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(input_urls).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid input_urls type for flux-2/pro-image-to-image: {type(input_urls)}")
                    return ConversationHandler.END
            
            # Validate that list is not empty and has 1-8 items
            if len(input_urls) == 0:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>input_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º. –¢—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty input_urls array for flux-2/pro-image-to-image")
                return ConversationHandler.END
            
            if len(input_urls) > 8:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä input_urls —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–º–∞–∫—Å. 8).\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(input_urls)}."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many input_urls for flux-2/pro-image-to-image: {len(input_urls)}")
                return ConversationHandler.END
            
            # Validate each URL is a string
            for i, url in enumerate(input_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ input_urls –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid input_urls[{i}] for flux-2/pro-image-to-image: {url}")
                    return ConversationHandler.END
            
            api_params['input_urls'] = [url.strip() for url in input_urls]
            
            # Validate aspect_ratio (required, enum values, including "auto")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "3:2", "2:3", "auto"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for flux-2/pro-image-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate resolution (required, enum values: "1K" or "2K")
            # NOTE: This parameter affects price - 1K = 5 credits, 2K = 7 credits
            valid_resolutions = ["1K", "2K"]
            if 'resolution' not in api_params or not api_params.get('resolution'):
                # Use default if not set
                api_params['resolution'] = "1K"
            else:
                resolution = str(api_params['resolution']).strip()
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ resolution.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_resolutions)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {resolution}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for flux-2/pro-image-to-image: {resolution}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
        
        # For flux-2/pro-text-to-image, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution parameter (same as image-to-image)
        # 1K: 5 credits, 2K: 7 credits
        if model_id == "flux-2/pro-text-to-image":
            # Validate prompt (required, min 3, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/pro-text-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for flux-2/pro-text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) < 3:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω. 3 —Å–∏–º–≤–æ–ª–∞).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too short for flux-2/pro-text-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for flux-2/pro-text-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (required, enum values, including "auto")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            # Note: "auto" is available but requires input image (not applicable for text-to-image)
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "3:2", "2:3", "auto"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for flux-2/pro-text-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate resolution (required, enum values: "1K" or "2K")
            # NOTE: This parameter affects price - 1K = 5 credits, 2K = 7 credits
            valid_resolutions = ["1K", "2K"]
            if 'resolution' not in api_params or not api_params.get('resolution'):
                # Use default if not set
                api_params['resolution'] = "1K"
            else:
                resolution = str(api_params['resolution']).strip()
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ resolution.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_resolutions)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {resolution}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for flux-2/pro-text-to-image: {resolution}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
        
        # For flux-2/flex-image-to-image, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution parameter
        # 1K: 14 credits, 2K: 24 credits (higher than pro version)
        if model_id == "flux-2/flex-image-to-image":
            # Validate prompt (required, min 3, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/flex-image-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for flux-2/flex-image-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) < 3:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω. 3 —Å–∏–º–≤–æ–ª–∞).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too short for flux-2/flex-image-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for flux-2/flex-image-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate input_urls (required, array of URLs, 1-8 images)
            # Note: image_input is converted to input_urls earlier in the code
            if 'input_urls' not in api_params or not api_params.get('input_urls'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>input_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/flex-image-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter input_urls for flux-2/flex-image-to-image")
                return ConversationHandler.END
            
            # Ensure input_urls is a list
            input_urls = api_params['input_urls']
            if not isinstance(input_urls, list):
                # Convert single URL to list
                if isinstance(input_urls, str):
                    input_urls = [input_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä input_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(input_urls).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid input_urls type for flux-2/flex-image-to-image: {type(input_urls)}")
                    return ConversationHandler.END
            
            # Validate that list is not empty and has 1-8 items
            if len(input_urls) == 0:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>input_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º. –¢—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty input_urls array for flux-2/flex-image-to-image")
                return ConversationHandler.END
            
            if len(input_urls) > 8:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä input_urls —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–º–∞–∫—Å. 8).\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(input_urls)}."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many input_urls for flux-2/flex-image-to-image: {len(input_urls)}")
                return ConversationHandler.END
            
            # Validate each URL is a string
            for i, url in enumerate(input_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ input_urls –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid input_urls[{i}] for flux-2/flex-image-to-image: {url}")
                    return ConversationHandler.END
            
            api_params['input_urls'] = [url.strip() for url in input_urls]
            
            # Validate aspect_ratio (required, enum values, including "auto")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "3:2", "2:3", "auto"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for flux-2/flex-image-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate resolution (required, enum values: "1K" or "2K")
            # NOTE: This parameter affects price - 1K = 14 credits, 2K = 24 credits
            valid_resolutions = ["1K", "2K"]
            if 'resolution' not in api_params or not api_params.get('resolution'):
                # Use default if not set
                api_params['resolution'] = "1K"
            else:
                resolution = str(api_params['resolution']).strip()
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ resolution.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_resolutions)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {resolution}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for flux-2/flex-image-to-image: {resolution}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
        
        # For flux-2/flex-text-to-image, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution parameter (same as flex-image-to-image)
        # 1K: 14 credits, 2K: 24 credits (higher than pro version)
        if model_id == "flux-2/flex-text-to-image":
            # Validate prompt (required, min 3, max 5000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ flux-2/flex-text-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for flux-2/flex-text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) < 3:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω. 3 —Å–∏–º–≤–æ–ª–∞).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too short for flux-2/flex-text-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            if len(prompt) > 5000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 5000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for flux-2/flex-text-to-image: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (required, enum values, including "auto")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            # Note: "auto" is available but requires input image (not applicable for text-to-image)
            valid_aspect_ratios = ["1:1", "4:3", "3:4", "16:9", "9:16", "3:2", "2:3", "auto"]
            if 'aspect_ratio' not in api_params or not api_params.get('aspect_ratio'):
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            else:
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for flux-2/flex-text-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate resolution (required, enum values: "1K" or "2K")
            # NOTE: This parameter affects price - 1K = 14 credits, 2K = 24 credits
            valid_resolutions = ["1K", "2K"]
            if 'resolution' not in api_params or not api_params.get('resolution'):
                # Use default if not set
                api_params['resolution'] = "1K"
            else:
                resolution = str(api_params['resolution']).strip()
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ resolution.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_resolutions)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {resolution}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for flux-2/flex-text-to-image: {resolution}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
        
        # For nano-banana-pro, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution parameter
        # 1K/2K: 18 credits, 4K: 24 credits
        if model_id == "nano-banana-pro":
            # Validate prompt (required, max 10000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ nano-banana-pro."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for nano-banana-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 10000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 10000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for nano-banana-pro: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_input (optional, array of URLs, up to 8 images)
            # Note: image_input is kept as-is (not converted to another parameter name)
            if 'image_input' in api_params and api_params.get('image_input'):
                image_input = api_params['image_input']
                
                # Ensure image_input is a list
                if not isinstance(image_input, list):
                    # Convert single URL to list
                    if isinstance(image_input, str):
                        image_input = [image_input]
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_input –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(image_input).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid image_input type for nano-banana-pro: {type(image_input)}")
                        return ConversationHandler.END
                
                # Validate that list has max 8 items
                if len(image_input) > 8:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_input —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–º–∞–∫—Å. 8).\n"
                        f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(image_input)}."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Too many image_input for nano-banana-pro: {len(image_input)}")
                    return ConversationHandler.END
                
                # Validate each URL is a string
                for i, url in enumerate(image_input):
                    if not isinstance(url, str) or not url.strip():
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ image_input –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                            f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid image_input[{i}] for nano-banana-pro: {url}")
                        return ConversationHandler.END
                
                api_params['image_input'] = [url.strip() for url in image_input]
            
            # Validate aspect_ratio (optional, enum values, including "auto")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "9:16", "16:9", "21:9", "auto"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for nano-banana-pro: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Use default if not set
                api_params['aspect_ratio'] = "1:1"
            
            # Validate resolution (optional, enum values: "1K", "2K", or "4K")
            # NOTE: This parameter affects price - 1K/2K = 18 credits, 4K = 24 credits
            valid_resolutions = ["1K", "2K", "4K"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip()
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ resolution.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_resolutions)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {resolution}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for nano-banana-pro: {resolution}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "1K"
            
            # Validate output_format (optional, enum values: "png" or "jpg")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_output_formats = ["png", "jpg"]
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().lower()
                # Normalize: PNG/JPG -> png/jpg
                if output_format not in valid_output_formats:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ output_format.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_output_formats)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('output_format')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid output_format for nano-banana-pro: {api_params.get('output_format')}")
                    return ConversationHandler.END
                api_params['output_format'] = output_format
            else:
                # Use default if not set
                api_params['output_format'] = "png"
        
        # For bytedance/v1-pro-fast-image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution and duration parameters
        # 480p, 5s: 10 credits (estimated), 480p, 10s: 20 credits (estimated)
        # 720p, 5s: 16 credits, 720p, 10s: 36 credits
        # 1080p, 5s: 36 credits, 1080p, 10s: 72 credits
        if model_id == "bytedance/v1-pro-fast-image-to-video":
            # Validate prompt (required, max 10000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-pro-fast-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/v1-pro-fast-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if len(prompt) > 10000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä prompt —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 10000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for bytedance/v1-pro-fast-image-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, single URL)
            # Note: image_input is converted to image_url earlier in the code
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-pro-fast-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for bytedance/v1-pro-fast-image-to-video")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for bytedance/v1-pro-fast-image-to-video")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for bytedance/v1-pro-fast-image-to-video: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate resolution (optional, enum values: "480p", "720p", or "1080p")
            # NOTE: This parameter affects price - higher resolution costs more
            valid_resolutions = ["480p", "720p", "1080p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Normalize: ensure it ends with 'p'
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('resolution')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for bytedance/v1-pro-fast-image-to-video: {api_params.get('resolution')}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "720p"
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            # Note: API form shows "5s" and "10s", but enum uses "5" and "10"
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove 's' if present
                if duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5s</b> –∏–ª–∏ <b>10s</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for bytedance/v1-pro-fast-image-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
        
        # For bytedance/v1-lite-text-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution and duration parameters (see calculate_price_rub())
        if model_id == "bytedance/v1-lite-text-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-lite-text-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/v1-lite-text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/v1-lite-text-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (optional, enum: "16:9", default: "16:9")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in ["16:9"]:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>16:9</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for bytedance/v1-lite-text-to-video: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Use default if not set
                api_params['aspect_ratio'] = "16:9"
            
            # Validate resolution (optional, enum values: "480p", "720p", or "1080p")
            # NOTE: This parameter affects price - higher resolution costs more
            valid_resolutions = ["480p", "720p", "1080p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Normalize: ensure it ends with 'p'
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('resolution')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for bytedance/v1-lite-text-to-video: {api_params.get('resolution')}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "480p"
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove "s" suffix if present
                if duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5s</b> –∏–ª–∏ <b>10s</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for bytedance/v1-lite-text-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
            
            # Validate camera_fixed (optional, boolean)
            if 'camera_fixed' in api_params and api_params.get('camera_fixed') is not None:
                camera_fixed = api_params['camera_fixed']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(camera_fixed, str):
                    camera_fixed = camera_fixed.strip().lower()
                    if camera_fixed in ['true', '1', 'yes', 'on']:
                        camera_fixed = True
                    elif camera_fixed in ['false', '0', 'no', 'off']:
                        camera_fixed = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['camera_fixed']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid camera_fixed for bytedance/v1-lite-text-to-video: {api_params['camera_fixed']}")
                        return ConversationHandler.END
                elif not isinstance(camera_fixed, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(camera_fixed).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid camera_fixed type for bytedance/v1-lite-text-to-video: {type(camera_fixed)}")
                    return ConversationHandler.END
                api_params['camera_fixed'] = camera_fixed
            else:
                # Remove camera_fixed if it's empty or None
                if 'camera_fixed' in api_params:
                    del api_params['camera_fixed']
            
            # Validate seed (optional, integer, can be -1 for random)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for bytedance/v1-lite-text-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Allow -1 for random seed
                    if seed != -1 and seed < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º –∏–ª–∏ -1 (–¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed value for bytedance/v1-lite-text-to-video: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for bytedance/v1-lite-text-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid enable_safety_checker for bytedance/v1-lite-text-to-video: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid enable_safety_checker type for bytedance/v1-lite-text-to-video: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
        
        # For bytedance/v1-pro-text-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution and duration parameters (see calculate_price_rub())
        if model_id == "bytedance/v1-pro-text-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-pro-text-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/v1-pro-text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/v1-pro-text-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (optional, enum: "16:9", default: "16:9")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in ["16:9"]:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>16:9</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for bytedance/v1-pro-text-to-video: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Use default if not set
                api_params['aspect_ratio'] = "16:9"
            
            # Validate resolution (optional, enum values: "480p", "720p", or "1080p")
            # NOTE: This parameter affects price - higher resolution costs more
            valid_resolutions = ["480p", "720p", "1080p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Normalize: ensure it ends with 'p'
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('resolution')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for bytedance/v1-pro-text-to-video: {api_params.get('resolution')}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "720p"
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove "s" suffix if present
                if duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5s</b> –∏–ª–∏ <b>10s</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for bytedance/v1-pro-text-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
            
            # Validate camera_fixed (optional, boolean)
            if 'camera_fixed' in api_params and api_params.get('camera_fixed') is not None:
                camera_fixed = api_params['camera_fixed']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(camera_fixed, str):
                    camera_fixed = camera_fixed.strip().lower()
                    if camera_fixed in ['true', '1', 'yes', 'on']:
                        camera_fixed = True
                    elif camera_fixed in ['false', '0', 'no', 'off']:
                        camera_fixed = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['camera_fixed']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid camera_fixed for bytedance/v1-pro-text-to-video: {api_params['camera_fixed']}")
                        return ConversationHandler.END
                elif not isinstance(camera_fixed, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(camera_fixed).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid camera_fixed type for bytedance/v1-pro-text-to-video: {type(camera_fixed)}")
                    return ConversationHandler.END
                api_params['camera_fixed'] = camera_fixed
            else:
                # Remove camera_fixed if it's empty or None
                if 'camera_fixed' in api_params:
                    del api_params['camera_fixed']
            
            # Validate seed (optional, integer, can be -1 for random)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for bytedance/v1-pro-text-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Allow -1 for random seed
                    if seed != -1 and seed < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º –∏–ª–∏ -1 (–¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed value for bytedance/v1-pro-text-to-video: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for bytedance/v1-pro-text-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid enable_safety_checker for bytedance/v1-pro-text-to-video: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid enable_safety_checker type for bytedance/v1-pro-text-to-video: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
        
        # For bytedance/v1-lite-image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution and duration parameters (see calculate_price_rub())
        if model_id == "bytedance/v1-lite-image-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-lite-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/v1-lite-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/v1-lite-image-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-lite-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for bytedance/v1-lite-image-to-video")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for bytedance/v1-lite-image-to-video")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for bytedance/v1-lite-image-to-video: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate resolution (optional, enum values: "480p", "720p", or "1080p")
            # NOTE: This parameter affects price - higher resolution costs more
            valid_resolutions = ["480p", "720p", "1080p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Normalize: ensure it ends with 'p'
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('resolution')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for bytedance/v1-lite-image-to-video: {api_params.get('resolution')}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "480p"
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove "s" suffix if present
                if duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5s</b> –∏–ª–∏ <b>10s</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for bytedance/v1-lite-image-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
            
            # Validate camera_fixed (optional, boolean)
            if 'camera_fixed' in api_params and api_params.get('camera_fixed') is not None:
                camera_fixed = api_params['camera_fixed']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(camera_fixed, str):
                    camera_fixed = camera_fixed.strip().lower()
                    if camera_fixed in ['true', '1', 'yes', 'on']:
                        camera_fixed = True
                    elif camera_fixed in ['false', '0', 'no', 'off']:
                        camera_fixed = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['camera_fixed']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid camera_fixed for bytedance/v1-lite-image-to-video: {api_params['camera_fixed']}")
                        return ConversationHandler.END
                elif not isinstance(camera_fixed, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(camera_fixed).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid camera_fixed type for bytedance/v1-lite-image-to-video: {type(camera_fixed)}")
                    return ConversationHandler.END
                api_params['camera_fixed'] = camera_fixed
            else:
                # Remove camera_fixed if it's empty or None
                if 'camera_fixed' in api_params:
                    del api_params['camera_fixed']
            
            # Validate seed (optional, integer, can be -1 for random)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for bytedance/v1-lite-image-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Allow -1 for random seed
                    if seed != -1 and seed < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º –∏–ª–∏ -1 (–¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed value for bytedance/v1-lite-image-to-video: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for bytedance/v1-lite-image-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid enable_safety_checker for bytedance/v1-lite-image-to-video: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid enable_safety_checker type for bytedance/v1-lite-image-to-video: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
            
            # Validate end_image_url (optional, URL)
            if 'end_image_url' in api_params and api_params.get('end_image_url'):
                end_image_url = str(api_params['end_image_url']).strip()
                if end_image_url:
                    # Validate URL format
                    if not (end_image_url.startswith('http://') or end_image_url.startswith('https://')):
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>end_image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {end_image_url[:50]}..."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid end_image_url format for bytedance/v1-lite-image-to-video: {end_image_url[:50]}")
                        return ConversationHandler.END
                    api_params['end_image_url'] = end_image_url
                else:
                    # Remove end_image_url if it's empty
                    del api_params['end_image_url']
            else:
                # Remove end_image_url if it's empty or None
                if 'end_image_url' in api_params:
                    del api_params['end_image_url']
        
        # For bytedance/v1-pro-image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Price depends on resolution and duration parameters (see calculate_price_rub())
        if model_id == "bytedance/v1-pro-image-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-pro-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/v1-pro-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/v1-pro-image-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/v1-pro-image-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for bytedance/v1-pro-image-to-video")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for bytedance/v1-pro-image-to-video")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for bytedance/v1-pro-image-to-video: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate resolution (optional, enum values: "480p", "720p", or "1080p")
            # NOTE: This parameter affects price - higher resolution costs more
            valid_resolutions = ["480p", "720p", "1080p"]
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Normalize: ensure it ends with 'p'
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in valid_resolutions:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('resolution')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for bytedance/v1-pro-image-to-video: {api_params.get('resolution')}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Use default if not set
                api_params['resolution'] = "720p"
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter affects price - longer duration costs more
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove "s" suffix if present
                if duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5s</b> –∏–ª–∏ <b>10s</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for bytedance/v1-pro-image-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
            
            # Validate camera_fixed (optional, boolean)
            if 'camera_fixed' in api_params and api_params.get('camera_fixed') is not None:
                camera_fixed = api_params['camera_fixed']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(camera_fixed, str):
                    camera_fixed = camera_fixed.strip().lower()
                    if camera_fixed in ['true', '1', 'yes', 'on']:
                        camera_fixed = True
                    elif camera_fixed in ['false', '0', 'no', 'off']:
                        camera_fixed = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['camera_fixed']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid camera_fixed for bytedance/v1-pro-image-to-video: {api_params['camera_fixed']}")
                        return ConversationHandler.END
                elif not isinstance(camera_fixed, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>camera_fixed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(camera_fixed).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid camera_fixed type for bytedance/v1-pro-image-to-video: {type(camera_fixed)}")
                    return ConversationHandler.END
                api_params['camera_fixed'] = camera_fixed
            else:
                # Remove camera_fixed if it's empty or None
                if 'camera_fixed' in api_params:
                    del api_params['camera_fixed']
            
            # Validate seed (optional, integer, can be -1 for random)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for bytedance/v1-pro-image-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    # Allow -1 for random seed
                    if seed != -1 and seed < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º –∏–ª–∏ -1 (–¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed value for bytedance/v1-pro-image-to-video: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ -1 –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ seed.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for bytedance/v1-pro-image-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid enable_safety_checker for bytedance/v1-pro-image-to-video: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid enable_safety_checker type for bytedance/v1-pro-image-to-video: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
        
        # For kling/v2-1-master-image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "kling/v2-1-master-image-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-1-master-image-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/v2-1-master-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/v2-1-master-image-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-1-master-image-to-video.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for kling/v2-1-master-image-to-video")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for kling/v2-1-master-image-to-video")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for kling/v2-1-master-image-to-video: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate duration (optional, enum values: "5" or "10")
            # NOTE: This parameter may affect price
            valid_durations = ["5", "10"]
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip()
                # Normalize: remove "seconds" or "s" suffix if present
                if duration.lower().endswith('seconds'):
                    duration = duration[:-7].strip()
                elif duration.endswith('s') or duration.endswith('S'):
                    duration = duration[:-1]
                
                if duration not in valid_durations:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5 seconds</b> –∏–ª–∏ <b>10 seconds</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('duration')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for kling/v2-1-master-image-to-video: {api_params.get('duration')}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Use default if not set
                api_params['duration'] = "5"
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize cfg_scale (optional, number)
            # Note: cfg_scale should be a number (float), user might send "0,5" (comma) or "0.5" (dot)
            if 'cfg_scale' in api_params and api_params.get('cfg_scale') is not None:
                cfg_scale = api_params['cfg_scale']
                try:
                    # Convert string to float, handling both comma and dot as decimal separator
                    if isinstance(cfg_scale, str):
                        # Replace comma with dot for European number format
                        cfg_scale_str = cfg_scale.strip().replace(',', '.')
                        cfg_scale = float(cfg_scale_str)
                    elif isinstance(cfg_scale, (int, float)):
                        cfg_scale = float(cfg_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(cfg_scale).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid cfg_scale type for kling/v2-1-master-image-to-video: {type(cfg_scale)}")
                        return ConversationHandler.END
                    
                    # Validate range (typically 0-20, but we'll allow any positive number)
                    if cfg_scale < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {cfg_scale}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid cfg_scale value for kling/v2-1-master-image-to-video: {cfg_scale}")
                        return ConversationHandler.END
                    
                    api_params['cfg_scale'] = cfg_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('cfg_scale')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid cfg_scale for kling/v2-1-master-image-to-video: {api_params.get('cfg_scale')}")
                    return ConversationHandler.END
            else:
                # Remove cfg_scale if it's empty or None
                if 'cfg_scale' in api_params:
                    del api_params['cfg_scale']
        
        # For grok-imagine/image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "grok-imagine/image-to-video":
            # Validate that either image_urls OR task_id is provided (but not both)
            has_image_urls = 'image_urls' in api_params and api_params.get('image_urls')
            has_task_id = 'task_id' in api_params and api_params.get('task_id')
            
            if not has_image_urls and not has_task_id:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –ª–∏–±–æ <b>image_urls</b> (–≤–Ω–µ—à–Ω–∏–π URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è), "
                    "–ª–∏–±–æ <b>task_id</b> (ID –∑–∞–¥–∞—á–∏ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Grok).\n\n"
                    "–ù–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–±–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter: need either image_urls or task_id for grok-imagine/image-to-video")
                return ConversationHandler.END
            
            if has_image_urls and has_task_id:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ù–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <b>image_urls</b> –∏ <b>task_id</b> –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.\n\n"
                    "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ —Å–ø–æ—Å–æ–±–æ–≤:\n"
                    "‚Ä¢ <b>image_urls</b> - –≤–Ω–µ—à–Ω–∏–π URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\n"
                    "‚Ä¢ <b>task_id</b> + <b>index</b> - –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Grok"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Cannot use both image_urls and task_id for grok-imagine/image-to-video")
                return ConversationHandler.END
            
            # Validate image_urls if provided (optional, array, max 1 image)
            if has_image_urls:
                # Remove task_id and index if image_urls is used
                if 'task_id' in api_params:
                    api_params.pop('task_id')
                if 'index' in api_params:
                    api_params.pop('index')
                
                image_urls = api_params['image_urls']
                
                # Ensure image_urls is a list
                if not isinstance(image_urls, list):
                    # Convert single URL to list
                    if isinstance(image_urls, str):
                        image_urls = [image_urls]
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(image_urls).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid image_urls type for grok-imagine/image-to-video: {type(image_urls)}")
                        return ConversationHandler.END
                
                # Validate that list has max 1 item
                if len(image_urls) > 1:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä image_urls –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                        f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(image_urls)}."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Too many image_urls for grok-imagine/image-to-video: {len(image_urls)}")
                    return ConversationHandler.END
                
                # Validate URL is a string
                if len(image_urls) > 0:
                    url = image_urls[0]
                    if not isinstance(url, str) or not url.strip():
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–≠–ª–µ–º–µ–Ω—Ç –≤ image_urls –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–æ–π (URL)."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid image_urls[0] for grok-imagine/image-to-video: {url}")
                        return ConversationHandler.END
                    api_params['image_urls'] = [url.strip()]
            
            # Validate task_id if provided (optional, string)
            if has_task_id:
                # Remove image_urls if task_id is used
                if 'image_urls' in api_params:
                    api_params.pop('image_urls')
                
                task_id = str(api_params['task_id']).strip()
                if not task_id:
                    error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>task_id</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Empty task_id for grok-imagine/image-to-video")
                    return ConversationHandler.END
                api_params['task_id'] = task_id
                
                # Validate index if task_id is provided (optional, 0-5, 0-based)
                if 'index' in api_params and api_params.get('index') is not None:
                    try:
                        index = int(api_params['index'])
                        if index < 0 or index > 5:
                            error_msg = (
                                f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                                f"–ü–∞—Ä–∞–º–µ—Ç—Ä index –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç 0 –¥–æ 5 (0-based).\n"
                                f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {index}"
                            )
                            await query.edit_message_text(error_msg, parse_mode='HTML')
                            logger.error(f"Invalid index for grok-imagine/image-to-video: {index}")
                            return ConversationHandler.END
                        api_params['index'] = index
                    except (ValueError, TypeError):
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä index –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0 –¥–æ 5.\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('index')}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid index type for grok-imagine/image-to-video: {api_params.get('index')}")
                        return ConversationHandler.END
                else:
                    # Use default if not set
                    api_params['index'] = 0
            
            # Validate prompt (optional, string)
            if 'prompt' in api_params and api_params.get('prompt'):
                prompt = str(api_params['prompt']).strip()
                api_params['prompt'] = prompt
            
            # Validate mode (optional, enum values: "fun", "normal", "spicy")
            # NOTE: Spicy mode is not supported when using external image_urls
            valid_modes = ["fun", "normal", "spicy"]
            if 'mode' in api_params and api_params.get('mode'):
                mode = str(api_params['mode']).strip().lower()
                if mode not in valid_modes:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ mode.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_modes)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('mode')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid mode for grok-imagine/image-to-video: {api_params.get('mode')}")
                    return ConversationHandler.END
                
                # Check if spicy mode is used with external image_urls (not allowed)
                if mode == "spicy" and has_image_urls:
                    logger.warning(f"Spicy mode used with image_urls for grok-imagine/image-to-video, switching to normal")
                    # Automatically switch to normal mode (spicy not supported with external images)
                    mode = "normal"
                
                api_params['mode'] = mode
            else:
                # Use default if not set
                api_params['mode'] = "normal"
        
        # For grok-imagine/text-to-video, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "grok-imagine/text-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ grok-imagine/text-to-video."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for grok-imagine/text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for grok-imagine/text-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (optional, enum values: "2:3", "3:2", "1:1")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["2:3", "3:2", "1:1"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for grok-imagine/text-to-video: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            
            # Validate mode (optional, enum values: "fun", "normal", "spicy")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_modes = ["fun", "normal", "spicy"]
            if 'mode' in api_params and api_params.get('mode'):
                mode = str(api_params['mode']).strip().lower()
                if mode not in valid_modes:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ mode.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_modes)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {api_params.get('mode')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid mode for grok-imagine/text-to-video: {api_params.get('mode')}")
                    return ConversationHandler.END
                api_params['mode'] = mode
            else:
                # Use default if not set
                api_params['mode'] = "normal"
        
        # For grok-imagine/text-to-image, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "grok-imagine/text-to-image":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ grok-imagine/text-to-image."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for grok-imagine/text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for grok-imagine/text-to-image")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate aspect_ratio (optional, enum values: "2:3", "3:2", "1:1")
            # NOTE: Currently doesn't affect price, but validated for API correctness
            valid_aspect_ratios = ["2:3", "3:2", "1:1"]
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                if aspect_ratio not in valid_aspect_ratios:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ aspect_ratio.\n"
                        f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(valid_aspect_ratios)}\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {aspect_ratio}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for grok-imagine/text-to-image: {aspect_ratio}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
        
        # For grok-imagine/upscale, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "grok-imagine/upscale":
            # Validate task_id (required, string)
            # Note: task_id must be from a Kie AI-generated task (supports only Kie AI-generated taskid)
            if 'task_id' not in api_params or not api_params.get('task_id'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>task_id</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ grok-imagine/upscale.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ taskid –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Grok –Ω–∞ Kie AI."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter task_id for grok-imagine/upscale")
                return ConversationHandler.END
            
            task_id = str(api_params['task_id']).strip()
            if not task_id:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>task_id</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ taskid –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Grok –Ω–∞ Kie AI."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty task_id for grok-imagine/upscale")
                return ConversationHandler.END
            
            # Basic validation: task_id should not be empty and should look like a valid task ID
            # Note: Full validation would require checking if task_id exists in Kie AI system
            # For now, we just validate that it's a non-empty string
            api_params['task_id'] = task_id
        
        # For hailuo/2-3-image-to-video-pro, validate and normalize parameters
        # NOTE: Price depends on resolution and duration (see calculate_price_rub())
        # Price calculation: 768P ~5 credits/sec, 1080P ~9.5 credits/sec
        # IMPORTANT: 10-second videos are NOT supported for 1080P resolution
        if model_id == "hailuo/2-3-image-to-video-pro":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/2-3-image-to-video-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/2-3-image-to-video-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, single URL string)
            # Note: This model uses image_url (singular), not image_urls (plural)
            if 'image_url' not in api_params or not api_params.get('image_url'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_url if it's a single URL string
                    if isinstance(image_input, str):
                        api_params['image_url'] = image_input.strip()
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        # If it's a list, take the first URL
                        api_params['image_url'] = str(image_input[0]).strip()
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-pro.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Missing required parameter image_url for hailuo/2-3-image-to-video-pro")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-pro.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Missing required parameter image_url for hailuo/2-3-image-to-video-pro")
                    return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for hailuo/2-3-image-to-video-pro")
                return ConversationHandler.END
            
            # Basic URL format validation
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for hailuo/2-3-image-to-video-pro: {image_url}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize duration (optional, enum: "6" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["6", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>6</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for hailuo/2-3-image-to-video-pro: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "6"
            
            # Validate and normalize resolution (optional, enum: "768P" or "1080P")
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().upper()
                # Ensure "P" suffix
                if not resolution.endswith('P'):
                    resolution = resolution + 'P'
                
                if resolution not in ["768P", "1080P"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>768P</b> –∏–ª–∏ <b>1080P</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for hailuo/2-3-image-to-video-pro: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "768P"
            
            # Validate mutual exclusivity: 10-second videos are not supported for 1080p resolution
            duration = api_params.get('duration', '6')
            resolution = api_params.get('resolution', '768P')
            if duration == "10" and resolution == "1080P":
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "10-—Å–µ–∫—É–Ω–¥–Ω—ã–µ –≤–∏–¥–µ–æ <b>–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è</b> –¥–ª—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è <b>1080P</b>.\n\n"
                    "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω–æ –∏–∑:\n"
                    "‚Ä¢ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ <b>768P</b> —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é 10 —Å–µ–∫—É–Ω–¥\n"
                    "‚Ä¢ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ <b>1080P</b> —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é 6 —Å–µ–∫—É–Ω–¥"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid combination for hailuo/2-3-image-to-video-pro: duration=10, resolution=1080P")
                return ConversationHandler.END
        
        # For hailuo/2-3-image-to-video-standard, validate and normalize parameters
        # NOTE: Price depends on resolution and duration (see calculate_price_rub())
        # Price calculation: 768P ~5 credits/sec, 1080P ~7 credits/sec (standard version is cheaper than Pro)
        # IMPORTANT: 10-second videos are NOT supported for 1080P resolution
        if model_id == "hailuo/2-3-image-to-video-standard":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-standard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/2-3-image-to-video-standard")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/2-3-image-to-video-standard")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, single URL string)
            # Note: This model uses image_url (singular), not image_urls (plural)
            if 'image_url' not in api_params or not api_params.get('image_url'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_url if it's a single URL string
                    if isinstance(image_input, str):
                        api_params['image_url'] = image_input.strip()
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        # If it's a list, take the first URL
                        api_params['image_url'] = str(image_input[0]).strip()
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-standard.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Missing required parameter image_url for hailuo/2-3-image-to-video-standard")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/2-3-image-to-video-standard.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Missing required parameter image_url for hailuo/2-3-image-to-video-standard")
                    return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –≤—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for hailuo/2-3-image-to-video-standard")
                return ConversationHandler.END
            
            # Basic URL format validation
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for hailuo/2-3-image-to-video-standard: {image_url}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize duration (optional, enum: "6" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["6", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>6</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for hailuo/2-3-image-to-video-standard: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "6"
            
            # Validate and normalize resolution (optional, enum: "768P" or "1080P")
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().upper()
                # Ensure "P" suffix
                if not resolution.endswith('P'):
                    resolution = resolution + 'P'
                
                if resolution not in ["768P", "1080P"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>768P</b> –∏–ª–∏ <b>1080P</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for hailuo/2-3-image-to-video-standard: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "768P"
            
            # Validate mutual exclusivity: 10-second videos are not supported for 1080p resolution
            duration = api_params.get('duration', '6')
            resolution = api_params.get('resolution', '768P')
            if duration == "10" and resolution == "1080P":
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "10-—Å–µ–∫—É–Ω–¥–Ω—ã–µ –≤–∏–¥–µ–æ <b>–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è</b> –¥–ª—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è <b>1080P</b>.\n\n"
                    "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω–æ –∏–∑:\n"
                    "‚Ä¢ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ <b>768P</b> —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é 10 —Å–µ–∫—É–Ω–¥\n"
                    "‚Ä¢ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ <b>1080P</b> —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é 6 —Å–µ–∫—É–Ω–¥"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid combination for hailuo/2-3-image-to-video-standard: duration=10, resolution=1080P")
                return ConversationHandler.END
        
        # For sora-2-pro-storyboard, validate and normalize parameters
        # NOTE: Price depends on n_frames (see calculate_price_rub())
        # Price calculation: 10s = 150 credits, 15-25s = 270 credits
        if model_id == "sora-2-pro-storyboard":
            # Validate shots (required, array of objects with Scene and duration)
            if 'shots' not in api_params or not api_params.get('shots'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>shots</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-storyboard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –º–∞—Å—Å–∏–≤ —Å—Ü–µ–Ω —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –∫–∞–∂–¥–æ–π —Å—Ü–µ–Ω—ã."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter shots for sora-2-pro-storyboard")
                return ConversationHandler.END
            
            shots = api_params['shots']
            if not isinstance(shots, list):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>shots</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º –æ–±—ä–µ–∫—Ç–æ–≤.\n\n"
                    "–ö–∞–∂–¥—ã–π –æ–±—ä–µ–∫—Ç –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å:\n"
                    "‚Ä¢ <b>Scene</b> (—Å—Ç—Ä–æ–∫–∞) - –æ–ø–∏—Å–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã\n"
                    "‚Ä¢ <b>duration</b> (—á–∏—Å–ª–æ) - –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —Å–µ–∫—É–Ω–¥–∞—Ö"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid shots type for sora-2-pro-storyboard: {type(shots)}")
                return ConversationHandler.END
            
            if len(shots) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>shots</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É —Å—Ü–µ–Ω—É —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty shots array for sora-2-pro-storyboard")
                return ConversationHandler.END
            
            # Validate each shot object
            total_duration = 0.0
            validated_shots = []
            for i, shot in enumerate(shots, 1):
                if not isinstance(shot, dict):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–°—Ü–µ–Ω–∞ #{i} –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ–±—ä–µ–∫—Ç–æ–º (—Å–ª–æ–≤–∞—Ä–µ–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(shot).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid shot #{i} type for sora-2-pro-storyboard: {type(shot)}")
                    return ConversationHandler.END
                
                # Validate Scene (required, string)
                if 'Scene' not in shot or not shot.get('Scene'):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–°—Ü–µ–Ω–∞ #{i}: –ø–∞—Ä–∞–º–µ—Ç—Ä <b>Scene</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω.\n\n"
                        f"–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Missing Scene in shot #{i} for sora-2-pro-storyboard")
                    return ConversationHandler.END
                
                scene_text = str(shot['Scene']).strip()
                if not scene_text:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–°—Ü–µ–Ω–∞ #{i}: –ø–∞—Ä–∞–º–µ—Ç—Ä <b>Scene</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                        f"–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Empty Scene in shot #{i} for sora-2-pro-storyboard")
                    return ConversationHandler.END
                
                # Validate duration (required, number)
                if 'duration' not in shot:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–°—Ü–µ–Ω–∞ #{i}: –ø–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω.\n\n"
                        f"–£–∫–∞–∂–∏—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å—Ü–µ–Ω—ã –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (—á–∏—Å–ª–æ)."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Missing duration in shot #{i} for sora-2-pro-storyboard")
                    return ConversationHandler.END
                
                try:
                    duration = float(shot['duration'])
                    if duration <= 0:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–°—Ü–µ–Ω–∞ #{i}: –ø–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {duration}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid duration in shot #{i} for sora-2-pro-storyboard: {duration}")
                        return ConversationHandler.END
                except (ValueError, TypeError):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–°—Ü–µ–Ω–∞ #{i}: –ø–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {shot['duration']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration type in shot #{i} for sora-2-pro-storyboard: {type(shot['duration'])}")
                    return ConversationHandler.END
                
                validated_shots.append({
                    "Scene": scene_text,
                    "duration": duration
                })
                total_duration += duration
            
            api_params['shots'] = validated_shots
            
            # Validate n_frames (required, string: "10", "15", or "25")
            if 'n_frames' not in api_params or not api_params.get('n_frames'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-storyboard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –æ–±—â—É—é –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤–∏–¥–µ–æ: <b>10</b>, <b>15</b> –∏–ª–∏ <b>25</b> —Å–µ–∫—É–Ω–¥."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter n_frames for sora-2-pro-storyboard")
                return ConversationHandler.END
            
            n_frames = str(api_params['n_frames']).strip()
            # Normalize by removing "s" suffix if present
            if n_frames.lower().endswith('s'):
                n_frames = n_frames[:-1].strip()
            
            if n_frames not in ["10", "15", "25"]:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>10</b>, <b>15</b> –∏–ª–∏ <b>25</b> —Å–µ–∫—É–Ω–¥.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['n_frames']}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid n_frames for sora-2-pro-storyboard: {api_params['n_frames']}")
                return ConversationHandler.END
            api_params['n_frames'] = n_frames
            
            # Validate that total duration of shots matches n_frames (with small tolerance for floating point)
            n_frames_float = float(n_frames)
            if abs(total_duration - n_frames_float) > 0.1:  # Allow 0.1 second tolerance
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–°—É–º–º–∞ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π –≤—Å–µ—Ö —Å—Ü–µ–Ω (<b>{total_duration:.1f}—Å</b>) –¥–æ–ª–∂–Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å "
                    f"–æ–±—â–µ–π –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤–∏–¥–µ–æ <b>n_frames</b> (<b>{n_frames}—Å</b>).\n\n"
                    "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤—Å–µ—Ö —Å—Ü–µ–Ω –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–µ <b>shots</b>."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Total shots duration ({total_duration}) doesn't match n_frames ({n_frames}) for sora-2-pro-storyboard")
                return ConversationHandler.END
            
            # Validate image_urls (optional, array of URLs, max 1 image)
            if 'image_urls' in api_params and api_params.get('image_urls'):
                image_urls = api_params['image_urls']
                # Convert single URL string to list
                if isinstance(image_urls, str):
                    image_urls = [image_urls]
                
                if not isinstance(image_urls, list):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–ª–∏ –æ–¥–Ω–∏–º URL —Å—Ç—Ä–æ–∫–æ–π.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(image_urls).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_urls type for sora-2-pro-storyboard: {type(image_urls)}")
                    return ConversationHandler.END
                
                if len(image_urls) > 1:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –º–∞–∫—Å–∏–º—É–º <b>1</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {len(image_urls)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Too many image_urls for sora-2-pro-storyboard: {len(image_urls)}")
                    return ConversationHandler.END
                
                # Validate each URL
                validated_image_urls = []
                for i, url in enumerate(image_urls, 1):
                    if not isinstance(url, str):
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π (URL).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(url).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid image_url #{i} type for sora-2-pro-storyboard: {type(url)}")
                        return ConversationHandler.END
                    
                    url = url.strip()
                    if not url:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                            f"–£–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Empty image_url #{i} for sora-2-pro-storyboard")
                        return ConversationHandler.END
                    
                    if not (url.startswith('http://') or url.startswith('https://')):
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {url[:50]}..."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid image_url #{i} format for sora-2-pro-storyboard: {url}")
                        return ConversationHandler.END
                    
                    validated_image_urls.append(url)
                
                api_params['image_urls'] = validated_image_urls
            else:
                # Remove image_urls if it's empty or None
                if 'image_urls' in api_params:
                    del api_params['image_urls']
            
            # Validate aspect_ratio (optional, enum: "portrait" or "landscape")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                
                if aspect_ratio not in ["portrait", "landscape"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>portrait</b> –∏–ª–∏ <b>landscape</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for sora-2-pro-storyboard: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
        
        # For elevenlabs/speech-to-text, validate and normalize parameters
        # NOTE: Price calculation - 3.5 credits per minute (calculated in calculate_price_rub)
        if model_id == "elevenlabs/speech-to-text":
            # Validate audio_url (required, URL)
            if 'audio_url' not in api_params or not api_params.get('audio_url'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ elevenlabs/speech-to-text."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter audio_url for elevenlabs/speech-to-text")
                return ConversationHandler.END
            
            audio_url = str(api_params['audio_url']).strip()
            if not audio_url.startswith(('http://', 'https://')):
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {audio_url[:100]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid audio_url format for elevenlabs/speech-to-text: {audio_url[:100]}")
                return ConversationHandler.END
            api_params['audio_url'] = audio_url
            
            # Validate language_code (optional, string, default "eng")
            # Common language codes: eng, ru, de, fr, es, it, zh, ja, ko, etc.
            if 'language_code' in api_params and api_params.get('language_code'):
                lang_code = str(api_params['language_code']).strip()
                if lang_code:
                    # Try to convert common language names to codes
                    lang_lower = lang_code.lower()
                    lang_map = {
                        '—Ä—É—Å—Å–∫–∏–π': 'ru',
                        'russian': 'ru',
                        '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π': 'en',
                        'english': 'en',
                        'eng': 'en',
                        '–Ω–µ–º–µ—Ü–∫–∏–π': 'de',
                        'german': 'de',
                        '—Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π': 'fr',
                        'french': 'fr',
                        '–∏—Å–ø–∞–Ω—Å–∫–∏–π': 'es',
                        'spanish': 'es',
                        '–∏—Ç–∞–ª—å—è–Ω—Å–∫–∏–π': 'it',
                        'italian': 'it',
                        '–∫–∏—Ç–∞–π—Å–∫–∏–π': 'zh',
                        'chinese': 'zh',
                        '—è–ø–æ–Ω—Å–∫–∏–π': 'ja',
                        'japanese': 'ja',
                        '–∫–æ—Ä–µ–π—Å–∫–∏–π': 'ko',
                        'korean': 'ko'
                    }
                    if lang_lower in lang_map:
                        api_params['language_code'] = lang_map[lang_lower]
                    # If it's already a code (2-5 letters), keep it as is (normalize to lowercase)
                    elif len(lang_code) <= 5 and lang_code.replace('-', '').replace('_', '').isalpha():
                        api_params['language_code'] = lang_code.lower()
                    else:
                        # Invalid format, use default "eng"
                        api_params['language_code'] = 'eng'
                else:
                    # Empty language_code - use default "eng"
                    api_params['language_code'] = 'eng'
            else:
                # Use default "eng" if not set
                api_params['language_code'] = 'eng'
            
            # Validate tag_audio_events (optional, boolean)
            if 'tag_audio_events' in api_params and api_params.get('tag_audio_events') is not None:
                tag_audio_events = api_params['tag_audio_events']
                # Normalize boolean values
                if isinstance(tag_audio_events, str):
                    tag_audio_events_lower = tag_audio_events.lower().strip()
                    if tag_audio_events_lower in ['true', '1', 'yes', 'on']:
                        api_params['tag_audio_events'] = True
                    elif tag_audio_events_lower in ['false', '0', 'no', 'off']:
                        api_params['tag_audio_events'] = False
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>tag_audio_events</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±—É–ª–µ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {tag_audio_events}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid tag_audio_events for elevenlabs/speech-to-text: {tag_audio_events}")
                        return ConversationHandler.END
                elif isinstance(tag_audio_events, bool):
                    api_params['tag_audio_events'] = tag_audio_events
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>tag_audio_events</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±—É–ª–µ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(tag_audio_events).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid tag_audio_events type for elevenlabs/speech-to-text: {type(tag_audio_events)}")
                    return ConversationHandler.END
                
                # Remove if False (default value)
                if api_params.get('tag_audio_events') is False:
                    api_params.pop('tag_audio_events')
            
            # Validate diarize (optional, boolean)
            if 'diarize' in api_params and api_params.get('diarize') is not None:
                diarize = api_params['diarize']
                # Normalize boolean values
                if isinstance(diarize, str):
                    diarize_lower = diarize.lower().strip()
                    if diarize_lower in ['true', '1', 'yes', 'on']:
                        api_params['diarize'] = True
                    elif diarize_lower in ['false', '0', 'no', 'off']:
                        api_params['diarize'] = False
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>diarize</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±—É–ª–µ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {diarize}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid diarize for elevenlabs/speech-to-text: {diarize}")
                        return ConversationHandler.END
                elif isinstance(diarize, bool):
                    api_params['diarize'] = diarize
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>diarize</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±—É–ª–µ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(diarize).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid diarize type for elevenlabs/speech-to-text: {type(diarize)}")
                    return ConversationHandler.END
                
                # Remove if False (default value)
                if api_params.get('diarize') is False:
                    api_params.pop('diarize')
        
        # Log API params for debugging (only for admin)
        if is_admin_user:
            logger.info(f"Creating task for model {model_id} with params: {json.dumps(api_params, indent=2, ensure_ascii=False)}")
        
        # For elevenlabs/speech-to-text, verify audio_url is accessible
        if model_id == "elevenlabs/speech-to-text" and 'audio_url' in api_params:
            audio_url = api_params['audio_url']
            try:
                # Quick check if URL is accessible
                session = await get_http_client()
                async with session.head(audio_url) as resp:
                        if resp.status != 200:
                            logger.warning(f"Audio URL returned status {resp.status}: {audio_url}")
                            if is_admin_user:
                                await query.edit_message_text(
                                    f"‚ö†Ô∏è <b>–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ</b>\n\n"
                                    f"URL –∞—É–¥–∏–æ-—Ñ–∞–π–ª–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å {resp.status}.\n"
                                    f"URL: {audio_url[:100]}...\n\n"
                                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª –µ—â–µ —Ä–∞–∑.",
                                    parse_mode='HTML'
                                )
                                return ConversationHandler.END
            except Exception as e:
                logger.warning(f"Could not verify audio URL accessibility: {e}")
        
        # For sora-watermark-remover, validate video_url parameter
        # NOTE: Price calculation - Fixed at 10 credits per use (doesn't depend on parameters)
        if model_id == "sora-watermark-remover":
            if 'video_url' not in api_params or not api_params.get('video_url'):
                error_msg = "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-watermark-remover."
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter video_url for sora-watermark-remover")
                return ConversationHandler.END
            
            video_url = str(api_params['video_url']).strip()
            
            # Validate max length (500 characters)
            if len(video_url) > 500:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"URL –≤–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 500 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(video_url)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"video_url too long for sora-watermark-remover: {len(video_url)} characters")
                return ConversationHandler.END
            
            # Validate URL format (should contain sora.chatgpt.com)
            # Accept URLs like: https://sora.chatgpt.com/p/s_...
            if 'sora.chatgpt.com' not in video_url:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"URL –≤–∏–¥–µ–æ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç OpenAI Sora 2 (–¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å sora.chatgpt.com).\n\n"
                    f"–ü—Ä–∏–º–µ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ URL: https://sora.chatgpt.com/p/s_...\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π URL: {video_url[:100]}{'...' if len(video_url) > 100 else ''}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid video_url format for sora-watermark-remover: {video_url[:100]}")
                return ConversationHandler.END
            
            # Additional validation: check if URL looks like a valid Sora URL
            # Should start with http:// or https://
            if not (video_url.startswith('http://') or video_url.startswith('https://')):
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"URL –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π URL: {video_url[:100]}{'...' if len(video_url) > 100 else ''}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid video_url protocol for sora-watermark-remover: {video_url[:100]}")
                return ConversationHandler.END
            
            # Update api_params with validated video_url
            api_params['video_url'] = video_url
            
            # Optional: Quick check if URL is accessible (similar to audio_url check)
        
        # For sora-2-pro-text-to-video, validate and normalize parameters
        # NOTE: Price depends on size and n_frames (see calculate_price_rub())
        # Price calculation:
        # Standard: 10s = 150 credits, 15s = 270 credits
        # High: 10s = 330 credits, 15s = 630 credits
        if model_id == "sora-2-pro-text-to-video":
            # Validate prompt (required, string, max 10000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-text-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for sora-2-pro-text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for sora-2-pro-text-to-video")
                return ConversationHandler.END
            
            if len(prompt) > 10000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 10000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for sora-2-pro-text-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize aspect_ratio (optional, enum: "portrait" or "landscape")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                
                if aspect_ratio not in ["portrait", "landscape"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>portrait</b> –∏–ª–∏ <b>landscape</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for sora-2-pro-text-to-video: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate and normalize n_frames (optional, enum: "10" or "15" seconds)
            # Normalize by removing "s" suffix if present
            if 'n_frames' in api_params and api_params.get('n_frames'):
                n_frames = str(api_params['n_frames']).strip()
                # Remove "s" suffix if present
                if n_frames.lower().endswith('s'):
                    n_frames = n_frames[:-1].strip()
                
                if n_frames not in ["10", "15"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>10</b> –∏–ª–∏ <b>15</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['n_frames']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid n_frames for sora-2-pro-text-to-video: {api_params['n_frames']}")
                    return ConversationHandler.END
                api_params['n_frames'] = n_frames
            else:
                # Default n_frames if not provided
                api_params['n_frames'] = "10"
            
            # Validate and normalize size (optional, enum: "standard" or "high")
            # NOTE: Size affects price significantly (Standard vs High)
            if 'size' in api_params and api_params.get('size'):
                size = str(api_params['size']).strip().lower()
                
                if size not in ["standard", "high"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>standard</b> –∏–ª–∏ <b>high</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['size']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid size for sora-2-pro-text-to-video: {api_params['size']}")
                    return ConversationHandler.END
                api_params['size'] = size
            else:
                # Default size if not provided
                api_params['size'] = "standard"
            
            # Validate and normalize remove_watermark (optional, boolean)
            if 'remove_watermark' in api_params and api_params.get('remove_watermark') is not None:
                remove_watermark = api_params['remove_watermark']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(remove_watermark, str):
                    remove_watermark = remove_watermark.strip().lower()
                    if remove_watermark in ['true', '1', 'yes']:
                        remove_watermark = True
                    elif remove_watermark in ['false', '0', 'no']:
                        remove_watermark = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['remove_watermark']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid remove_watermark for sora-2-pro-text-to-video: {api_params['remove_watermark']}")
                        return ConversationHandler.END
                elif not isinstance(remove_watermark, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(remove_watermark).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid remove_watermark type for sora-2-pro-text-to-video: {type(remove_watermark)}")
                    return ConversationHandler.END
                api_params['remove_watermark'] = remove_watermark
            else:
                # Remove remove_watermark if it's empty or None
                if 'remove_watermark' in api_params:
                    del api_params['remove_watermark']
        
        # For sora-2-pro-image-to-video, validate and normalize parameters
        # NOTE: Price depends on size and n_frames (see calculate_price_rub())
        # Price calculation:
        # Standard: 10s = 150 credits, 15s = 270 credits
        # High: 10s = 330 credits, 15s = 630 credits
        if model_id == "sora-2-pro-image-to-video":
            # Validate prompt (required, string, max 10000 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-image-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for sora-2-pro-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for sora-2-pro-image-to-video")
                return ConversationHandler.END
            
            if len(prompt) > 10000:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 10000 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for sora-2-pro-image-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs, max 1 image)
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_urls if it's a single URL string or list
                    if isinstance(image_input, str):
                        api_params['image_urls'] = [image_input.strip()]
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        api_params['image_urls'] = [str(url).strip() for url in image_input[:1]]  # Take only first
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-image-to-video.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Missing required parameter image_urls for sora-2-pro-image-to-video")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-pro-image-to-video.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Missing required parameter image_urls for sora-2-pro-image-to-video")
                    return ConversationHandler.END
            
            image_urls = api_params['image_urls']
            # Convert single URL string to list
            if isinstance(image_urls, str):
                image_urls = [image_urls]
            
            if not isinstance(image_urls, list):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–ª–∏ –æ–¥–Ω–∏–º URL —Å—Ç—Ä–æ–∫–æ–π.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {type(image_urls).__name__}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_urls type for sora-2-pro-image-to-video: {type(image_urls)}")
                return ConversationHandler.END
            
            if len(image_urls) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_urls array for sora-2-pro-image-to-video")
                return ConversationHandler.END
            
            if len(image_urls) > 1:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –º–∞–∫—Å–∏–º—É–º <b>1</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {len(image_urls)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many image_urls for sora-2-pro-image-to-video: {len(image_urls)}")
                return ConversationHandler.END
            
            # Validate each URL
            validated_image_urls = []
            for i, url in enumerate(image_urls, 1):
                if not isinstance(url, str):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π (URL).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(url).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_url #{i} type for sora-2-pro-image-to-video: {type(url)}")
                    return ConversationHandler.END
                
                url = url.strip()
                if not url:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                        f"–£–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Empty image_url #{i} for sora-2-pro-image-to-video")
                    return ConversationHandler.END
                
                if not (url.startswith('http://') or url.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {url[:50]}..."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_url #{i} format for sora-2-pro-image-to-video: {url}")
                    return ConversationHandler.END
                
                validated_image_urls.append(url)
            
            api_params['image_urls'] = validated_image_urls
            
            # Validate and normalize aspect_ratio (optional, enum: "portrait" or "landscape")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                
                if aspect_ratio not in ["portrait", "landscape"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>portrait</b> –∏–ª–∏ <b>landscape</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for sora-2-pro-image-to-video: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate and normalize n_frames (optional, enum: "10" or "15" seconds)
            # Normalize by removing "s" suffix if present
            if 'n_frames' in api_params and api_params.get('n_frames'):
                n_frames = str(api_params['n_frames']).strip()
                # Remove "s" suffix if present
                if n_frames.lower().endswith('s'):
                    n_frames = n_frames[:-1].strip()
                
                if n_frames not in ["10", "15"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>10</b> –∏–ª–∏ <b>15</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['n_frames']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid n_frames for sora-2-pro-image-to-video: {api_params['n_frames']}")
                    return ConversationHandler.END
                api_params['n_frames'] = n_frames
            else:
                # Default n_frames if not provided
                api_params['n_frames'] = "10"
            
            # Validate and normalize size (optional, enum: "standard" or "high")
            # NOTE: Size affects price significantly (Standard vs High)
            if 'size' in api_params and api_params.get('size'):
                size = str(api_params['size']).strip().lower()
                
                if size not in ["standard", "high"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>standard</b> –∏–ª–∏ <b>high</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['size']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid size for sora-2-pro-image-to-video: {api_params['size']}")
                    return ConversationHandler.END
                api_params['size'] = size
            else:
                # Default size if not provided
                api_params['size'] = "standard"
            
            # Validate and normalize remove_watermark (optional, boolean)
            if 'remove_watermark' in api_params and api_params.get('remove_watermark') is not None:
                remove_watermark = api_params['remove_watermark']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(remove_watermark, str):
                    remove_watermark = remove_watermark.strip().lower()
                    if remove_watermark in ['true', '1', 'yes']:
                        remove_watermark = True
                    elif remove_watermark in ['false', '0', 'no']:
                        remove_watermark = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['remove_watermark']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid remove_watermark for sora-2-pro-image-to-video: {api_params['remove_watermark']}")
                        return ConversationHandler.END
                elif not isinstance(remove_watermark, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(remove_watermark).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid remove_watermark type for sora-2-pro-image-to-video: {type(remove_watermark)}")
                    return ConversationHandler.END
                api_params['remove_watermark'] = remove_watermark
            else:
                # Remove remove_watermark if it's empty or None
                if 'remove_watermark' in api_params:
                    del api_params['remove_watermark']
        
        # For sora-2-text-to-video, validate and normalize parameters
        # NOTE: Price calculation - Fixed at 30 credits per 10-second video (see calculate_price_rub())
        # Price: 30 credits (fixed, doesn't depend on parameters)
        if model_id == "sora-2-text-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-text-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for sora-2-text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for sora-2-text-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize aspect_ratio (optional, enum: "portrait" or "landscape")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                
                if aspect_ratio not in ["portrait", "landscape"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>portrait</b> –∏–ª–∏ <b>landscape</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for sora-2-text-to-video: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate and normalize n_frames (optional, enum: "10" or "15" seconds)
            # Normalize by removing "s" suffix if present
            if 'n_frames' in api_params and api_params.get('n_frames'):
                n_frames = str(api_params['n_frames']).strip()
                # Remove "s" suffix if present
                if n_frames.lower().endswith('s'):
                    n_frames = n_frames[:-1].strip()
                
                if n_frames not in ["10", "15"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>10</b> –∏–ª–∏ <b>15</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['n_frames']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid n_frames for sora-2-text-to-video: {api_params['n_frames']}")
                    return ConversationHandler.END
                api_params['n_frames'] = n_frames
            else:
                # Default n_frames if not provided
                api_params['n_frames'] = "10"
            
            # Validate and normalize remove_watermark (optional, boolean)
            if 'remove_watermark' in api_params and api_params.get('remove_watermark') is not None:
                remove_watermark = api_params['remove_watermark']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(remove_watermark, str):
                    remove_watermark = remove_watermark.strip().lower()
                    if remove_watermark in ['true', '1', 'yes']:
                        remove_watermark = True
                    elif remove_watermark in ['false', '0', 'no']:
                        remove_watermark = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['remove_watermark']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid remove_watermark for sora-2-text-to-video: {api_params['remove_watermark']}")
                        return ConversationHandler.END
                elif not isinstance(remove_watermark, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(remove_watermark).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid remove_watermark type for sora-2-text-to-video: {type(remove_watermark)}")
                    return ConversationHandler.END
                api_params['remove_watermark'] = remove_watermark
            else:
                # Remove remove_watermark if it's empty or None
                if 'remove_watermark' in api_params:
                    del api_params['remove_watermark']
        
        # For sora-2-image-to-video, validate and normalize parameters
        # NOTE: Price calculation - Fixed at 30 credits per 10-second video (see calculate_price_rub())
        # Price: 30 credits (fixed, doesn't depend on parameters)
        if model_id == "sora-2-image-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-image-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for sora-2-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for sora-2-image-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs, max 1 image)
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_urls if it's a single URL string or list
                    if isinstance(image_input, str):
                        api_params['image_urls'] = [image_input.strip()]
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        api_params['image_urls'] = [str(url).strip() for url in image_input[:1]]  # Take only first
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-image-to-video.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Missing required parameter image_urls for sora-2-image-to-video")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ sora-2-image-to-video.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Missing required parameter image_urls for sora-2-image-to-video")
                    return ConversationHandler.END
            
            image_urls = api_params['image_urls']
            # Convert single URL string to list
            if isinstance(image_urls, str):
                image_urls = [image_urls]
            
            if not isinstance(image_urls, list):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–ª–∏ –æ–¥–Ω–∏–º URL —Å—Ç—Ä–æ–∫–æ–π.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {type(image_urls).__name__}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_urls type for sora-2-image-to-video: {type(image_urls)}")
                return ConversationHandler.END
            
            if len(image_urls) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_urls array for sora-2-image-to-video")
                return ConversationHandler.END
            
            if len(image_urls) > 1:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –º–∞–∫—Å–∏–º—É–º <b>1</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {len(image_urls)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many image_urls for sora-2-image-to-video: {len(image_urls)}")
                return ConversationHandler.END
            
            # Validate each URL
            validated_image_urls = []
            for i, url in enumerate(image_urls, 1):
                if not isinstance(url, str):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π (URL).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(url).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_url #{i} type for sora-2-image-to-video: {type(url)}")
                    return ConversationHandler.END
                
                url = url.strip()
                if not url:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                        f"–£–∫–∞–∂–∏—Ç–µ –≤–∞–ª–∏–¥–Ω—ã–π URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Empty image_url #{i} for sora-2-image-to-video")
                    return ConversationHandler.END
                
                if not (url.startswith('http://') or url.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ #{i} –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {url[:50]}..."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_url #{i} format for sora-2-image-to-video: {url}")
                    return ConversationHandler.END
                
                validated_image_urls.append(url)
            
            api_params['image_urls'] = validated_image_urls
            
            # Validate and normalize aspect_ratio (optional, enum: "portrait" or "landscape")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip().lower()
                
                if aspect_ratio not in ["portrait", "landscape"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>portrait</b> –∏–ª–∏ <b>landscape</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for sora-2-image-to-video: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate and normalize n_frames (optional, enum: "10" or "15" seconds)
            # Normalize by removing "s" suffix if present
            if 'n_frames' in api_params and api_params.get('n_frames'):
                n_frames = str(api_params['n_frames']).strip()
                # Remove "s" suffix if present
                if n_frames.lower().endswith('s'):
                    n_frames = n_frames[:-1].strip()
                
                if n_frames not in ["10", "15"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>n_frames</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>10</b> –∏–ª–∏ <b>15</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['n_frames']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid n_frames for sora-2-image-to-video: {api_params['n_frames']}")
                    return ConversationHandler.END
                api_params['n_frames'] = n_frames
            else:
                # Default n_frames if not provided
                api_params['n_frames'] = "10"
            
            # Validate and normalize remove_watermark (optional, boolean)
            if 'remove_watermark' in api_params and api_params.get('remove_watermark') is not None:
                remove_watermark = api_params['remove_watermark']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(remove_watermark, str):
                    remove_watermark = remove_watermark.strip().lower()
                    if remove_watermark in ['true', '1', 'yes']:
                        remove_watermark = True
                    elif remove_watermark in ['false', '0', 'no']:
                        remove_watermark = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['remove_watermark']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid remove_watermark for sora-2-image-to-video: {api_params['remove_watermark']}")
                        return ConversationHandler.END
                elif not isinstance(remove_watermark, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>remove_watermark</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(remove_watermark).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid remove_watermark type for sora-2-image-to-video: {type(remove_watermark)}")
                    return ConversationHandler.END
                api_params['remove_watermark'] = remove_watermark
            else:
                # Remove remove_watermark if it's empty or None
                if 'remove_watermark' in api_params:
                    del api_params['remove_watermark']
        
        # For topaz/image-upscale, validate and normalize parameters
        # NOTE: Price depends on upscale_factor (see calculate_price_rub())
        # Price calculation: 1x = 10 credits, 2x/4x = 20 credits, 8x = 40 credits
        if model_id == "topaz/image-upscale":
            # Validate image_url (required, single URL string)
            # Note: This model uses image_url (singular), not image_urls (plural)
            if 'image_url' not in api_params or not api_params.get('image_url'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_url if it's a single URL string
                    if isinstance(image_input, str):
                        api_params['image_url'] = image_input.strip()
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        # If it's a list, take the first URL
                        api_params['image_url'] = str(image_input[0]).strip()
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ topaz/image-upscale.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–ø—Å–∫–µ–π–ª–∞."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Missing required parameter image_url for topaz/image-upscale")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ topaz/image-upscale.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–ø—Å–∫–µ–π–ª–∞."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Missing required parameter image_url for topaz/image-upscale")
                    return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–ø—Å–∫–µ–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for topaz/image-upscale")
                return ConversationHandler.END
            
            # Basic URL format validation
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for topaz/image-upscale: {image_url}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize upscale_factor (required, enum: "1", "2", "4", or "8")
            # Normalize by removing "x" suffix if present
            if 'upscale_factor' not in api_params or not api_params.get('upscale_factor'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>upscale_factor</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ topaz/image-upscale.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∞–ø—Å–∫–µ–π–ª–∞: <b>1x</b>, <b>2x</b>, <b>4x</b> –∏–ª–∏ <b>8x</b>."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter upscale_factor for topaz/image-upscale")
                return ConversationHandler.END
            
            upscale_factor = str(api_params['upscale_factor']).strip().lower()
            # Remove "x" suffix if present
            if upscale_factor.endswith('x'):
                upscale_factor = upscale_factor[:-1].strip()
            
            if upscale_factor not in ["1", "2", "4", "8"]:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>upscale_factor</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1x</b>, <b>2x</b>, <b>4x</b> –∏–ª–∏ <b>8x</b>.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['upscale_factor']}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid upscale_factor for topaz/image-upscale: {api_params['upscale_factor']}")
                return ConversationHandler.END
            api_params['upscale_factor'] = upscale_factor
        
        # For kling/v2-5-turbo-text-to-video-pro, validate and normalize parameters
        # NOTE: Price depends on duration (see calculate_price_rub())
        # Price calculation: 5s = 42 credits, 10s = 84 credits
        if model_id == "kling/v2-5-turbo-text-to-video-pro":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-5-turbo-text-to-video-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/v2-5-turbo-text-to-video-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/v2-5-turbo-text-to-video-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize duration (optional, enum: "5" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["5", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for kling/v2-5-turbo-text-to-video-pro: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "5"
            
            # Validate and normalize aspect_ratio (optional, enum: "16:9", "9:16", or "1:1")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                
                if aspect_ratio not in ["16:9", "9:16", "1:1"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>16:9</b>, <b>9:16</b> –∏–ª–∏ <b>1:1</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for kling/v2-5-turbo-text-to-video-pro: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize cfg_scale (optional, number)
            # Note: cfg_scale should be a number (float), user might send "0,5" (comma) or "0.5" (dot)
            if 'cfg_scale' in api_params and api_params.get('cfg_scale') is not None:
                cfg_scale = api_params['cfg_scale']
                try:
                    # Convert string to float, handling both comma and dot as decimal separator
                    if isinstance(cfg_scale, str):
                        # Replace comma with dot for European number format
                        cfg_scale_str = cfg_scale.strip().replace(',', '.')
                        cfg_scale = float(cfg_scale_str)
                    elif isinstance(cfg_scale, (int, float)):
                        cfg_scale = float(cfg_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(cfg_scale).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid cfg_scale type for kling/v2-5-turbo-text-to-video-pro: {type(cfg_scale)}")
                        return ConversationHandler.END
                    
                    # Validate range (typically 0-20, but we'll allow any positive number)
                    if cfg_scale < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {cfg_scale}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid cfg_scale value for kling/v2-5-turbo-text-to-video-pro: {cfg_scale}")
                        return ConversationHandler.END
                    
                    api_params['cfg_scale'] = cfg_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('cfg_scale')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid cfg_scale for kling/v2-5-turbo-text-to-video-pro: {api_params.get('cfg_scale')}")
                    return ConversationHandler.END
            else:
                # Remove cfg_scale if it's empty or None
                if 'cfg_scale' in api_params:
                    del api_params['cfg_scale']
        
        # For kling/v2-5-turbo-image-to-video-pro, validate and normalize parameters
        # NOTE: Price depends on duration (see calculate_price_rub())
        # Price calculation: 5s = 42 credits, 10s = 84 credits
        if model_id == "kling/v2-5-turbo-image-to-video-pro":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-5-turbo-image-to-video-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/v2-5-turbo-image-to-video-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/v2-5-turbo-image-to-video-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, single URL string)
            # Note: This model uses image_url (singular), not image_urls (plural)
            if 'image_url' not in api_params or not api_params.get('image_url'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_url if it's a single URL string
                    if isinstance(image_input, str):
                        api_params['image_url'] = image_input.strip()
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        # If it's a list, take the first URL
                        api_params['image_url'] = str(image_input[0]).strip()
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-5-turbo-image-to-video-pro.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Missing required parameter image_url for kling/v2-5-turbo-image-to-video-pro")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v2-5-turbo-image-to-video-pro.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Missing required parameter image_url for kling/v2-5-turbo-image-to-video-pro")
                    return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for kling/v2-5-turbo-image-to-video-pro")
                return ConversationHandler.END
            
            # Basic URL format validation
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for kling/v2-5-turbo-image-to-video-pro: {image_url}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate tail_image_url (optional, single URL string)
            if 'tail_image_url' in api_params and api_params.get('tail_image_url'):
                tail_image_url = str(api_params['tail_image_url']).strip()
                if tail_image_url:
                    # Basic URL format validation
                    if not (tail_image_url.startswith('http://') or tail_image_url.startswith('https://')):
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>tail_image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {tail_image_url[:50]}..."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid tail_image_url format for kling/v2-5-turbo-image-to-video-pro: {tail_image_url}")
                        return ConversationHandler.END
                    api_params['tail_image_url'] = tail_image_url
                else:
                    # Remove tail_image_url if it's empty
                    del api_params['tail_image_url']
            else:
                # Remove tail_image_url if it's empty or None
                if 'tail_image_url' in api_params:
                    del api_params['tail_image_url']
            
            # Validate and normalize duration (optional, enum: "5" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["5", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for kling/v2-5-turbo-image-to-video-pro: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "5"
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize cfg_scale (optional, number)
            # Note: cfg_scale should be a number (float), user might send "0,5" (comma) or "0.5" (dot)
            if 'cfg_scale' in api_params and api_params.get('cfg_scale') is not None:
                cfg_scale = api_params['cfg_scale']
                try:
                    # Convert string to float, handling both comma and dot as decimal separator
                    if isinstance(cfg_scale, str):
                        # Replace comma with dot for European number format
                        cfg_scale_str = cfg_scale.strip().replace(',', '.')
                        cfg_scale = float(cfg_scale_str)
                    elif isinstance(cfg_scale, (int, float)):
                        cfg_scale = float(cfg_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(cfg_scale).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid cfg_scale type for kling/v2-5-turbo-image-to-video-pro: {type(cfg_scale)}")
                        return ConversationHandler.END
                    
                    # Validate range (typically 0-20, but we'll allow any positive number)
                    if cfg_scale < 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {cfg_scale}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid cfg_scale value for kling/v2-5-turbo-image-to-video-pro: {cfg_scale}")
                        return ConversationHandler.END
                    
                    api_params['cfg_scale'] = cfg_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>cfg_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('cfg_scale')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid cfg_scale for kling/v2-5-turbo-image-to-video-pro: {api_params.get('cfg_scale')}")
                    return ConversationHandler.END
            else:
                # Remove cfg_scale if it's empty or None
                if 'cfg_scale' in api_params:
                    del api_params['cfg_scale']
        
        # For wan/2-5-image-to-video, validate and normalize parameters
        # NOTE: Price depends on duration and resolution (see calculate_price_rub())
        # Price calculation: 720p = 12 credits/sec, 1080p = 20 credits/sec
        if model_id == "wan/2-5-image-to-video":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-5-image-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for wan/2-5-image-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for wan/2-5-image-to-video")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, single URL string)
            # Note: This model uses image_url (singular), not image_urls (plural)
            if 'image_url' not in api_params or not api_params.get('image_url'):
                # Check if image_input was provided (common user input name)
                if 'image_input' in api_params and api_params.get('image_input'):
                    image_input = api_params['image_input']
                    # Convert to image_url if it's a single URL string
                    if isinstance(image_input, str):
                        api_params['image_url'] = image_input.strip()
                        del api_params['image_input']
                    elif isinstance(image_input, list) and len(image_input) > 0:
                        # If it's a list, take the first URL
                        api_params['image_url'] = str(image_input[0]).strip()
                        del api_params['image_input']
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-5-image-to-video.\n\n"
                            "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Missing required parameter image_url for wan/2-5-image-to-video")
                        return ConversationHandler.END
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-5-image-to-video.\n\n"
                        "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Missing required parameter image_url for wan/2-5-image-to-video")
                    return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for wan/2-5-image-to-video")
                return ConversationHandler.END
            
            # Basic URL format validation
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for wan/2-5-image-to-video: {image_url}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize duration (optional, enum: "5" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["5", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for wan/2-5-image-to-video: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "5"
            
            # Validate and normalize resolution (optional, enum: "720p" or "1080p")
            # NOTE: Resolution affects price significantly (720p vs 1080p)
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in ["720p", "1080p"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for wan/2-5-image-to-video: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "720p"
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize enable_prompt_expansion (optional, boolean)
            if 'enable_prompt_expansion' in api_params and api_params.get('enable_prompt_expansion') is not None:
                enable_prompt_expansion = api_params['enable_prompt_expansion']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_prompt_expansion, str):
                    enable_prompt_expansion = enable_prompt_expansion.strip().lower()
                    if enable_prompt_expansion in ['true', '1', 'yes']:
                        enable_prompt_expansion = True
                    elif enable_prompt_expansion in ['false', '0', 'no']:
                        enable_prompt_expansion = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_prompt_expansion']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid enable_prompt_expansion for wan/2-5-image-to-video: {api_params['enable_prompt_expansion']}")
                        return ConversationHandler.END
                elif not isinstance(enable_prompt_expansion, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_prompt_expansion).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid enable_prompt_expansion type for wan/2-5-image-to-video: {type(enable_prompt_expansion)}")
                    return ConversationHandler.END
                api_params['enable_prompt_expansion'] = enable_prompt_expansion
            else:
                # Remove enable_prompt_expansion if it's empty or None
                if 'enable_prompt_expansion' in api_params:
                    del api_params['enable_prompt_expansion']
            
            # Validate and normalize seed (optional, number/integer)
            # Note: seed should be an integer, but we'll accept any number and convert to int
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for wan/2-5-image-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for wan/2-5-image-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For wan/2-5-text-to-video, validate and normalize parameters
        # NOTE: Price depends on duration and resolution (see calculate_price_rub())
        # Price calculation: 720p = 12 credits/sec, 1080p = 20 credits/sec
        if model_id == "wan/2-5-text-to-video":
            # Validate prompt (required, string, max 800 characters)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-5-text-to-video.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ (–º–∞–∫—Å. 800 —Å–∏–º–≤–æ–ª–æ–≤)."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for wan/2-5-text-to-video")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ (–º–∞–∫—Å. 800 —Å–∏–º–≤–æ–ª–æ–≤)."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for wan/2-5-text-to-video")
                return ConversationHandler.END
            
            if len(prompt) > 800:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 800 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                    f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"prompt too long for wan/2-5-text-to-video: {len(prompt)} characters")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize duration (optional, enum: "5" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["5", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>5</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for wan/2-5-text-to-video: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "5"
            
            # Validate and normalize aspect_ratio (optional, enum: "16:9", "9:16", or "1:1")
            if 'aspect_ratio' in api_params and api_params.get('aspect_ratio'):
                aspect_ratio = str(api_params['aspect_ratio']).strip()
                
                if aspect_ratio not in ["16:9", "9:16", "1:1"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>aspect_ratio</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>16:9</b>, <b>9:16</b> –∏–ª–∏ <b>1:1</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['aspect_ratio']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid aspect_ratio for wan/2-5-text-to-video: {api_params['aspect_ratio']}")
                    return ConversationHandler.END
                api_params['aspect_ratio'] = aspect_ratio
            else:
                # Remove aspect_ratio if it's empty or None
                if 'aspect_ratio' in api_params:
                    del api_params['aspect_ratio']
            
            # Validate and normalize resolution (optional, enum: "720p" or "1080p")
            # NOTE: Resolution affects price significantly (720p vs 1080p)
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in ["720p", "1080p"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>720p</b> –∏–ª–∏ <b>1080p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for wan/2-5-text-to-video: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "720p"
            
            # Validate negative_prompt (optional, string, max 500 characters)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    if len(negative_prompt) > 500:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>negative_prompt</b> —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 500 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                            f"–¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞: {len(negative_prompt)} —Å–∏–º–≤–æ–ª–æ–≤."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"negative_prompt too long for wan/2-5-text-to-video: {len(negative_prompt)} characters")
                        return ConversationHandler.END
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize enable_prompt_expansion (optional, boolean)
            if 'enable_prompt_expansion' in api_params and api_params.get('enable_prompt_expansion') is not None:
                enable_prompt_expansion = api_params['enable_prompt_expansion']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_prompt_expansion, str):
                    enable_prompt_expansion = enable_prompt_expansion.strip().lower()
                    if enable_prompt_expansion in ['true', '1', 'yes']:
                        enable_prompt_expansion = True
                    elif enable_prompt_expansion in ['false', '0', 'no']:
                        enable_prompt_expansion = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_prompt_expansion']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid enable_prompt_expansion for wan/2-5-text-to-video: {api_params['enable_prompt_expansion']}")
                        return ConversationHandler.END
                elif not isinstance(enable_prompt_expansion, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_prompt_expansion</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_prompt_expansion).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid enable_prompt_expansion type for wan/2-5-text-to-video: {type(enable_prompt_expansion)}")
                    return ConversationHandler.END
                api_params['enable_prompt_expansion'] = enable_prompt_expansion
            else:
                # Remove enable_prompt_expansion if it's empty or None
                if 'enable_prompt_expansion' in api_params:
                    del api_params['enable_prompt_expansion']
            
            # Validate and normalize seed (optional, number/integer)
            # Note: seed should be an integer, but we'll accept any number and convert to int
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for wan/2-5-text-to-video: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for wan/2-5-text-to-video: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For wan/2-2-animate-move, validate and normalize parameters
        # NOTE: Price depends on resolution (see calculate_price_rub())
        # Price calculation: 480p = 6 credits/sec, 580p = 9.5 credits/sec, 720p = 12.5 credits/sec
        # Duration is determined by input video length (up to 30 seconds)
        if model_id == "wan/2-2-animate-move":
            # Validate video_url (required, URL)
            # Note: video_url should already be converted from video_input in the conversion block above
            if 'video_url' not in api_params or not api_params.get('video_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-animate-move.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter video_url for wan/2-2-animate-move")
                return ConversationHandler.END
            
            video_url = str(api_params['video_url']).strip()
            if not video_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty video_url for wan/2-2-animate-move")
                return ConversationHandler.END
            
            # Validate URL format
            if not (video_url.startswith('http://') or video_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {video_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid video_url format for wan/2-2-animate-move: {video_url[:50]}")
                return ConversationHandler.END
            api_params['video_url'] = video_url
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ wan/2-2-animate-move.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for wan/2-2-animate-move")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for wan/2-2-animate-move")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for wan/2-2-animate-move: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize resolution (optional, enum: "480p", "580p", or "720p")
            # NOTE: Resolution affects price significantly (480p vs 580p vs 720p)
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in ["480p", "580p", "720p"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b>, <b>580p</b> –∏–ª–∏ <b>720p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for wan/2-2-animate-move: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "480p"
        
        # For hailuo/02-text-to-video-pro, validate and normalize parameters
        # NOTE: Price is fixed at 57 credits for 6-second 1080p video (see calculate_price_rub())
        if model_id == "hailuo/02-text-to-video-pro":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-text-to-video-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/02-text-to-video-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/02-text-to-video-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize prompt_optimizer (optional, boolean)
            if 'prompt_optimizer' in api_params and api_params.get('prompt_optimizer') is not None:
                prompt_optimizer = api_params['prompt_optimizer']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(prompt_optimizer, str):
                    prompt_optimizer = prompt_optimizer.strip().lower()
                    if prompt_optimizer in ['true', '1', 'yes']:
                        prompt_optimizer = True
                    elif prompt_optimizer in ['false', '0', 'no']:
                        prompt_optimizer = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['prompt_optimizer']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid prompt_optimizer for hailuo/02-text-to-video-pro: {api_params['prompt_optimizer']}")
                        return ConversationHandler.END
                elif not isinstance(prompt_optimizer, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(prompt_optimizer).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid prompt_optimizer type for hailuo/02-text-to-video-pro: {type(prompt_optimizer)}")
                    return ConversationHandler.END
                api_params['prompt_optimizer'] = prompt_optimizer
            else:
                # Remove prompt_optimizer if it's empty or None
                if 'prompt_optimizer' in api_params:
                    del api_params['prompt_optimizer']
        
        # For hailuo/02-image-to-video-pro, validate and normalize parameters
        # NOTE: Price is fixed at 57 credits for 6-second 1080p video (see calculate_price_rub())
        if model_id == "hailuo/02-image-to-video-pro":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-image-to-video-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/02-image-to-video-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/02-image-to-video-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-image-to-video-pro.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for hailuo/02-image-to-video-pro")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for hailuo/02-image-to-video-pro")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for hailuo/02-image-to-video-pro: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate end_image_url (optional, URL)
            if 'end_image_url' in api_params and api_params.get('end_image_url'):
                end_image_url = str(api_params['end_image_url']).strip()
                if end_image_url:
                    # Validate URL format
                    if not (end_image_url.startswith('http://') or end_image_url.startswith('https://')):
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>end_image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {end_image_url[:50]}..."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid end_image_url format for hailuo/02-image-to-video-pro: {end_image_url[:50]}")
                        return ConversationHandler.END
                    api_params['end_image_url'] = end_image_url
                else:
                    # Remove end_image_url if it's empty
                    del api_params['end_image_url']
            else:
                # Remove end_image_url if it's empty or None
                if 'end_image_url' in api_params:
                    del api_params['end_image_url']
            
            # Validate and normalize prompt_optimizer (optional, boolean)
            if 'prompt_optimizer' in api_params and api_params.get('prompt_optimizer') is not None:
                prompt_optimizer = api_params['prompt_optimizer']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(prompt_optimizer, str):
                    prompt_optimizer = prompt_optimizer.strip().lower()
                    if prompt_optimizer in ['true', '1', 'yes']:
                        prompt_optimizer = True
                    elif prompt_optimizer in ['false', '0', 'no']:
                        prompt_optimizer = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['prompt_optimizer']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid prompt_optimizer for hailuo/02-image-to-video-pro: {api_params['prompt_optimizer']}")
                        return ConversationHandler.END
                elif not isinstance(prompt_optimizer, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(prompt_optimizer).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid prompt_optimizer type for hailuo/02-image-to-video-pro: {type(prompt_optimizer)}")
                    return ConversationHandler.END
                api_params['prompt_optimizer'] = prompt_optimizer
            else:
                # Remove prompt_optimizer if it's empty or None
                if 'prompt_optimizer' in api_params:
                    del api_params['prompt_optimizer']
        
        # For hailuo/02-image-to-video-standard, validate and normalize parameters
        # NOTE: Price depends on resolution and duration (see calculate_price_rub())
        # Price calculation: 512P = 2 credits/sec, 768P = 5 credits/sec
        if model_id == "hailuo/02-image-to-video-standard":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-image-to-video-standard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/02-image-to-video-standard")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/02-image-to-video-standard")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-image-to-video-standard.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for hailuo/02-image-to-video-standard")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for hailuo/02-image-to-video-standard")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for hailuo/02-image-to-video-standard: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate end_image_url (optional, URL)
            if 'end_image_url' in api_params and api_params.get('end_image_url'):
                end_image_url = str(api_params['end_image_url']).strip()
                if end_image_url:
                    # Validate URL format
                    if not (end_image_url.startswith('http://') or end_image_url.startswith('https://')):
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>end_image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {end_image_url[:50]}..."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid end_image_url format for hailuo/02-image-to-video-standard: {end_image_url[:50]}")
                        return ConversationHandler.END
                    api_params['end_image_url'] = end_image_url
                else:
                    # Remove end_image_url if it's empty
                    del api_params['end_image_url']
            else:
                # Remove end_image_url if it's empty or None
                if 'end_image_url' in api_params:
                    del api_params['end_image_url']
            
            # Validate and normalize duration (optional, enum: "6" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["6", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>6</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for hailuo/02-image-to-video-standard: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "6"
            
            # Validate and normalize resolution (optional, enum: "512P" or "768P")
            # NOTE: Resolution affects price significantly (512P vs 768P)
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().upper()
                # Ensure "P" suffix (uppercase)
                if not resolution.endswith('P'):
                    resolution = resolution + 'P'
                
                if resolution not in ["512P", "768P"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>512P</b> –∏–ª–∏ <b>768P</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for hailuo/02-image-to-video-standard: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "768P"
            
            # Validate and normalize prompt_optimizer (optional, boolean)
            if 'prompt_optimizer' in api_params and api_params.get('prompt_optimizer') is not None:
                prompt_optimizer = api_params['prompt_optimizer']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(prompt_optimizer, str):
                    prompt_optimizer = prompt_optimizer.strip().lower()
                    if prompt_optimizer in ['true', '1', 'yes']:
                        prompt_optimizer = True
                    elif prompt_optimizer in ['false', '0', 'no']:
                        prompt_optimizer = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['prompt_optimizer']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid prompt_optimizer for hailuo/02-image-to-video-standard: {api_params['prompt_optimizer']}")
                        return ConversationHandler.END
                elif not isinstance(prompt_optimizer, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(prompt_optimizer).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid prompt_optimizer type for hailuo/02-image-to-video-standard: {type(prompt_optimizer)}")
                    return ConversationHandler.END
                api_params['prompt_optimizer'] = prompt_optimizer
            else:
                # Remove prompt_optimizer if it's empty or None
                if 'prompt_optimizer' in api_params:
                    del api_params['prompt_optimizer']
        
        # For hailuo/02-text-to-video-standard, validate and normalize parameters
        # NOTE: Price depends on duration (see calculate_price_rub())
        # Price calculation: 768P = 5 credits/sec (fixed resolution)
        if model_id == "hailuo/02-text-to-video-standard":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ hailuo/02-text-to-video-standard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for hailuo/02-text-to-video-standard")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for hailuo/02-text-to-video-standard")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize duration (optional, enum: "6" or "10" seconds)
            # Normalize by removing "s" or "seconds" suffix if present
            if 'duration' in api_params and api_params.get('duration'):
                duration = str(api_params['duration']).strip().lower()
                # Remove "s" or "seconds" suffix
                if duration.endswith('s'):
                    duration = duration[:-1].strip()
                elif duration.endswith('seconds'):
                    duration = duration[:-7].strip()
                
                if duration not in ["6", "10"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>duration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>6</b> –∏–ª–∏ <b>10</b> —Å–µ–∫—É–Ω–¥.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['duration']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid duration for hailuo/02-text-to-video-standard: {api_params['duration']}")
                    return ConversationHandler.END
                api_params['duration'] = duration
            else:
                # Default duration if not provided
                api_params['duration'] = "6"
            
            # Validate and normalize prompt_optimizer (optional, boolean)
            if 'prompt_optimizer' in api_params and api_params.get('prompt_optimizer') is not None:
                prompt_optimizer = api_params['prompt_optimizer']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(prompt_optimizer, str):
                    prompt_optimizer = prompt_optimizer.strip().lower()
                    if prompt_optimizer in ['true', '1', 'yes']:
                        prompt_optimizer = True
                    elif prompt_optimizer in ['false', '0', 'no']:
                        prompt_optimizer = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['prompt_optimizer']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid prompt_optimizer for hailuo/02-text-to-video-standard: {api_params['prompt_optimizer']}")
                        return ConversationHandler.END
                elif not isinstance(prompt_optimizer, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt_optimizer</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(prompt_optimizer).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid prompt_optimizer type for hailuo/02-text-to-video-standard: {type(prompt_optimizer)}")
                    return ConversationHandler.END
                api_params['prompt_optimizer'] = prompt_optimizer
            else:
                # Remove prompt_optimizer if it's empty or None
                if 'prompt_optimizer' in api_params:
                    del api_params['prompt_optimizer']
        
        # For topaz/video-upscale, validate and normalize parameters
        # NOTE: Price is 12 credits per second (see calculate_price_rub())
        # Duration is determined by input video length
        if model_id == "topaz/video-upscale":
            # Validate video_url (required, URL)
            # Note: video_url should already be converted from video_input in the conversion block above
            if 'video_url' not in api_params or not api_params.get('video_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ topaz/video-upscale.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter video_url for topaz/video-upscale")
                return ConversationHandler.END
            
            video_url = str(api_params['video_url']).strip()
            if not video_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty video_url for topaz/video-upscale")
                return ConversationHandler.END
            
            # Validate URL format
            if not (video_url.startswith('http://') or video_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>video_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {video_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid video_url format for topaz/video-upscale: {video_url[:50]}")
                return ConversationHandler.END
            api_params['video_url'] = video_url
            
            # Validate and normalize upscale_factor (optional, enum: "1", "2", or "4")
            # Normalize by removing "x" suffix if present (e.g., "2x" -> "2")
            if 'upscale_factor' in api_params and api_params.get('upscale_factor'):
                upscale_factor = str(api_params['upscale_factor']).strip().lower()
                # Remove "x" suffix if present
                if upscale_factor.endswith('x'):
                    upscale_factor = upscale_factor[:-1].strip()
                
                if upscale_factor not in ["1", "2", "4"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>upscale_factor</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1</b>, <b>2</b> –∏–ª–∏ <b>4</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['upscale_factor']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid upscale_factor for topaz/video-upscale: {api_params['upscale_factor']}")
                    return ConversationHandler.END
                api_params['upscale_factor'] = upscale_factor
            else:
                # Remove upscale_factor if it's empty or None
                if 'upscale_factor' in api_params:
                    del api_params['upscale_factor']
        
        # For kling/v1-avatar-standard, validate and normalize parameters
        # NOTE: Price is 8 credits per second for 720P, up to 15 seconds (see calculate_price_rub())
        if model_id == "kling/v1-avatar-standard":
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v1-avatar-standard.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for kling/v1-avatar-standard")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for kling/v1-avatar-standard")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for kling/v1-avatar-standard: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate audio_url (required, URL)
            # Note: audio_url should already be converted from audio_input in the conversion block above
            if 'audio_url' not in api_params or not api_params.get('audio_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v1-avatar-standard.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter audio_url for kling/v1-avatar-standard")
                return ConversationHandler.END
            
            audio_url = str(api_params['audio_url']).strip()
            if not audio_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty audio_url for kling/v1-avatar-standard")
                return ConversationHandler.END
            
            # Validate URL format
            if not (audio_url.startswith('http://') or audio_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {audio_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid audio_url format for kling/v1-avatar-standard: {audio_url[:50]}")
                return ConversationHandler.END
            api_params['audio_url'] = audio_url
            
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/v1-avatar-standard.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/v1-avatar-standard")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/v1-avatar-standard")
                return ConversationHandler.END
            api_params['prompt'] = prompt
        
        # For kling/ai-avatar-v1-pro, validate and normalize parameters
        # NOTE: Price is 16 credits per second for 1080P, up to 15 seconds (see calculate_price_rub())
        if model_id == "kling/ai-avatar-v1-pro":
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/ai-avatar-v1-pro.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for kling/ai-avatar-v1-pro: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate audio_url (required, URL)
            # Note: audio_url should already be converted from audio_input in the conversion block above
            if 'audio_url' not in api_params or not api_params.get('audio_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/ai-avatar-v1-pro.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter audio_url for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            
            audio_url = str(api_params['audio_url']).strip()
            if not audio_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty audio_url for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            
            # Validate URL format
            if not (audio_url.startswith('http://') or audio_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {audio_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid audio_url format for kling/ai-avatar-v1-pro: {audio_url[:50]}")
                return ConversationHandler.END
            api_params['audio_url'] = audio_url
            
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ kling/ai-avatar-v1-pro.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for kling/ai-avatar-v1-pro")
                return ConversationHandler.END
            api_params['prompt'] = prompt
        
        # For bytedance/seedream-v4-text-to-image, validate and normalize parameters
        # NOTE: Price is 5 credits per image, depends on max_images (see calculate_price_rub())
        if model_id == "bytedance/seedream-v4-text-to-image":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/seedream-v4-text-to-image.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/seedream-v4-text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/seedream-v4-text-to-image")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize image_size (optional, enum: "Square HD")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                
                if image_size not in ["Square HD"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_size for bytedance/seedream-v4-text-to-image: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Remove image_size if it's empty or None
                if 'image_size' in api_params:
                    del api_params['image_size']
            
            # Validate and normalize image_resolution (optional, enum: "1K", "2K", or "4K")
            if 'image_resolution' in api_params and api_params.get('image_resolution'):
                image_resolution = str(api_params['image_resolution']).strip().upper()
                # Ensure "K" suffix (uppercase)
                if not image_resolution.endswith('K'):
                    # Try to add "K" if it's just a number
                    try:
                        num = int(image_resolution)
                        image_resolution = f"{num}K"
                    except ValueError:
                        pass
                
                if image_resolution not in ["1K", "2K", "4K"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1K</b>, <b>2K</b> –∏–ª–∏ <b>4K</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_resolution']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_resolution for bytedance/seedream-v4-text-to-image: {api_params['image_resolution']}")
                    return ConversationHandler.END
                api_params['image_resolution'] = image_resolution
            else:
                # Remove image_resolution if it's empty or None
                if 'image_resolution' in api_params:
                    del api_params['image_resolution']
            
            # Validate and normalize max_images (optional, integer from 1 to 6)
            # NOTE: max_images affects price significantly (5 credits per image)
            if 'max_images' in api_params and api_params.get('max_images') is not None:
                max_images = api_params['max_images']
                try:
                    # Convert to integer
                    if isinstance(max_images, str):
                        max_images = int(max_images.strip())
                    elif isinstance(max_images, (int, float)):
                        max_images = int(max_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1 –¥–æ 6.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(max_images).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid max_images type for bytedance/seedream-v4-text-to-image: {type(max_images)}")
                        return ConversationHandler.END
                    
                    if max_images < 1 or max_images > 6:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>1</b> –¥–æ <b>6</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {max_images}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid max_images value for bytedance/seedream-v4-text-to-image: {max_images}")
                        return ConversationHandler.END
                    
                    api_params['max_images'] = max_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1 –¥–æ 6.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('max_images')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid max_images for bytedance/seedream-v4-text-to-image: {api_params.get('max_images')}")
                    return ConversationHandler.END
            else:
                # Default max_images if not provided
                api_params['max_images'] = 1
            
            # Validate and normalize seed (optional, number/integer)
            # Note: seed should be an integer, but we'll accept any number and convert to int
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for bytedance/seedream-v4-text-to-image: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for bytedance/seedream-v4-text-to-image: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For bytedance/seedream-v4-edit, validate and normalize parameters
        # NOTE: Price is 5 credits per image, depends on max_images (see calculate_price_rub())
        if model_id == "bytedance/seedream-v4-edit":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/seedream-v4-edit.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/seedream-v4-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/seedream-v4-edit")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs, max 10 images)
            # Note: image_urls should already be converted from image_input in the conversion block above
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/seedream-v4-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ(—è) –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è(–∏–π) –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_urls for bytedance/seedream-v4-edit")
                return ConversationHandler.END
            
            image_urls = api_params['image_urls']
            # Convert single URL string or single-item list to list format
            if isinstance(image_urls, str):
                image_urls = [image_urls]
            elif not isinstance(image_urls, list):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–ª–∏ —Å—Ç—Ä–æ–∫–æ–π URL.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {type(image_urls).__name__}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_urls type for bytedance/seedream-v4-edit: {type(image_urls)}")
                return ConversationHandler.END
            
            if len(image_urls) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_urls for bytedance/seedream-v4-edit")
                return ConversationHandler.END
            
            if len(image_urls) > 10:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∞–∫—Å–∏–º—É–º <b>10</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(image_urls)}."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many image_urls for bytedance/seedream-v4-edit: {len(image_urls)}")
                return ConversationHandler.END
            
            # Validate each URL in the array
            validated_urls = []
            for idx, url in enumerate(image_urls):
                url_str = str(url).strip()
                if not url_str:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è #{idx + 1} –≤ –º–∞—Å—Å–∏–≤–µ <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Empty URL at index {idx} in image_urls for bytedance/seedream-v4-edit")
                    return ConversationHandler.END
                
                if not (url_str.startswith('http://') or url_str.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è #{idx + 1} –≤ –º–∞—Å—Å–∏–≤–µ <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {url_str[:50]}..."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid URL format at index {idx} in image_urls for bytedance/seedream-v4-edit: {url_str[:50]}")
                    return ConversationHandler.END
                
                validated_urls.append(url_str)
            
            api_params['image_urls'] = validated_urls
            
            # Validate and normalize image_size (optional, enum: "Square HD")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                
                if image_size not in ["Square HD"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_size for bytedance/seedream-v4-edit: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Remove image_size if it's empty or None
                if 'image_size' in api_params:
                    del api_params['image_size']
            
            # Validate and normalize image_resolution (optional, enum: "1K", "2K", or "4K")
            if 'image_resolution' in api_params and api_params.get('image_resolution'):
                image_resolution = str(api_params['image_resolution']).strip().upper()
                # Ensure "K" suffix (uppercase)
                if not image_resolution.endswith('K'):
                    # Try to add "K" if it's just a number
                    try:
                        num = int(image_resolution)
                        image_resolution = f"{num}K"
                    except ValueError:
                        pass
                
                if image_resolution not in ["1K", "2K", "4K"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1K</b>, <b>2K</b> –∏–ª–∏ <b>4K</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_resolution']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_resolution for bytedance/seedream-v4-edit: {api_params['image_resolution']}")
                    return ConversationHandler.END
                api_params['image_resolution'] = image_resolution
            else:
                # Remove image_resolution if it's empty or None
                if 'image_resolution' in api_params:
                    del api_params['image_resolution']
            
            # Validate and normalize max_images (optional, integer from 1 to 6)
            # NOTE: max_images affects price significantly (5 credits per image)
            if 'max_images' in api_params and api_params.get('max_images') is not None:
                max_images = api_params['max_images']
                try:
                    # Convert to integer
                    if isinstance(max_images, str):
                        max_images = int(max_images.strip())
                    elif isinstance(max_images, (int, float)):
                        max_images = int(max_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1 –¥–æ 6.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(max_images).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid max_images type for bytedance/seedream-v4-edit: {type(max_images)}")
                        return ConversationHandler.END
                    
                    if max_images < 1 or max_images > 6:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>1</b> –¥–æ <b>6</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {max_images}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid max_images value for bytedance/seedream-v4-edit: {max_images}")
                        return ConversationHandler.END
                    
                    api_params['max_images'] = max_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>max_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1 –¥–æ 6.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('max_images')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid max_images for bytedance/seedream-v4-edit: {api_params.get('max_images')}")
                    return ConversationHandler.END
            else:
                # Default max_images if not provided
                api_params['max_images'] = 1
            
            # Validate and normalize seed (optional, number/integer)
            # Note: seed should be an integer, but we'll accept any number and convert to int
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for bytedance/seedream-v4-edit: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for bytedance/seedream-v4-edit: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For infinitalk/from-audio, validate and normalize parameters
        # NOTE: Price depends on resolution (see calculate_price_rub())
        # Price calculation: 480p = 3 credits/sec, 720p = 12 credits/sec, up to 15 seconds
        if model_id == "infinitalk/from-audio":
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ infinitalk/from-audio.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for infinitalk/from-audio")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for infinitalk/from-audio")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for infinitalk/from-audio: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate audio_url (required, URL)
            # Note: audio_url should already be converted from audio_input in the conversion block above
            if 'audio_url' not in api_params or not api_params.get('audio_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ infinitalk/from-audio.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter audio_url for infinitalk/from-audio")
                return ConversationHandler.END
            
            audio_url = str(api_params['audio_url']).strip()
            if not audio_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty audio_url for infinitalk/from-audio")
                return ConversationHandler.END
            
            # Validate URL format
            if not (audio_url.startswith('http://') or audio_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>audio_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {audio_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid audio_url format for infinitalk/from-audio: {audio_url[:50]}")
                return ConversationHandler.END
            api_params['audio_url'] = audio_url
            
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ infinitalk/from-audio.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for infinitalk/from-audio")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for infinitalk/from-audio")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize resolution (optional, enum: "480p" or "720p")
            # NOTE: Resolution affects price significantly (480p vs 720p)
            if 'resolution' in api_params and api_params.get('resolution'):
                resolution = str(api_params['resolution']).strip().lower()
                # Ensure "p" suffix
                if not resolution.endswith('p'):
                    resolution = resolution + 'p'
                
                if resolution not in ["480p", "720p"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>resolution</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>480p</b> –∏–ª–∏ <b>720p</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['resolution']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid resolution for infinitalk/from-audio: {api_params['resolution']}")
                    return ConversationHandler.END
                api_params['resolution'] = resolution
            else:
                # Default resolution if not provided
                api_params['resolution'] = "480p"
            
            # Validate and normalize seed (optional, integer from 10000 to 1000000)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 10000 –¥–æ 1000000.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for infinitalk/from-audio: {type(seed)}")
                        return ConversationHandler.END
                    
                    if seed < 10000 or seed > 1000000:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>10000</b> –¥–æ <b>1000000</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {seed}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed value for infinitalk/from-audio: {seed}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 10000 –¥–æ 1000000.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for infinitalk/from-audio: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For recraft/remove-background, validate and normalize parameters
        # NOTE: Price is fixed at 1 credit per image (see calculate_price_rub())
        if model_id == "recraft/remove-background":
            # Validate image (required, URL)
            # Note: image should already be converted from image_input in the conversion block above
            if 'image' not in api_params or not api_params.get('image'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ recraft/remove-background.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image for recraft/remove-background")
                return ConversationHandler.END
            
            image = str(api_params['image']).strip()
            if not image:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image for recraft/remove-background")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image.startswith('http://') or image.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image format for recraft/remove-background: {image[:50]}")
                return ConversationHandler.END
            api_params['image'] = image
            # Note: Additional constraints (file size, dimensions, format) are handled by the API
        
        # For recraft/crisp-upscale, validate and normalize parameters
        # NOTE: Price is free and unlimited for users (see calculate_price_rub())
        if model_id == "recraft/crisp-upscale":
            # Validate image (required, URL)
            # Note: image should already be converted from image_input in the conversion block above
            if 'image' not in api_params or not api_params.get('image'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ recraft/crisp-upscale.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–ø—Å–∫–µ–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image for recraft/crisp-upscale")
                return ConversationHandler.END
            
            image = str(api_params['image']).strip()
            if not image:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –∞–ø—Å–∫–µ–π–ª–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image for recraft/crisp-upscale")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image.startswith('http://') or image.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image format for recraft/crisp-upscale: {image[:50]}")
                return ConversationHandler.END
            api_params['image'] = image
            # Note: Additional constraints (file size, dimensions, format) are handled by the API
        
        # For ideogram/v3-reframe, validate and normalize parameters
        # NOTE: Price depends on rendering_speed and num_images (see calculate_price_rub())
        # Price calculation: TURBO = 3.5 credits/image, BALANCED = 7 credits/image, QUALITY = 10 credits/image
        if model_id == "ideogram/v3-reframe":
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/v3-reframe.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ—Ñ—Ä–µ–π–º–∏–Ω–≥–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for ideogram/v3-reframe")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ—Ñ—Ä–µ–π–º–∏–Ω–≥–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for ideogram/v3-reframe")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for ideogram/v3-reframe: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate image_size (required, enum: "Square HD")
            if 'image_size' not in api_params or not api_params.get('image_size'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/v3-reframe.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–ª—è —Ä–µ—Ñ—Ä–µ–π–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_size for ideogram/v3-reframe")
                return ConversationHandler.END
            
            image_size = str(api_params['image_size']).strip()
            if not image_size:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–ª—è —Ä–µ—Ñ—Ä–µ–π–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_size for ideogram/v3-reframe")
                return ConversationHandler.END
            
            if image_size not in ["Square HD"]:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b>.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_size}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_size for ideogram/v3-reframe: {image_size}")
                return ConversationHandler.END
            api_params['image_size'] = image_size
            
            # Validate and normalize rendering_speed (optional, enum: "Turbo", "Balanced", "Quality")
            # Normalize to uppercase: "TURBO", "BALANCED", "QUALITY"
            if 'rendering_speed' in api_params and api_params.get('rendering_speed'):
                rendering_speed = str(api_params['rendering_speed']).strip()
                # Normalize to uppercase
                rendering_speed_upper = rendering_speed.upper()
                
                # Map common variations
                if rendering_speed_upper in ["TURBO", "TURB"]:
                    rendering_speed = "TURBO"
                elif rendering_speed_upper in ["BALANCED", "BALANCE", "BAL"]:
                    rendering_speed = "BALANCED"
                elif rendering_speed_upper in ["QUALITY", "QUAL", "HIGH"]:
                    rendering_speed = "QUALITY"
                else:
                    # Try direct match
                    if rendering_speed_upper not in ["TURBO", "BALANCED", "QUALITY"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>rendering_speed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>Turbo</b>, <b>Balanced</b> –∏–ª–∏ <b>Quality</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['rendering_speed']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid rendering_speed for ideogram/v3-reframe: {api_params['rendering_speed']}")
                        return ConversationHandler.END
                    rendering_speed = rendering_speed_upper
                
                api_params['rendering_speed'] = rendering_speed
            else:
                # Default rendering_speed if not provided
                api_params['rendering_speed'] = "BALANCED"
            
            # Validate and normalize style (optional, enum: "Auto", "General", "Realistic", "Design")
            if 'style' in api_params and api_params.get('style'):
                style = str(api_params['style']).strip()
                
                if style not in ["Auto", "General", "Realistic", "Design"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>style</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>Auto</b>, <b>General</b>, <b>Realistic</b> –∏–ª–∏ <b>Design</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['style']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid style for ideogram/v3-reframe: {api_params['style']}")
                    return ConversationHandler.END
                api_params['style'] = style
            else:
                # Remove style if it's empty or None
                if 'style' in api_params:
                    del api_params['style']
            
            # Validate and normalize num_images (optional, integer, default: 1)
            # NOTE: num_images affects price (price per image * num_images)
            if 'num_images' in api_params and api_params.get('num_images') is not None:
                num_images = api_params['num_images']
                try:
                    # Convert to integer
                    if isinstance(num_images, str):
                        num_images = int(num_images.strip())
                    elif isinstance(num_images, (int, float)):
                        num_images = int(num_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_images).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_images type for ideogram/v3-reframe: {type(num_images)}")
                        return ConversationHandler.END
                    
                    if num_images < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_images}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_images value for ideogram/v3-reframe: {num_images}")
                        return ConversationHandler.END
                    
                    api_params['num_images'] = num_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_images')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid num_images for ideogram/v3-reframe: {api_params.get('num_images')}")
                    return ConversationHandler.END
            else:
                # Default num_images if not provided
                api_params['num_images'] = 1
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for ideogram/v3-reframe: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for ideogram/v3-reframe: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For bytedance/seedream, validate and normalize parameters
        # NOTE: Price is fixed at 3.5 credits per image (see calculate_price_rub())
        if model_id == "bytedance/seedream":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ bytedance/seedream.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for bytedance/seedream")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for bytedance/seedream")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize image_size (optional, enum: "Square HD")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                
                if image_size not in ["Square HD"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {image_size}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_size for bytedance/seedream: {image_size}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Remove image_size if it's empty or None
                if 'image_size' in api_params:
                    del api_params['image_size']
            
            # Validate and normalize guidance_scale (optional, number)
            # Note: guidance_scale can be a float (e.g., 2.5), and may use comma as decimal separator
            if 'guidance_scale' in api_params and api_params.get('guidance_scale') is not None:
                guidance_scale = api_params['guidance_scale']
                try:
                    # Convert to float
                    if isinstance(guidance_scale, str):
                        guidance_scale_str = guidance_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in guidance_scale_str:
                            guidance_scale_str = guidance_scale_str.replace(',', '.')
                        guidance_scale = float(guidance_scale_str)
                    elif isinstance(guidance_scale, (int, float)):
                        guidance_scale = float(guidance_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(guidance_scale).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid guidance_scale type for bytedance/seedream: {type(guidance_scale)}")
                        return ConversationHandler.END
                    
                    # Check if guidance_scale is positive
                    if guidance_scale <= 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {guidance_scale}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid guidance_scale value for bytedance/seedream: {guidance_scale}")
                        return ConversationHandler.END
                    
                    api_params['guidance_scale'] = guidance_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('guidance_scale')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid guidance_scale for bytedance/seedream: {api_params.get('guidance_scale')}")
                    return ConversationHandler.END
            else:
                # Remove guidance_scale if it's empty or None
                if 'guidance_scale' in api_params:
                    del api_params['guidance_scale']
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for bytedance/seedream: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for bytedance/seedream: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid enable_safety_checker for bytedance/seedream: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid enable_safety_checker type for bytedance/seedream: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
        
        # For qwen/text-to-image, validate and normalize parameters
        # NOTE: Price depends on image_size (4 credits per megapixel, see calculate_price_rub())
        if model_id == "qwen/text-to-image":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ qwen/text-to-image.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for qwen/text-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for qwen/text-to-image")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize image_size (optional, enum: "Square HD" -> "square_hd")
            # Note: API expects "square_hd" but form shows "Square HD"
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                # Normalize "Square HD" to "square_hd" for API
                if image_size == "Square HD" or image_size.lower() == "square hd":
                    image_size = "square_hd"
                elif image_size not in ["square", "square_hd", "portrait_4_3", "portrait_16_9", "landscape_4_3", "landscape_16_9"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b> (1024√ó1024).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_size for qwen/text-to-image: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Default image_size if not provided
                api_params['image_size'] = "square_hd"
            
            # Validate and normalize num_inference_steps (optional, integer, default: 30)
            if 'num_inference_steps' in api_params and api_params.get('num_inference_steps') is not None:
                num_inference_steps = api_params['num_inference_steps']
                try:
                    # Convert to integer
                    if isinstance(num_inference_steps, str):
                        num_inference_steps = int(num_inference_steps.strip())
                    elif isinstance(num_inference_steps, (int, float)):
                        num_inference_steps = int(num_inference_steps)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_inference_steps).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_inference_steps type for qwen/text-to-image: {type(num_inference_steps)}")
                        return ConversationHandler.END
                    
                    if num_inference_steps < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_inference_steps}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_inference_steps value for qwen/text-to-image: {num_inference_steps}")
                        return ConversationHandler.END
                    
                    api_params['num_inference_steps'] = num_inference_steps
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_inference_steps')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid num_inference_steps for qwen/text-to-image: {api_params.get('num_inference_steps')}")
                    return ConversationHandler.END
            else:
                # Default num_inference_steps if not provided
                api_params['num_inference_steps'] = 30
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for qwen/text-to-image: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for qwen/text-to-image: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize guidance_scale (optional, number)
            # Note: guidance_scale can be a float (e.g., 2.5), and may use comma as decimal separator
            if 'guidance_scale' in api_params and api_params.get('guidance_scale') is not None:
                guidance_scale = api_params['guidance_scale']
                try:
                    # Convert to float
                    if isinstance(guidance_scale, str):
                        guidance_scale_str = guidance_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in guidance_scale_str:
                            guidance_scale_str = guidance_scale_str.replace(',', '.')
                        guidance_scale = float(guidance_scale_str)
                    elif isinstance(guidance_scale, (int, float)):
                        guidance_scale = float(guidance_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(guidance_scale).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid guidance_scale type for qwen/text-to-image: {type(guidance_scale)}")
                        return ConversationHandler.END
                    
                    # Check if guidance_scale is positive
                    if guidance_scale <= 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {guidance_scale}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid guidance_scale value for qwen/text-to-image: {guidance_scale}")
                        return ConversationHandler.END
                    
                    api_params['guidance_scale'] = guidance_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('guidance_scale')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid guidance_scale for qwen/text-to-image: {api_params.get('guidance_scale')}")
                    return ConversationHandler.END
            else:
                # Remove guidance_scale if it's empty or None
                if 'guidance_scale' in api_params:
                    del api_params['guidance_scale']
            
            # Validate and normalize enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid enable_safety_checker for qwen/text-to-image: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid enable_safety_checker type for qwen/text-to-image: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
            
            # Validate and normalize output_format (optional, enum: "PNG" or "JPEG")
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().upper()
                
                if output_format not in ["PNG", "JPEG"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>output_format</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>PNG</b> –∏–ª–∏ <b>JPEG</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['output_format']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid output_format for qwen/text-to-image: {api_params['output_format']}")
                    return ConversationHandler.END
                api_params['output_format'] = output_format
            else:
                # Remove output_format if it's empty or None
                if 'output_format' in api_params:
                    del api_params['output_format']
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize acceleration (optional, enum: "None", "Regular", "High")
            # Normalize to lowercase: "none", "regular", "high"
            if 'acceleration' in api_params and api_params.get('acceleration'):
                acceleration = str(api_params['acceleration']).strip()
                # Normalize to lowercase
                acceleration_lower = acceleration.lower()
                
                # Map common variations
                if acceleration_lower in ["none", "no", "off", "false"]:
                    acceleration = "none"
                elif acceleration_lower in ["regular", "normal", "standard", "default"]:
                    acceleration = "regular"
                elif acceleration_lower in ["high", "fast", "turbo"]:
                    acceleration = "high"
                else:
                    # Try direct match
                    if acceleration_lower not in ["none", "regular", "high"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>acceleration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>None</b>, <b>Regular</b> –∏–ª–∏ <b>High</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['acceleration']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid acceleration for qwen/text-to-image: {api_params['acceleration']}")
                        return ConversationHandler.END
                    acceleration = acceleration_lower
                
                api_params['acceleration'] = acceleration
            else:
                # Remove acceleration if it's empty or None
                if 'acceleration' in api_params:
                    del api_params['acceleration']
        
        # For qwen/image-to-image, validate and normalize parameters
        # NOTE: Price is fixed at 4 credits per image (see calculate_price_rub())
        if model_id == "qwen/image-to-image":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ qwen/image-to-image.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for qwen/image-to-image")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for qwen/image-to-image")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ qwen/image-to-image.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for qwen/image-to-image")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL —ç—Ç–∞–ª–æ–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for qwen/image-to-image")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for qwen/image-to-image: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize strength (optional, number from 0.0 to 1.0)
            # Note: strength can be a float (e.g., 0.8), and may use comma as decimal separator
            if 'strength' in api_params and api_params.get('strength') is not None:
                strength = api_params['strength']
                try:
                    # Convert to float
                    if isinstance(strength, str):
                        strength_str = strength.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in strength_str:
                            strength_str = strength_str.replace(',', '.')
                        strength = float(strength_str)
                    elif isinstance(strength, (int, float)):
                        strength = float(strength)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0.0 –¥–æ 1.0.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(strength).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid strength type for qwen/image-to-image: {type(strength)}")
                        return ConversationHandler.END
                    
                    # Check if strength is in valid range [0.0, 1.0]
                    if strength < 0.0 or strength > 1.0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>0.0</b> –¥–æ <b>1.0</b>.\n"
                            "1.0 = –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–¥–µ–ª–∞—Ç—å; 0.0 = —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {strength}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid strength value for qwen/image-to-image: {strength}")
                        return ConversationHandler.END
                    
                    api_params['strength'] = strength
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0.0 –¥–æ 1.0.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('strength')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid strength for qwen/image-to-image: {api_params.get('strength')}")
                    return ConversationHandler.END
            else:
                # Remove strength if it's empty or None
                if 'strength' in api_params:
                    del api_params['strength']
            
            # Validate and normalize output_format (optional, enum: "PNG" or "JPEG")
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().upper()
                
                if output_format not in ["PNG", "JPEG"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>output_format</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>PNG</b> –∏–ª–∏ <b>JPEG</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['output_format']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid output_format for qwen/image-to-image: {api_params['output_format']}")
                    return ConversationHandler.END
                api_params['output_format'] = output_format
            else:
                # Remove output_format if it's empty or None
                if 'output_format' in api_params:
                    del api_params['output_format']
            
            # Validate and normalize acceleration (optional, enum: "none", "regular", "high")
            # Normalize to lowercase: "none", "regular", "high"
            if 'acceleration' in api_params and api_params.get('acceleration'):
                acceleration = str(api_params['acceleration']).strip()
                # Normalize to lowercase
                acceleration_lower = acceleration.lower()
                
                # Map common variations
                if acceleration_lower in ["none", "no", "off", "false"]:
                    acceleration = "none"
                elif acceleration_lower in ["regular", "normal", "standard", "default"]:
                    acceleration = "regular"
                elif acceleration_lower in ["high", "fast", "turbo"]:
                    acceleration = "high"
                else:
                    # Try direct match
                    if acceleration_lower not in ["none", "regular", "high"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>acceleration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>None</b>, <b>Regular</b> –∏–ª–∏ <b>High</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['acceleration']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid acceleration for qwen/image-to-image: {api_params['acceleration']}")
                        return ConversationHandler.END
                    acceleration = acceleration_lower
                
                api_params['acceleration'] = acceleration
            else:
                # Remove acceleration if it's empty or None
                if 'acceleration' in api_params:
                    del api_params['acceleration']
            
            # Validate negative_prompt (optional, string)
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Remove negative_prompt if it's empty
                    del api_params['negative_prompt']
            else:
                # Remove negative_prompt if it's empty or None
                if 'negative_prompt' in api_params:
                    del api_params['negative_prompt']
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for qwen/image-to-image: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for qwen/image-to-image: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize num_inference_steps (optional, integer, default: 30)
            if 'num_inference_steps' in api_params and api_params.get('num_inference_steps') is not None:
                num_inference_steps = api_params['num_inference_steps']
                try:
                    # Convert to integer
                    if isinstance(num_inference_steps, str):
                        num_inference_steps = int(num_inference_steps.strip())
                    elif isinstance(num_inference_steps, (int, float)):
                        num_inference_steps = int(num_inference_steps)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_inference_steps).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_inference_steps type for qwen/image-to-image: {type(num_inference_steps)}")
                        return ConversationHandler.END
                    
                    if num_inference_steps < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_inference_steps}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_inference_steps value for qwen/image-to-image: {num_inference_steps}")
                        return ConversationHandler.END
                    
                    api_params['num_inference_steps'] = num_inference_steps
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_inference_steps')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid num_inference_steps for qwen/image-to-image: {api_params.get('num_inference_steps')}")
                    return ConversationHandler.END
            else:
                # Default num_inference_steps if not provided
                api_params['num_inference_steps'] = 30
            
            # Validate and normalize guidance_scale (optional, number)
            # Note: guidance_scale can be a float (e.g., 2.5), and may use comma as decimal separator
            if 'guidance_scale' in api_params and api_params.get('guidance_scale') is not None:
                guidance_scale = api_params['guidance_scale']
                try:
                    # Convert to float
                    if isinstance(guidance_scale, str):
                        guidance_scale_str = guidance_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in guidance_scale_str:
                            guidance_scale_str = guidance_scale_str.replace(',', '.')
                        guidance_scale = float(guidance_scale_str)
                    elif isinstance(guidance_scale, (int, float)):
                        guidance_scale = float(guidance_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(guidance_scale).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid guidance_scale type for qwen/image-to-image: {type(guidance_scale)}")
                        return ConversationHandler.END
                    
                    # Check if guidance_scale is positive
                    if guidance_scale <= 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {guidance_scale}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid guidance_scale value for qwen/image-to-image: {guidance_scale}")
                        return ConversationHandler.END
                    
                    api_params['guidance_scale'] = guidance_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('guidance_scale')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid guidance_scale for qwen/image-to-image: {api_params.get('guidance_scale')}")
                    return ConversationHandler.END
            else:
                # Remove guidance_scale if it's empty or None
                if 'guidance_scale' in api_params:
                    del api_params['guidance_scale']
            
            # Validate and normalize enable_safety_checker (optional, boolean)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid enable_safety_checker for qwen/image-to-image: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid enable_safety_checker type for qwen/image-to-image: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Remove enable_safety_checker if it's empty or None
                # Note: Safety checker is always enabled in Playground, can only be disabled via API
                if 'enable_safety_checker' in api_params:
                    del api_params['enable_safety_checker']
        
        # For qwen/image-edit, validate and normalize parameters
        # NOTE: Price depends on image_size and num_images (‚âà $0.03 per megapixel, see calculate_price_rub())
        if model_id == "qwen/image-edit":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ qwen/image-edit.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for qwen/image-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for qwen/image-edit")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ qwen/image-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for qwen/image-edit")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for qwen/image-edit")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for qwen/image-edit: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate and normalize acceleration (optional, enum: "none", "regular", "high")
            # Normalize to lowercase: "none", "regular", "high"
            if 'acceleration' in api_params and api_params.get('acceleration'):
                acceleration = str(api_params['acceleration']).strip()
                # Normalize to lowercase
                acceleration_lower = acceleration.lower()
                
                # Map common variations
                if acceleration_lower in ["none", "no", "off", "false"]:
                    acceleration = "none"
                elif acceleration_lower in ["regular", "normal", "standard", "default"]:
                    acceleration = "regular"
                elif acceleration_lower in ["high", "fast", "turbo"]:
                    acceleration = "high"
                else:
                    # Try direct match
                    if acceleration_lower not in ["none", "regular", "high"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>acceleration</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>None</b>, <b>Regular</b> –∏–ª–∏ <b>High</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['acceleration']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid acceleration for qwen/image-edit: {api_params['acceleration']}")
                        return ConversationHandler.END
                    acceleration = acceleration_lower
                
                api_params['acceleration'] = acceleration
            else:
                # Default acceleration if not provided
                api_params['acceleration'] = "none"
            
            # Validate and normalize image_size (optional, enum: "Landscape 4:3" -> "landscape_4_3")
            # Note: API expects "landscape_4_3" but form shows "Landscape 4:3"
            valid_image_sizes = {
                "landscape 4:3": "landscape_4_3",
                "landscape_4_3": "landscape_4_3",
                "portrait 4:3": "portrait_4_3",
                "portrait_4_3": "portrait_4_3",
                "square": "square",
                "square_hd": "square_hd"
            }
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                image_size_lower = image_size.lower()
                
                if image_size_lower in valid_image_sizes:
                    api_params['image_size'] = valid_image_sizes[image_size_lower]
                else:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, <b>Landscape 4:3</b>).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_size for qwen/image-edit: {api_params['image_size']}")
                    return ConversationHandler.END
            else:
                # Default image_size if not provided
                api_params['image_size'] = "landscape_4_3"
            
            # Validate and normalize num_inference_steps (optional, integer, default: 30)
            if 'num_inference_steps' in api_params and api_params.get('num_inference_steps') is not None:
                num_inference_steps = api_params['num_inference_steps']
                try:
                    # Convert to integer
                    if isinstance(num_inference_steps, str):
                        num_inference_steps = int(num_inference_steps.strip())
                    elif isinstance(num_inference_steps, (int, float)):
                        num_inference_steps = int(num_inference_steps)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_inference_steps).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_inference_steps type for qwen/image-edit: {type(num_inference_steps)}")
                        return ConversationHandler.END
                    
                    if num_inference_steps < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_inference_steps}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_inference_steps value for qwen/image-edit: {num_inference_steps}")
                        return ConversationHandler.END
                    
                    api_params['num_inference_steps'] = num_inference_steps
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_inference_steps</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_inference_steps')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid num_inference_steps for qwen/image-edit: {api_params.get('num_inference_steps')}")
                    return ConversationHandler.END
            else:
                # Default num_inference_steps if not provided (form shows default 30, but example shows 25)
                api_params['num_inference_steps'] = 30
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for qwen/image-edit: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for qwen/image-edit: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize guidance_scale (optional, number, default: 4)
            # Note: guidance_scale can be a float (e.g., 4.0), and may use comma as decimal separator
            if 'guidance_scale' in api_params and api_params.get('guidance_scale') is not None:
                guidance_scale = api_params['guidance_scale']
                try:
                    # Convert to float
                    if isinstance(guidance_scale, str):
                        guidance_scale_str = guidance_scale.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in guidance_scale_str:
                            guidance_scale_str = guidance_scale_str.replace(',', '.')
                        guidance_scale = float(guidance_scale_str)
                    elif isinstance(guidance_scale, (int, float)):
                        guidance_scale = float(guidance_scale)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(guidance_scale).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid guidance_scale type for qwen/image-edit: {type(guidance_scale)}")
                        return ConversationHandler.END
                    
                    # Check if guidance_scale is positive
                    if guidance_scale <= 0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {guidance_scale}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid guidance_scale value for qwen/image-edit: {guidance_scale}")
                        return ConversationHandler.END
                    
                    api_params['guidance_scale'] = guidance_scale
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>guidance_scale</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('guidance_scale')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid guidance_scale for qwen/image-edit: {api_params.get('guidance_scale')}")
                    return ConversationHandler.END
            else:
                # Default guidance_scale if not provided
                api_params['guidance_scale'] = 4
            
            # Validate and normalize sync_mode (optional, boolean)
            if 'sync_mode' in api_params and api_params.get('sync_mode') is not None:
                sync_mode = api_params['sync_mode']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(sync_mode, str):
                    sync_mode = sync_mode.strip().lower()
                    if sync_mode in ['true', '1', 'yes', 'on']:
                        sync_mode = True
                    elif sync_mode in ['false', '0', 'no', 'off']:
                        sync_mode = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>sync_mode</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['sync_mode']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid sync_mode for qwen/image-edit: {api_params['sync_mode']}")
                        return ConversationHandler.END
                elif not isinstance(sync_mode, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>sync_mode</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(sync_mode).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid sync_mode type for qwen/image-edit: {type(sync_mode)}")
                    return ConversationHandler.END
                api_params['sync_mode'] = sync_mode
            else:
                # Remove sync_mode if it's empty or None
                if 'sync_mode' in api_params:
                    del api_params['sync_mode']
            
            # Validate and normalize num_images (optional, integer, range: 1-4, default: 1)
            if 'num_images' in api_params and api_params.get('num_images') is not None:
                num_images = api_params['num_images']
                try:
                    # Convert to integer
                    if isinstance(num_images, str):
                        num_images = int(num_images.strip())
                    elif isinstance(num_images, (int, float)):
                        num_images = int(num_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º) –æ—Ç 1 –¥–æ 4.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_images).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_images type for qwen/image-edit: {type(num_images)}")
                        return ConversationHandler.END
                    
                    if num_images < 1 or num_images > 4:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>1</b> –¥–æ <b>4</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_images}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_images value for qwen/image-edit: {num_images}")
                        return ConversationHandler.END
                    
                    api_params['num_images'] = num_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º) –æ—Ç 1 –¥–æ 4.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_images')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid num_images for qwen/image-edit: {api_params.get('num_images')}")
                    return ConversationHandler.END
            else:
                # Default num_images if not provided
                api_params['num_images'] = 1
            
            # Validate and normalize enable_safety_checker (optional, boolean, default: true)
            if 'enable_safety_checker' in api_params and api_params.get('enable_safety_checker') is not None:
                enable_safety_checker = api_params['enable_safety_checker']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(enable_safety_checker, str):
                    enable_safety_checker = enable_safety_checker.strip().lower()
                    if enable_safety_checker in ['true', '1', 'yes']:
                        enable_safety_checker = True
                    elif enable_safety_checker in ['false', '0', 'no']:
                        enable_safety_checker = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['enable_safety_checker']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid enable_safety_checker for qwen/image-edit: {api_params['enable_safety_checker']}")
                        return ConversationHandler.END
                elif not isinstance(enable_safety_checker, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>enable_safety_checker</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(enable_safety_checker).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid enable_safety_checker type for qwen/image-edit: {type(enable_safety_checker)}")
                    return ConversationHandler.END
                api_params['enable_safety_checker'] = enable_safety_checker
            else:
                # Default enable_safety_checker if not provided
                api_params['enable_safety_checker'] = True
            
            # Validate and normalize output_format (optional, enum: "PNG" or "JPEG", default: "png")
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().upper()
                
                if output_format not in ["PNG", "JPEG"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>output_format</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>PNG</b> –∏–ª–∏ <b>JPEG</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['output_format']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid output_format for qwen/image-edit: {api_params['output_format']}")
                    return ConversationHandler.END
                api_params['output_format'] = output_format
            else:
                # Default output_format if not provided
                api_params['output_format'] = "png"
            
            # Validate negative_prompt (optional, string, default: " ")
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Use default empty string with space if empty
                    api_params['negative_prompt'] = " "
            else:
                # Default negative_prompt if not provided
                api_params['negative_prompt'] = " "
        
        # For google/nano-banana, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "google/nano-banana":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ google/nano-banana.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for google/nano-banana")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for google/nano-banana")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate and normalize output_format (optional, enum: "PNG" or "JPEG")
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().upper()
                
                if output_format not in ["PNG", "JPEG"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>output_format</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>PNG</b> –∏–ª–∏ <b>JPEG</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['output_format']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid output_format for google/nano-banana: {api_params['output_format']}")
                    return ConversationHandler.END
                api_params['output_format'] = output_format
            else:
                # Remove output_format if it's empty or None
                if 'output_format' in api_params:
                    del api_params['output_format']
            
            # Validate and normalize image_size (optional, enum: "1:1", "9:16", "16:9", "3:4", "4:3", "3:2", "2:3", "5:4", "4:5", "21:9", "auto")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip().lower()
                
                if image_size not in ["1:1", "9:16", "16:9", "3:4", "4:3", "3:2", "2:3", "5:4", "4:5", "21:9", "auto"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1:1</b>, <b>9:16</b>, <b>16:9</b>, <b>3:4</b>, <b>4:3</b>, <b>3:2</b>, <b>2:3</b>, <b>5:4</b>, <b>4:5</b>, <b>21:9</b> –∏–ª–∏ <b>auto</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_size for google/nano-banana: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Remove image_size if it's empty or None
                if 'image_size' in api_params:
                    del api_params['image_size']
        
        # For google/nano-banana-edit, validate and normalize parameters
        # NOTE: Price calculation - Need to check pricing in calculate_price_rub()
        if model_id == "google/nano-banana-edit":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ google/nano-banana-edit.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for google/nano-banana-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for google/nano-banana-edit")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_urls (required, array of URLs, max 10 images)
            # Note: image_urls should already be converted from image_input in the conversion block above
            if 'image_urls' not in api_params or not api_params.get('image_urls'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ google/nano-banana-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ(—è) –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è(–∏–π) –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_urls for google/nano-banana-edit")
                return ConversationHandler.END
            
            image_urls = api_params['image_urls']
            # Convert single URL string or single-item list to list format
            if isinstance(image_urls, str):
                image_urls = [image_urls]
            elif not isinstance(image_urls, list):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–ª–∏ —Å—Ç—Ä–æ–∫–æ–π URL.\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {type(image_urls).__name__}"
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_urls type for google/nano-banana-edit: {type(image_urls)}")
                return ConversationHandler.END
            
            if len(image_urls) == 0:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_urls for google/nano-banana-edit")
                return ConversationHandler.END
            
            if len(image_urls) > 10:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∞–∫—Å–∏–º—É–º <b>10</b> –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(image_urls)}."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Too many image_urls for google/nano-banana-edit: {len(image_urls)}")
                return ConversationHandler.END
            
            # Validate each URL in the array
            validated_urls = []
            for idx, url in enumerate(image_urls):
                url_str = str(url).strip()
                if not url_str:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è #{idx + 1} –≤ –º–∞—Å—Å–∏–≤–µ <b>image_urls</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Empty URL at index {idx} in image_urls for google/nano-banana-edit")
                    return ConversationHandler.END
                
                if not (url_str.startswith('http://') or url_str.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è #{idx + 1} –≤ –º–∞—Å—Å–∏–≤–µ <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {url_str[:50]}..."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid URL format at index {idx} in image_urls for google/nano-banana-edit: {url_str[:50]}")
                    return ConversationHandler.END
                
                validated_urls.append(url_str)
            
            api_params['image_urls'] = validated_urls
            
            # Validate and normalize output_format (optional, enum: "PNG" or "JPEG")
            if 'output_format' in api_params and api_params.get('output_format'):
                output_format = str(api_params['output_format']).strip().upper()
                
                if output_format not in ["PNG", "JPEG"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>output_format</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>PNG</b> –∏–ª–∏ <b>JPEG</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['output_format']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid output_format for google/nano-banana-edit: {api_params['output_format']}")
                    return ConversationHandler.END
                api_params['output_format'] = output_format
            else:
                # Remove output_format if it's empty or None
                if 'output_format' in api_params:
                    del api_params['output_format']
            
            # Validate and normalize image_size (optional, enum: "1:1", "9:16", "16:9", "3:4", "4:3", "3:2", "2:3", "5:4", "4:5", "21:9", "auto")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip().lower()
                
                if image_size not in ["1:1", "9:16", "16:9", "3:4", "4:3", "3:2", "2:3", "5:4", "4:5", "21:9", "auto"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>1:1</b>, <b>9:16</b>, <b>16:9</b>, <b>3:4</b>, <b>4:3</b>, <b>3:2</b>, <b>2:3</b>, <b>5:4</b>, <b>4:5</b>, <b>21:9</b> –∏–ª–∏ <b>auto</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_size for google/nano-banana-edit: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Remove image_size if it's empty or None
                if 'image_size' in api_params:
                    del api_params['image_size']
        
        # For ideogram/character-edit, validate and normalize parameters
        # NOTE: Price depends on rendering_speed and num_images (see calculate_price_rub())
        # Price calculation: TURBO = 12 credits/image, BALANCED = 18 credits/image, QUALITY = 24 credits/image
        if model_id == "ideogram/character-edit":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-edit.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —á–∞—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for ideogram/character-edit")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —á–∞—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for ideogram/character-edit")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for ideogram/character-edit")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for ideogram/character-edit")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for ideogram/character-edit: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate mask_url (required, URL)
            # Note: mask_url should already be converted from mask_input in the conversion block above
            if 'mask_url' not in api_params or not api_params.get('mask_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>mask_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–∞—Å–∫—É –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –º–∞—Å–∫–∏ –¥–ª—è –∏–Ω–ø–µ–π–Ω—Ç–∏–Ω–≥–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter mask_url for ideogram/character-edit")
                return ConversationHandler.END
            
            mask_url = str(api_params['mask_url']).strip()
            if not mask_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>mask_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–∞—Å–∫—É –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –º–∞—Å–∫–∏ –¥–ª—è –∏–Ω–ø–µ–π–Ω—Ç–∏–Ω–≥–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty mask_url for ideogram/character-edit")
                return ConversationHandler.END
            
            # Validate URL format
            if not (mask_url.startswith('http://') or mask_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>mask_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {mask_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid mask_url format for ideogram/character-edit: {mask_url[:50]}")
                return ConversationHandler.END
            api_params['mask_url'] = mask_url
            
            # Validate reference_image_urls (required, array of URLs, max 1 image supported, max 10MB total)
            # Note: reference_image_urls should already be converted from reference_image_input in the conversion block above
            if 'reference_image_urls' not in api_params or not api_params.get('reference_image_urls'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-edit.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ(—è) –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter reference_image_urls for ideogram/character-edit")
                return ConversationHandler.END
            
            reference_image_urls = api_params['reference_image_urls']
            
            # Ensure reference_image_urls is a list
            if not isinstance(reference_image_urls, list):
                # Convert single URL to list
                if isinstance(reference_image_urls, str):
                    reference_image_urls = [reference_image_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(reference_image_urls).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid reference_image_urls type for ideogram/character-edit: {type(reference_image_urls)}")
                    return ConversationHandler.END
            
            # Validate that list has at least 1 item
            if len(reference_image_urls) == 0:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: 0."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty reference_image_urls for ideogram/character-edit")
                return ConversationHandler.END
            
            # Note: Currently only 1 image is supported, rest will be ignored
            # But we allow multiple URLs in the array (API will ignore extras)
            if len(reference_image_urls) > 1:
                logger.warning(f"ideogram/character-edit: Only first image in reference_image_urls will be used, {len(reference_image_urls)} provided")
            
            # Validate each URL is a string and has valid format
            validated_urls = []
            for i, url in enumerate(reference_image_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid reference_image_urls[{i}] for ideogram/character-edit: {url}")
                    return ConversationHandler.END
                
                url = url.strip()
                if not (url.startswith('http://') or url.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏ URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}: {url[:50]}..."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid reference_image_urls[{i}] format for ideogram/character-edit: {url[:50]}")
                    return ConversationHandler.END
                
                validated_urls.append(url)
            
            api_params['reference_image_urls'] = validated_urls
            
            # Validate and normalize rendering_speed (optional, enum: "TURBO", "BALANCED", "QUALITY")
            # Normalize to uppercase: "TURBO", "BALANCED", "QUALITY"
            if 'rendering_speed' in api_params and api_params.get('rendering_speed'):
                rendering_speed = str(api_params['rendering_speed']).strip()
                # Normalize to uppercase
                rendering_speed_upper = rendering_speed.upper()
                
                # Map common variations
                if rendering_speed_upper in ["TURBO", "TURB"]:
                    rendering_speed = "TURBO"
                elif rendering_speed_upper in ["BALANCED", "BALANCE", "BAL"]:
                    rendering_speed = "BALANCED"
                elif rendering_speed_upper in ["QUALITY", "QUAL", "HIGH"]:
                    rendering_speed = "QUALITY"
                else:
                    # Try direct match
                    if rendering_speed_upper not in ["TURBO", "BALANCED", "QUALITY"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>rendering_speed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>TURBO</b>, <b>BALANCED</b> –∏–ª–∏ <b>QUALITY</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['rendering_speed']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid rendering_speed for ideogram/character-edit: {api_params['rendering_speed']}")
                        return ConversationHandler.END
                    rendering_speed = rendering_speed_upper
                
                api_params['rendering_speed'] = rendering_speed
            else:
                # Default rendering_speed if not provided
                api_params['rendering_speed'] = "BALANCED"
            
            # Validate and normalize style (optional, enum: "AUTO", "REALISTIC", "FICTION")
            if 'style' in api_params and api_params.get('style'):
                style = str(api_params['style']).strip().upper()
                
                if style not in ["AUTO", "REALISTIC", "FICTION"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>style</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>AUTO</b>, <b>REALISTIC</b> –∏–ª–∏ <b>FICTION</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['style']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid style for ideogram/character-edit: {api_params['style']}")
                    return ConversationHandler.END
                api_params['style'] = style
            else:
                # Default style if not provided
                api_params['style'] = "AUTO"
            
            # Validate and normalize expand_prompt (optional, boolean, default: true)
            if 'expand_prompt' in api_params and api_params.get('expand_prompt') is not None:
                expand_prompt = api_params['expand_prompt']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(expand_prompt, str):
                    expand_prompt = expand_prompt.strip().lower()
                    if expand_prompt in ['true', '1', 'yes', 'on']:
                        expand_prompt = True
                    elif expand_prompt in ['false', '0', 'no', 'off']:
                        expand_prompt = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['expand_prompt']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid expand_prompt for ideogram/character-edit: {api_params['expand_prompt']}")
                        return ConversationHandler.END
                elif not isinstance(expand_prompt, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(expand_prompt).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid expand_prompt type for ideogram/character-edit: {type(expand_prompt)}")
                    return ConversationHandler.END
                api_params['expand_prompt'] = expand_prompt
            else:
                # Default expand_prompt if not provided
                api_params['expand_prompt'] = True
            
            # Validate and normalize num_images (optional, integer, default: 1)
            # NOTE: num_images affects price (price per image * num_images)
            if 'num_images' in api_params and api_params.get('num_images') is not None:
                num_images = api_params['num_images']
                try:
                    # Convert to integer
                    if isinstance(num_images, str):
                        num_images = int(num_images.strip())
                    elif isinstance(num_images, (int, float)):
                        num_images = int(num_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_images).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_images type for ideogram/character-edit: {type(num_images)}")
                        return ConversationHandler.END
                    
                    if num_images < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_images}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_images value for ideogram/character-edit: {num_images}")
                        return ConversationHandler.END
                    
                    api_params['num_images'] = num_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_images')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid num_images for ideogram/character-edit: {api_params.get('num_images')}")
                    return ConversationHandler.END
            else:
                # Default num_images if not provided
                api_params['num_images'] = 1
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for ideogram/character-edit: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for ideogram/character-edit: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
        
        # For ideogram/character-remix, validate and normalize parameters
        # NOTE: Price depends on rendering_speed and num_images (see calculate_price_rub())
        # Price calculation: TURBO = 12 credits/image, BALANCED = 18 credits/image, QUALITY = 24 credits/image
        if model_id == "ideogram/character-remix":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-remix.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–º–∏–∫—Å–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for ideogram/character-remix")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Ä–µ–º–∏–∫—Å–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for ideogram/character-remix")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate image_url (required, URL)
            # Note: image_url should already be converted from image_input in the conversion block above
            if 'image_url' not in api_params or not api_params.get('image_url'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-remix.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–º–∏–∫—Å–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter image_url for ideogram/character-remix")
                return ConversationHandler.END
            
            image_url = str(api_params['image_url']).strip()
            if not image_url:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–º–∏–∫—Å–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty image_url for ideogram/character-remix")
                return ConversationHandler.END
            
            # Validate URL format
            if not (image_url.startswith('http://') or image_url.startswith('https://')):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_url</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n\n"
                    f"–ü–æ–ª—É—á–µ–Ω–æ: {image_url[:50]}..."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Invalid image_url format for ideogram/character-remix: {image_url[:50]}")
                return ConversationHandler.END
            api_params['image_url'] = image_url
            
            # Validate reference_image_urls (required, array of URLs, max 1 image supported, max 10MB total)
            # Note: reference_image_urls should already be converted from reference_image_input in the conversion block above
            if 'reference_image_urls' not in api_params or not api_params.get('reference_image_urls'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character-remix.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ(—è) –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter reference_image_urls for ideogram/character-remix")
                return ConversationHandler.END
            
            reference_image_urls = api_params['reference_image_urls']
            
            # Ensure reference_image_urls is a list
            if not isinstance(reference_image_urls, list):
                # Convert single URL to list
                if isinstance(reference_image_urls, str):
                    reference_image_urls = [reference_image_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(reference_image_urls).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid reference_image_urls type for ideogram/character-remix: {type(reference_image_urls)}")
                    return ConversationHandler.END
            
            # Validate that list has at least 1 item
            if len(reference_image_urls) == 0:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: 0."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty reference_image_urls for ideogram/character-remix")
                return ConversationHandler.END
            
            # Note: Currently only 1 image is supported, rest will be ignored
            if len(reference_image_urls) > 1:
                logger.warning(f"ideogram/character-remix: Only first image in reference_image_urls will be used, {len(reference_image_urls)} provided")
            
            # Validate each URL is a string and has valid format
            validated_urls = []
            for i, url in enumerate(reference_image_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid reference_image_urls[{i}] for ideogram/character-remix: {url}")
                    return ConversationHandler.END
                
                url = url.strip()
                if not (url.startswith('http://') or url.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏ URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}: {url[:50]}..."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid reference_image_urls[{i}] format for ideogram/character-remix: {url[:50]}")
                    return ConversationHandler.END
                
                validated_urls.append(url)
            
            api_params['reference_image_urls'] = validated_urls
            
            # Validate and normalize rendering_speed (optional, enum: "TURBO", "BALANCED", "QUALITY")
            # Normalize to uppercase: "TURBO", "BALANCED", "QUALITY"
            if 'rendering_speed' in api_params and api_params.get('rendering_speed'):
                rendering_speed = str(api_params['rendering_speed']).strip()
                # Normalize to uppercase
                rendering_speed_upper = rendering_speed.upper()
                
                # Map common variations
                if rendering_speed_upper in ["TURBO", "TURB"]:
                    rendering_speed = "TURBO"
                elif rendering_speed_upper in ["BALANCED", "BALANCE", "BAL"]:
                    rendering_speed = "BALANCED"
                elif rendering_speed_upper in ["QUALITY", "QUAL", "HIGH"]:
                    rendering_speed = "QUALITY"
                else:
                    # Try direct match
                    if rendering_speed_upper not in ["TURBO", "BALANCED", "QUALITY"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>rendering_speed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>TURBO</b>, <b>BALANCED</b> –∏–ª–∏ <b>QUALITY</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['rendering_speed']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid rendering_speed for ideogram/character-remix: {api_params['rendering_speed']}")
                        return ConversationHandler.END
                    rendering_speed = rendering_speed_upper
                
                api_params['rendering_speed'] = rendering_speed
            else:
                # Default rendering_speed if not provided
                api_params['rendering_speed'] = "BALANCED"
            
            # Validate and normalize style (optional, enum: "AUTO", "REALISTIC", "FICTION")
            if 'style' in api_params and api_params.get('style'):
                style = str(api_params['style']).strip().upper()
                
                if style not in ["AUTO", "REALISTIC", "FICTION"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>style</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>AUTO</b>, <b>REALISTIC</b> –∏–ª–∏ <b>FICTION</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['style']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid style for ideogram/character-remix: {api_params['style']}")
                    return ConversationHandler.END
                api_params['style'] = style
            else:
                # Default style if not provided
                api_params['style'] = "AUTO"
            
            # Validate and normalize expand_prompt (optional, boolean, default: true)
            if 'expand_prompt' in api_params and api_params.get('expand_prompt') is not None:
                expand_prompt = api_params['expand_prompt']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(expand_prompt, str):
                    expand_prompt = expand_prompt.strip().lower()
                    if expand_prompt in ['true', '1', 'yes', 'on']:
                        expand_prompt = True
                    elif expand_prompt in ['false', '0', 'no', 'off']:
                        expand_prompt = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['expand_prompt']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid expand_prompt for ideogram/character-remix: {api_params['expand_prompt']}")
                        return ConversationHandler.END
                elif not isinstance(expand_prompt, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(expand_prompt).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid expand_prompt type for ideogram/character-remix: {type(expand_prompt)}")
                    return ConversationHandler.END
                api_params['expand_prompt'] = expand_prompt
            else:
                # Default expand_prompt if not provided
                api_params['expand_prompt'] = True
            
            # Validate and normalize image_size (optional, enum: "Square HD", default: "Square HD")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip()
                
                if image_size not in ["Square HD"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>Square HD</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {image_size}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_size for ideogram/character-remix: {image_size}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Default image_size if not provided
                api_params['image_size'] = "Square HD"
            
            # Validate and normalize num_images (optional, integer, default: 1)
            # NOTE: num_images affects price (price per image * num_images)
            if 'num_images' in api_params and api_params.get('num_images') is not None:
                num_images = api_params['num_images']
                try:
                    # Convert to integer
                    if isinstance(num_images, str):
                        num_images = int(num_images.strip())
                    elif isinstance(num_images, (int, float)):
                        num_images = int(num_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_images).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_images type for ideogram/character-remix: {type(num_images)}")
                        return ConversationHandler.END
                    
                    if num_images < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_images}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_images value for ideogram/character-remix: {num_images}")
                        return ConversationHandler.END
                    
                    api_params['num_images'] = num_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_images')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid num_images for ideogram/character-remix: {api_params.get('num_images')}")
                    return ConversationHandler.END
            else:
                # Default num_images if not provided
                api_params['num_images'] = 1
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for ideogram/character-remix: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for ideogram/character-remix: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate and normalize strength (optional, number from 0.0 to 1.0, default: 0.8)
            # Note: strength can be a float (e.g., 0.8), and may use comma as decimal separator
            if 'strength' in api_params and api_params.get('strength') is not None:
                strength = api_params['strength']
                try:
                    # Convert to float
                    if isinstance(strength, str):
                        strength_str = strength.strip()
                        # Replace comma with dot for decimal separator
                        if ',' in strength_str:
                            strength_str = strength_str.replace(',', '.')
                        strength = float(strength_str)
                    elif isinstance(strength, (int, float)):
                        strength = float(strength)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0.0 –¥–æ 1.0.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(strength).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid strength type for ideogram/character-remix: {type(strength)}")
                        return ConversationHandler.END
                    
                    # Check if strength is in valid range [0.0, 1.0]
                    if strength < 0.0 or strength > 1.0:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç <b>0.0</b> –¥–æ <b>1.0</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {strength}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid strength value for ideogram/character-remix: {strength}")
                        return ConversationHandler.END
                    
                    api_params['strength'] = strength
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>strength</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 0.0 –¥–æ 1.0.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('strength')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid strength for ideogram/character-remix: {api_params.get('strength')}")
                    return ConversationHandler.END
            else:
                # Default strength if not provided
                api_params['strength'] = 0.8
            
            # Validate negative_prompt (optional, string, default: "")
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Use default empty string if empty
                    api_params['negative_prompt'] = ""
            else:
                # Default negative_prompt if not provided
                api_params['negative_prompt'] = ""
            
            # Validate image_urls (optional, array of URLs, max 5 images, max 10MB total)
            # Note: image_urls are style references
            if 'image_urls' in api_params and api_params.get('image_urls'):
                image_urls = api_params['image_urls']
                
                # Ensure image_urls is a list
                if not isinstance(image_urls, list):
                    # Convert single URL to list
                    if isinstance(image_urls, str):
                        image_urls = [image_urls]
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(image_urls).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid image_urls type for ideogram/character-remix: {type(image_urls)}")
                        return ConversationHandler.END
                
                # Validate that list has max 5 items
                if len(image_urls) > 5:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_urls</b> —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–º–∞–∫—Å. 5).\n"
                        f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {len(image_urls)}."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Too many image_urls for ideogram/character-remix: {len(image_urls)}")
                    return ConversationHandler.END
                
                # Validate each URL is a string and has valid format
                validated_urls = []
                for i, url in enumerate(image_urls):
                    if not isinstance(url, str) or not url.strip():
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                            f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid image_urls[{i}] for ideogram/character-remix: {url}")
                        return ConversationHandler.END
                    
                    url = url.strip()
                    if not (url.startswith('http://') or url.startswith('https://')):
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏ URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n"
                            f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}: {url[:50]}..."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid image_urls[{i}] format for ideogram/character-remix: {url[:50]}")
                        return ConversationHandler.END
                    
                    validated_urls.append(url)
                
                api_params['image_urls'] = validated_urls
            else:
                # Remove image_urls if it's empty or None
                if 'image_urls' in api_params:
                    del api_params['image_urls']
            
            # Validate reference_mask_urls (optional, array of URLs, max 1 mask supported, max 10MB total)
            if 'reference_mask_urls' in api_params and api_params.get('reference_mask_urls'):
                reference_mask_urls = api_params['reference_mask_urls']
                
                # Ensure reference_mask_urls is a list
                if not isinstance(reference_mask_urls, list):
                    # Convert single URL to list
                    if isinstance(reference_mask_urls, str):
                        reference_mask_urls = [reference_mask_urls]
                    else:
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_mask_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –º–∞—Å–æ–∫.\n"
                            f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(reference_mask_urls).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid reference_mask_urls type for ideogram/character-remix: {type(reference_mask_urls)}")
                        return ConversationHandler.END
                
                # Note: Currently only 1 mask is supported, rest will be ignored
                if len(reference_mask_urls) > 1:
                    logger.warning(f"ideogram/character-remix: Only first mask in reference_mask_urls will be used, {len(reference_mask_urls)} provided")
                
                # Validate each URL is a string and has valid format
                validated_urls = []
                for i, url in enumerate(reference_mask_urls):
                    if not isinstance(url, str) or not url.strip():
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_mask_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                            f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid reference_mask_urls[{i}] for ideogram/character-remix: {url}")
                        return ConversationHandler.END
                    
                    url = url.strip()
                    if not (url.startswith('http://') or url.startswith('https://')):
                        error_msg = (
                            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_mask_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏ URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n"
                            f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}: {url[:50]}..."
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid reference_mask_urls[{i}] format for ideogram/character-remix: {url[:50]}")
                        return ConversationHandler.END
                    
                    validated_urls.append(url)
                
                api_params['reference_mask_urls'] = validated_urls
            else:
                # Remove reference_mask_urls if it's empty or None
                if 'reference_mask_urls' in api_params:
                    del api_params['reference_mask_urls']
        
        # For ideogram/character, validate and normalize parameters
        # NOTE: Price depends on rendering_speed and num_images (see calculate_price_rub())
        # Price calculation: TURBO = 12 credits/image, BALANCED = 18 credits/image, QUALITY = 24 credits/image
        if model_id == "ideogram/character":
            # Validate prompt (required, string)
            if 'prompt' not in api_params or not api_params.get('prompt'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–º."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter prompt for ideogram/character")
                return ConversationHandler.END
            
            prompt = str(api_params['prompt']).strip()
            if not prompt:
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>prompt</b> –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n\n"
                    "–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–º."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty prompt for ideogram/character")
                return ConversationHandler.END
            api_params['prompt'] = prompt
            
            # Validate reference_image_urls (required, array of URLs, max 1 image supported, max 10MB total)
            # Note: reference_image_urls should already be converted from reference_image_input in the conversion block above
            if 'reference_image_urls' not in api_params or not api_params.get('reference_image_urls'):
                error_msg = (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–æ–¥–µ–ª–∏ ideogram/character.\n\n"
                    "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ(—è) –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Missing required parameter reference_image_urls for ideogram/character")
                return ConversationHandler.END
            
            reference_image_urls = api_params['reference_image_urls']
            
            # Ensure reference_image_urls is a list
            if not isinstance(reference_image_urls, list):
                # Convert single URL to list
                if isinstance(reference_image_urls, str):
                    reference_image_urls = [reference_image_urls]
                else:
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.\n"
                        f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø: {type(reference_image_urls).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid reference_image_urls type for ideogram/character: {type(reference_image_urls)}")
                    return ConversationHandler.END
            
            # Validate that list has at least 1 item
            if len(reference_image_urls) == 0:
                error_msg = (
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>reference_image_urls</b> –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: 0."
                )
                await query.edit_message_text(error_msg, parse_mode='HTML')
                logger.error(f"Empty reference_image_urls for ideogram/character")
                return ConversationHandler.END
            
            # Note: Currently only 1 image is supported, rest will be ignored
            if len(reference_image_urls) > 1:
                logger.warning(f"ideogram/character: Only first image in reference_image_urls will be used, {len(reference_image_urls)} provided")
            
            # Validate each URL is a string and has valid format
            validated_urls = []
            for i, url in enumerate(reference_image_urls):
                if not isinstance(url, str) or not url.strip():
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–µ–ø—É—Å—Ç—ã–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏ (URL).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid reference_image_urls[{i}] for ideogram/character: {url}")
                    return ConversationHandler.END
                
                url = url.strip()
                if not (url.startswith('http://') or url.startswith('https://')):
                    error_msg = (
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        f"–í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ <b>reference_image_urls</b> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏ URL (–Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://).\n"
                        f"–û—à–∏–±–∫–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ {i+1}: {url[:50]}..."
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid reference_image_urls[{i}] format for ideogram/character: {url[:50]}")
                    return ConversationHandler.END
                
                validated_urls.append(url)
            
            api_params['reference_image_urls'] = validated_urls
            
            # Validate and normalize rendering_speed (optional, enum: "TURBO", "BALANCED", "QUALITY")
            # Normalize to uppercase: "TURBO", "BALANCED", "QUALITY"
            if 'rendering_speed' in api_params and api_params.get('rendering_speed'):
                rendering_speed = str(api_params['rendering_speed']).strip()
                # Normalize to uppercase
                rendering_speed_upper = rendering_speed.upper()
                
                # Map common variations
                if rendering_speed_upper in ["TURBO", "TURB"]:
                    rendering_speed = "TURBO"
                elif rendering_speed_upper in ["BALANCED", "BALANCE", "BAL"]:
                    rendering_speed = "BALANCED"
                elif rendering_speed_upper in ["QUALITY", "QUAL", "HIGH"]:
                    rendering_speed = "QUALITY"
                else:
                    # Try direct match
                    if rendering_speed_upper not in ["TURBO", "BALANCED", "QUALITY"]:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>rendering_speed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>TURBO</b>, <b>BALANCED</b> –∏–ª–∏ <b>QUALITY</b>.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['rendering_speed']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid rendering_speed for ideogram/character: {api_params['rendering_speed']}")
                        return ConversationHandler.END
                    rendering_speed = rendering_speed_upper
                
                api_params['rendering_speed'] = rendering_speed
            else:
                # Default rendering_speed if not provided
                api_params['rendering_speed'] = "BALANCED"
            
            # Validate and normalize style (optional, enum: "AUTO", "REALISTIC", "FICTION")
            if 'style' in api_params and api_params.get('style'):
                style = str(api_params['style']).strip().upper()
                
                if style not in ["AUTO", "REALISTIC", "FICTION"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>style</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: <b>AUTO</b>, <b>REALISTIC</b> –∏–ª–∏ <b>FICTION</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['style']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid style for ideogram/character: {api_params['style']}")
                    return ConversationHandler.END
                api_params['style'] = style
            else:
                # Default style if not provided
                api_params['style'] = "AUTO"
            
            # Validate and normalize expand_prompt (optional, boolean, default: true)
            if 'expand_prompt' in api_params and api_params.get('expand_prompt') is not None:
                expand_prompt = api_params['expand_prompt']
                # Convert string "true"/"false" to boolean if needed
                if isinstance(expand_prompt, str):
                    expand_prompt = expand_prompt.strip().lower()
                    if expand_prompt in ['true', '1', 'yes', 'on']:
                        expand_prompt = True
                    elif expand_prompt in ['false', '0', 'no', 'off']:
                        expand_prompt = False
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['expand_prompt']}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid expand_prompt for ideogram/character: {api_params['expand_prompt']}")
                        return ConversationHandler.END
                elif not isinstance(expand_prompt, bool):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>expand_prompt</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å boolean (true/false).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {type(expand_prompt).__name__}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid expand_prompt type for ideogram/character: {type(expand_prompt)}")
                    return ConversationHandler.END
                api_params['expand_prompt'] = expand_prompt
            else:
                # Default expand_prompt if not provided
                api_params['expand_prompt'] = True
            
            # Validate and normalize num_images (optional, integer, default: 1)
            # NOTE: num_images affects price (price per image * num_images)
            if 'num_images' in api_params and api_params.get('num_images') is not None:
                num_images = api_params['num_images']
                try:
                    # Convert to integer
                    if isinstance(num_images, str):
                        num_images = int(num_images.strip())
                    elif isinstance(num_images, (int, float)):
                        num_images = int(num_images)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(num_images).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_images type for ideogram/character: {type(num_images)}")
                        return ConversationHandler.END
                    
                    if num_images < 1:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–º–∏–Ω–∏–º—É–º 1).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {num_images}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid num_images value for ideogram/character: {num_images}")
                        return ConversationHandler.END
                    
                    api_params['num_images'] = num_images
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>num_images</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('num_images')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid num_images for ideogram/character: {api_params.get('num_images')}")
                    return ConversationHandler.END
            else:
                # Default num_images if not provided
                api_params['num_images'] = 1
            
            # Validate and normalize image_size (optional, enum: "square_hd", default: "square_hd")
            if 'image_size' in api_params and api_params.get('image_size'):
                image_size = str(api_params['image_size']).strip().lower()
                
                if image_size not in ["square_hd"]:
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>image_size</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: <b>square_hd</b>.\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params['image_size']}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid image_size for ideogram/character: {api_params['image_size']}")
                    return ConversationHandler.END
                api_params['image_size'] = image_size
            else:
                # Default image_size if not provided
                api_params['image_size'] = "square_hd"
            
            # Validate and normalize seed (optional, number/integer)
            if 'seed' in api_params and api_params.get('seed') is not None:
                seed = api_params['seed']
                try:
                    # Convert to integer
                    if isinstance(seed, str):
                        seed_str = seed.strip()
                        # Remove any decimal part if present
                        if '.' in seed_str:
                            seed_str = seed_str.split('.')[0]
                        seed = int(seed_str)
                    elif isinstance(seed, (int, float)):
                        seed = int(seed)
                    else:
                        error_msg = (
                            "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                            "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                            f"–ü–æ–ª—É—á–µ–Ω–æ: {type(seed).__name__}"
                        )
                        await query.edit_message_text(error_msg, parse_mode='HTML')
                        logger.error(f"Invalid seed type for ideogram/character: {type(seed)}")
                        return ConversationHandler.END
                    
                    api_params['seed'] = seed
                except (ValueError, TypeError):
                    error_msg = (
                        "‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏</b>\n\n"
                        "–ü–∞—Ä–∞–º–µ—Ç—Ä <b>seed</b> –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º (—Ü–µ–ª—ã–º).\n\n"
                        f"–ü–æ–ª—É—á–µ–Ω–æ: {api_params.get('seed')}"
                    )
                    await query.edit_message_text(error_msg, parse_mode='HTML')
                    logger.error(f"Invalid seed for ideogram/character: {api_params.get('seed')}")
                    return ConversationHandler.END
            else:
                # Remove seed if it's empty or None
                if 'seed' in api_params:
                    del api_params['seed']
            
            # Validate negative_prompt (optional, string, default: "")
            if 'negative_prompt' in api_params and api_params.get('negative_prompt'):
                negative_prompt = str(api_params['negative_prompt']).strip()
                if negative_prompt:
                    api_params['negative_prompt'] = negative_prompt
                else:
                    # Use default empty string if empty
                    api_params['negative_prompt'] = ""
            else:
                # Default negative_prompt if not provided
                api_params['negative_prompt'] = ""
            
        # Check video_url validation for sora-watermark-remover (if applicable)
        if model_id == "sora-watermark-remover" and 'video_url' in api_params:
            try:
                session = await get_http_client()
                async with session.head(video_url, allow_redirects=True) as resp:
                    if resp.status not in [200, 301, 302, 303, 307, 308]:
                        logger.warning(f"Video URL returned status {resp.status}: {video_url}")
                        if is_admin_user:
                            await query.edit_message_text(
                                f"‚ö†Ô∏è <b>–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ</b>\n\n"
                                f"URL –≤–∏–¥–µ–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å {resp.status}.\n"
                                f"URL: {video_url[:100]}...\n\n"
                                f"–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ URL –ø—É–±–ª–∏—á–Ω–æ –¥–æ—Å—Ç—É–ø–µ–Ω.",
                                parse_mode='HTML'
                            )
                            return ConversationHandler.END
            except Exception as e:
                logger.warning(f"Could not verify video URL accessibility: {e}")
                # Don't fail if we can't verify, just log warning
        
        # Create task (for async models like z-image) with retry logic
        result = None
        max_retries = 3
        retry_delay = 2
        
        for attempt in range(max_retries):
            result = await kie.create_task(model_id, api_params)
            
            # Log result for debugging (only for admin)
            if is_admin_user:
                logger.info(f"Task creation attempt {attempt + 1}/{max_retries} result: {result}")
            
            if result.get('ok'):
                break
            
            # Check if error is retryable
            error = result.get('error', '').lower()
            is_retryable = any(keyword in error for keyword in ['server exception', 'please again', 'try again', 'timeout', 'temporarily'])
            
            if is_retryable and attempt < max_retries - 1:
                if is_admin_user:
                    await query.edit_message_text(
                        f"‚è≥ <b>–ü–æ–ø—ã—Ç–∫–∞ {attempt + 2}/{max_retries}</b>\n\n"
                        f"–û—à–∏–±–∫–∞ API: {result.get('error', 'Unknown')}\n"
                        f"–ü–æ–≤—Ç–æ—Ä—è—é —á–µ—Ä–µ–∑ {retry_delay} —Å–µ–∫...",
                        parse_mode='HTML'
                    )
                await asyncio.sleep(retry_delay)
                retry_delay *= 2  # Exponential backoff
            else:
                break
        
        if result.get('ok'):
            task_id = result.get('taskId')
            
            # Store task ID for polling
            session['task_id'] = task_id
            session['poll_attempts'] = 0
            session['max_poll_attempts'] = 60  # Poll for up to 5 minutes (60 * 5 seconds)
            session['is_free_generation'] = is_free  # Store if this is a free generation
            
            # Show Task ID only for admin
            if is_admin_user:
                message_text = (
                    f"‚úÖ <b>–ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
                    f"Task ID: <code>{task_id}</code>\n\n"
                    f"‚è≥ –û–∂–∏–¥–∞—é –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏..."
                )
            else:
                message_text = (
                    f"‚úÖ <b>–ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
                    f"‚è≥ –û–∂–∏–¥–∞—é –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏..."
                )
            
            await query.edit_message_text(
                message_text,
                parse_mode='HTML'
            )
            
            # Start polling for task completion
            asyncio.create_task(poll_task_status(update, context, task_id, user_id))
        else:
            error = result.get('error', 'Unknown error')
            error_details = ""
            
            # Add more details for admin
            if is_admin_user:
                error_details = f"\n\nüìã <b>–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n"
                try:
                    params_preview = json.dumps(api_params, indent=2, ensure_ascii=False)
                    # Limit preview length
                    if len(params_preview) > 500:
                        params_preview = params_preview[:500] + "..."
                    error_details += f"<code>{params_preview}</code>"
                except Exception as e:
                    error_details += f"<code>{str(api_params)[:500]}</code>"
                    logger.error(f"Error formatting params for error message: {e}")
            
            # Check if it's a server error
            is_server_error = any(keyword in error.lower() for keyword in ['server exception', 'please again', 'try again'])
            
            keyboard = []
            if is_server_error:
                keyboard.append([InlineKeyboardButton("üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ —Ä–∞–∑", callback_data=f"retry_generate:{model_id}")])
            keyboard.append([InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")])
            
            error_msg = (
                f"‚ùå <b>–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏</b>\n\n"
                f"{error}\n"
                f"{error_details}\n\n"
            )
            
            if is_server_error:
                error_msg += (
                    f"‚ö†Ô∏è <b>–≠—Ç–æ –æ—à–∏–±–∫–∞ API —Å–µ—Ä–≤–µ—Ä–∞ KIE</b>\n\n"
                    f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                    f"‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–∂–∞—Ç—å '–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ —Ä–∞–∑'\n"
                    f"‚Ä¢ –ò–ª–∏ –ø–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞\n"
                    f"‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –≤–∞—à–µ–≥–æ –∞—É–¥–∏–æ-—Ñ–∞–π–ª–∞ –ø–æ URL"
                )
            else:
                error_msg += (
                    f"üí° <b>–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:</b>\n"
                    f"‚Ä¢ –ü—Ä–æ–±–ª–µ–º—ã —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –∑–∞–ø—Ä–æ—Å–∞\n"
                    f"‚Ä¢ –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö\n"
                    f"‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑"
                )
            
            await query.edit_message_text(
                error_msg,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            # Clean up session
            if user_id in user_sessions:
                del user_sessions[user_id]
    
    except Exception as e:
        logger.error(f"Error during generation: {e}", exc_info=True)
        await query.edit_message_text(
            f"‚ùå <b>–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞:</b>\n\n{str(e)}",
            parse_mode='HTML'
        )
        # Clean up session
        if user_id in user_sessions:
            del user_sessions[user_id]
    
    return ConversationHandler.END


async def poll_task_status(update: Update, context: ContextTypes.DEFAULT_TYPE, task_id: str, user_id: int):
    """Poll task status until completion."""
    max_attempts = 60  # 5 minutes max
    attempt = 0
    start_time = asyncio.get_event_loop().time()
    last_status_message = None
    
    while attempt < max_attempts:
        await asyncio.sleep(5)  # Wait 5 seconds between polls
        attempt += 1
        
        try:
            status_result = await kie.get_task_status(task_id)
            
            if not status_result.get('ok'):
                error = status_result.get('error', 'Unknown error')
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text=f"‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞:</b>\n\n{error}",
                    parse_mode='HTML'
                )
                break
            
            state = status_result.get('state')
            
            if state == 'success':
                # Send notification immediately when generation completes
                try:
                    await context.bot.send_message(
                        chat_id=update.effective_chat.id,
                        text="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n‚è≥ –ó–∞–≥—Ä—É–∂–∞—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç...",
                        parse_mode='HTML'
                    )
                except Exception as e:
                    logger.warning(f"Could not send completion notification: {e}")
                
                # Task completed successfully - deduct balance
                # Save session data before cleanup (for "generate again" button)
                saved_session_data = None
                model_id = ''
                params = {}
                if user_id in user_sessions:
                    session = user_sessions[user_id]
                    saved_session_data = {
                        'model_id': session.get('model_id'),
                        'model_info': session.get('model_info'),
                        'params': session.get('params', {}).copy(),
                        'properties': session.get('properties', {}).copy(),
                        'required': session.get('required', []).copy()
                    }
                    
                    # Get price and deduct from balance or limit
                    model_id = session.get('model_id', '')
                    params = session.get('params', {})
                    is_admin_user = get_is_admin(user_id)
                    is_free = session.get('is_free_generation', False)
                    
                    if is_free:
                        # Use free generation
                        if use_free_generation(user_id):
                            price = 0.0
                        else:
                            # Free generation limit reached, treat as paid
                            is_free = False
                            price = calculate_price_rub(model_id, params, is_admin_user)
                    else:
                        price = calculate_price_rub(model_id, params, is_admin_user)
                    
                    if user_id != ADMIN_ID:
                        if is_free:
                            # Free generation - no deduction needed
                            pass
                        elif is_admin_user:
                            # Limited admin - deduct from limit
                            add_admin_spent(user_id, price)
                        else:
                            # Regular user - deduct from balance
                            subtract_user_balance(user_id, price)
                
                # Task completed successfully
                result_json = status_result.get('resultJson', '{}')
                last_message = None
                try:
                    result_data = json.loads(result_json)
                    
                    # Determine if this is a video model
                    is_video_model = model_id in ['sora-2-text-to-video', 'sora-watermark-remover', 'kling-2.6/image-to-video', 'kling-2.6/text-to-video', 'kling/v2-5-turbo-text-to-video-pro', 'kling/v2-5-turbo-image-to-video-pro', 'wan/2-5-image-to-video', 'wan/2-5-text-to-video', 'wan/2-2-animate-move', 'wan/2-2-animate-replace', 'hailuo/02-text-to-video-pro', 'hailuo/02-image-to-video-pro', 'hailuo/02-text-to-video-standard', 'hailuo/02-image-to-video-standard', 'topaz/video-upscale', 'kling/v1-avatar-standard', 'kling/ai-avatar-v1-pro', 'infinitalk/from-audio', 'wan/2-2-a14b-speech-to-video-turbo', 'bytedance/v1-pro-fast-image-to-video', 'kling/v2-1-master-image-to-video', 'kling/v2-1-standard', 'kling/v2-1-pro', 'kling/v2-1-master-text-to-video', 'wan/2-2-a14b-text-to-video-turbo', 'wan/2-2-a14b-image-to-video-turbo']
                    
                    # For sora-2-text-to-video, check remove_watermark parameter
                    if model_id == 'sora-2-text-to-video':
                        remove_watermark = params.get('remove_watermark', True)
                        # If remove_watermark is True, use resultUrls (without watermark)
                        # If False, use resultWaterMarkUrls (with watermark)
                        if remove_watermark:
                            result_urls = result_data.get('resultUrls', [])
                        else:
                            result_urls = result_data.get('resultWaterMarkUrls', [])
                            # Fallback to resultUrls if resultWaterMarkUrls is empty
                            if not result_urls:
                                result_urls = result_data.get('resultUrls', [])
                    else:
                        # For other models, use resultUrls
                        result_urls = result_data.get('resultUrls', [])
                    
                    # Save to history
                    if result_urls and model_id:
                        model_info = saved_session_data.get('model_info', {}) if saved_session_data else {}
                        model_name = model_info.get('name', model_id)
                        save_generation_to_history(
                            user_id=user_id,
                            model_id=model_id,
                            model_name=model_name,
                            params=params.copy(),
                            result_urls=result_urls.copy(),
                            task_id=task_id,
                            price=price,
                            is_free=is_free
                        )
                    
                    # Prepare buttons for last message
                    keyboard = [
                        [InlineKeyboardButton("üìö –ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", callback_data="my_generations")],
                        [InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    if result_urls:
                        # Send media (video or image) directly
                        session_http = await get_http_client()
                        for i, url in enumerate(result_urls[:5]):  # Limit to 5 items
                            try:
                                # Try to download media and send it
                                async with session_http.get(url) as resp:
                                        if resp.status == 200:
                                            media_data = await resp.read()
                                            
                                            # Add buttons only to the last item
                                            is_last = (i == len(result_urls[:5]) - 1)
                                            caption = "‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None
                                            
                                            if is_video_model:
                                                # Send as video
                                                video_file = io.BytesIO(media_data)
                                                video_file.name = f"generated_video_{i+1}.mp4"
                                                
                                                if is_last:
                                                    last_message = await context.bot.send_video(
                                                        chat_id=update.effective_chat.id,
                                                        video=video_file,
                                                        caption=caption,
                                                        reply_markup=reply_markup,
                                                        parse_mode='HTML'
                                                    )
                                                else:
                                                    await context.bot.send_video(
                                                        chat_id=update.effective_chat.id,
                                                        video=video_file,
                                                        caption=caption,
                                                        parse_mode='HTML'
                                                    )
                                            else:
                                                # Send as image
                                                photo_file = io.BytesIO(media_data)
                                                photo_file.name = f"generated_image_{i+1}.png"
                                                
                                                if is_last:
                                                    last_message = await context.bot.send_photo(
                                                        chat_id=update.effective_chat.id,
                                                        photo=photo_file,
                                                        caption=caption,
                                                        reply_markup=reply_markup,
                                                        parse_mode='HTML'
                                                    )
                                                else:
                                                    await context.bot.send_photo(
                                                        chat_id=update.effective_chat.id,
                                                        photo=photo_file,
                                                        caption=caption,
                                                        parse_mode='HTML'
                                                    )
                                        else:
                                            # If download fails, try sending URL directly
                                            if is_video_model:
                                                if i == len(result_urls[:5]) - 1:
                                                    last_message = await context.bot.send_video(
                                                        chat_id=update.effective_chat.id,
                                                        video=url,
                                                        caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                        reply_markup=reply_markup,
                                                        parse_mode='HTML'
                                                    )
                                                else:
                                                    await context.bot.send_video(
                                                        chat_id=update.effective_chat.id,
                                                        video=url,
                                                        caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                        parse_mode='HTML'
                                                    )
                                            else:
                                                if i == len(result_urls[:5]) - 1:
                                                    last_message = await context.bot.send_photo(
                                                        chat_id=update.effective_chat.id,
                                                        photo=url,
                                                        caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                        reply_markup=reply_markup,
                                                        parse_mode='HTML'
                                                    )
                                                else:
                                                    await context.bot.send_photo(
                                                        chat_id=update.effective_chat.id,
                                                        photo=url,
                                                        caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                        parse_mode='HTML'
                                                    )
                            except Exception as e:
                                # If all methods fail, try sending URL directly as last resort
                                media_type = "video" if is_video_model else "photo"
                                logger.warning(f"Failed to send {media_type} {url}: {e}")
                                try:
                                    is_last = (i == len(result_urls[:5]) - 1)
                                    if is_video_model:
                                        if is_last:
                                            last_message = await context.bot.send_video(
                                                chat_id=update.effective_chat.id,
                                                video=url,
                                                caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                reply_markup=reply_markup,
                                                parse_mode='HTML'
                                            )
                                        else:
                                            await context.bot.send_video(
                                                chat_id=update.effective_chat.id,
                                                video=url,
                                                caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                parse_mode='HTML'
                                            )
                                    else:
                                        if is_last:
                                            last_message = await context.bot.send_photo(
                                                chat_id=update.effective_chat.id,
                                                photo=url,
                                                caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                reply_markup=reply_markup,
                                                parse_mode='HTML'
                                            )
                                        else:
                                            await context.bot.send_photo(
                                                chat_id=update.effective_chat.id,
                                                photo=url,
                                                caption="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>" if i == 0 else None,
                                                parse_mode='HTML'
                                            )
                                except Exception as e2:
                                    logger.error(f"Failed to send {media_type} even via URL: {e2}")
                                    # Last resort: send as message
                                    is_last = (i == len(result_urls[:5]) - 1)
                                    media_name = "–í–∏–¥–µ–æ" if is_video_model else "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"
                                    if is_last:
                                        last_message = await context.bot.send_message(
                                            chat_id=update.effective_chat.id,
                                            text=f"‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n{media_name}: {url}",
                                            reply_markup=reply_markup,
                                            parse_mode='HTML'
                                        )
                                    else:
                                        await context.bot.send_message(
                                            chat_id=update.effective_chat.id,
                                            text=f"‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n{media_name}: {url}",
                                            parse_mode='HTML'
                                        )
                    else:
                        last_message = await context.bot.send_message(
                            chat_id=update.effective_chat.id,
                            text="‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤.",
                            reply_markup=reply_markup,
                            parse_mode='HTML'
                        )
                except json.JSONDecodeError:
                    last_message = await context.bot.send_message(
                        chat_id=update.effective_chat.id,
                        text=f"‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n–†–µ–∑—É–ª—å—Ç–∞—Ç: {result_json[:500]}",
                        reply_markup=reply_markup,
                        parse_mode='HTML'
                    )
                
                # Clean up session
                if user_id in user_sessions:
                    del user_sessions[user_id]
                break
            
            elif state == 'fail':
                # Task failed
                fail_msg = status_result.get('failMsg', 'Unknown error')
                fail_code = status_result.get('failCode', '')
                
                error_text = f"‚ùå <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Å –æ—à–∏–±–∫–æ–π</b>\n\n"
                if fail_code:
                    error_text += f"–ö–æ–¥ –æ—à–∏–±–∫–∏: {fail_code}\n"
                error_text += f"–°–æ–æ–±—â–µ–Ω–∏–µ: {fail_msg}"
                
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text=error_text,
                    parse_mode='HTML'
                )
                
                # Clean up session
                if user_id in user_sessions:
                    del user_sessions[user_id]
                break
            
            elif state in ['waiting', 'queuing', 'generating']:
                # Still processing, continue polling
                # Update status every 30 seconds (6 attempts * 5 seconds)
                if attempt % 6 == 0:
                    elapsed_time = int(asyncio.get_event_loop().time() - start_time)
                    minutes = elapsed_time // 60
                    seconds = elapsed_time % 60
                    
                    status_text = f"‚è≥ –°—Ç–∞—Ç—É—Å: <b>{state}</b>\n–û–∂–∏–¥–∞—é –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è..."
                    if minutes > 0:
                        status_text += f"\n‚è± –ü—Ä–æ—à–ª–æ: {minutes} –º–∏–Ω {seconds} —Å–µ–∫"
                    else:
                        status_text += f"\n‚è± –ü—Ä–æ—à–ª–æ: {seconds} —Å–µ–∫"
                    
                    # Edit previous status message if exists, otherwise send new one
                    if last_status_message:
                        try:
                            await context.bot.edit_message_text(
                                chat_id=update.effective_chat.id,
                                message_id=last_status_message,
                                text=status_text,
                                parse_mode='HTML'
                            )
                        except Exception:
                            # If edit fails, send new message
                            msg = await context.bot.send_message(
                                chat_id=update.effective_chat.id,
                                text=status_text,
                                parse_mode='HTML'
                            )
                            last_status_message = msg.message_id
                    else:
                        msg = await context.bot.send_message(
                            chat_id=update.effective_chat.id,
                            text=status_text,
                            parse_mode='HTML'
                        )
                        last_status_message = msg.message_id
                continue
            else:
                # Unknown state
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text=f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å—Ç–∞—Ç—É—Å: {state}\n–ü—Ä–æ–¥–æ–ª–∂–∞—é –æ–∂–∏–¥–∞–Ω–∏–µ...",
                    parse_mode='HTML'
                )
                continue
        
        except Exception as e:
            logger.error(f"Error polling task status: {e}", exc_info=True)
            if attempt >= max_attempts:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text=f"‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.",
                    parse_mode='HTML'
                )
                break
    
    if attempt >= max_attempts:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"‚è∞ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.",
            parse_mode='HTML'
        )


async def check_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Check user balance in rubles."""
    user_id = update.effective_user.id
    is_admin_user = get_is_admin(user_id)
    is_main_admin = (user_id == ADMIN_ID)
    
    # Get user balance
    user_balance = get_user_balance(user_id)
    
    # Check if limited admin
    is_limited_admin = is_admin(user_id) and not is_main_admin
    balance_str = f"{user_balance:.2f}".rstrip('0').rstrip('.')
    
    if is_limited_admin:
        # Limited admin - show limit info
        limit = get_admin_limit(user_id)
        spent = get_admin_spent(user_id)
        remaining = get_admin_remaining(user_id)
        keyboard = [
            [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
        ]
        
        await update.message.reply_text(
            f'üëë <b>–ê–¥–º–∏–Ω —Å –ª–∏–º–∏—Ç–æ–º</b>\n\n'
            f'üí≥ <b>–õ–∏–º–∏—Ç:</b> {limit:.2f} ‚ÇΩ\n'
            f'üí∏ <b>–ü–æ—Ç—Ä–∞—á–µ–Ω–æ:</b> {spent:.2f} ‚ÇΩ\n'
            f'‚úÖ <b>–û—Å—Ç–∞–ª–æ—Å—å:</b> {remaining:.2f} ‚ÇΩ\n\n'
            f'üí∞ <b>–ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:</b> {balance_str} ‚ÇΩ',
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
    elif is_main_admin:
        # Main admin sees both user balance and KIE credits
        try:
            result = await kie.get_credits()
            if result.get('ok'):
                credits = result.get('credits', 0)
                credits_rub = credits * CREDIT_TO_USD * USD_TO_RUB
                credits_rub_str = f"{credits_rub:.2f}".rstrip('0').rstrip('.')
                keyboard = [
                    [InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="topup_balance")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                await update.message.reply_text(
                    f'üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n\n'
                    f'üîß <b>API –±–∞–ª–∞–Ω—Å:</b> {credits_rub_str} ‚ÇΩ\n'
                    f'<i>({credits} –∫—Ä–µ–¥–∏—Ç–æ–≤)</i>',
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            else:
                await update.message.reply_text(
                    f'üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n\n'
                    f'‚ö†Ô∏è API –±–∞–ª–∞–Ω—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω',
                    parse_mode='HTML'
                )
        except Exception as e:
            logger.error(f"Error checking KIE balance: {e}")
            await update.message.reply_text(
                f'üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n\n'
                    f'‚ö†Ô∏è API –±–∞–ª–∞–Ω—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω',
                parse_mode='HTML'
            )
    else:
        # Regular user sees only their balance
        # Check for free generations
        remaining_free = get_user_free_generations_remaining(user_id)
        free_info = ""
        if remaining_free > 0:
            free_info = f"\n\nüéÅ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b> {remaining_free}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å (–º–æ–¥–µ–ª—å Z-Image)"
        
        keyboard = [
            [InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="topup_balance")],
            [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
        ]
        
        await update.message.reply_text(
            f'üí≥ <b>–ë–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ{free_info}\n\n'
            f'–î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞.',
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancel the current operation."""
    user_id = update.effective_user.id
    
    # Handle callback query (button press)
    if update.callback_query:
        query = update.callback_query
        await query.answer("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
        
        # Clean up session
        if user_id in user_sessions:
            del user_sessions[user_id]
        
        try:
            await query.edit_message_text(
                "‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é."
            )
        except Exception as e:
            logger.error(f"Error editing message on cancel: {e}", exc_info=True)
            try:
                await query.message.reply_text("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")
            except:
                pass
        return ConversationHandler.END
    
    # Handle command
    if update.message:
        # Clean up session
        if user_id in user_sessions:
            del user_sessions[user_id]
        
        await update.message.reply_text("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")
        return ConversationHandler.END


# Keep existing handlers
async def search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle search queries."""
    query = ' '.join(context.args) if context.args else ''
    
    if not query:
        await update.message.reply_text('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∑–∞–ø—Ä–æ—Å. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /search [–∑–∞–ø—Ä–æ—Å]')
        return
    
    results = storage.search_entries(query)
    
    if results:
        response = f'–ù–∞–π–¥–µ–Ω–æ {len(results)} —Ä–µ–∑—É–ª—å—Ç–∞—Ç(–æ–≤) –¥–ª—è "{query}":\n\n'
        for i, result in enumerate(results[:5], 1):
            response += f'{i}. {result["content"][:100]}...\n'
    else:
        response = f'–ü–æ –∑–∞–ø—Ä–æ—Å—É "{query}" –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.'
    
    await update.message.reply_text(response)


async def ask(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle questions."""
    question = ' '.join(context.args) if context.args else ''
    
    if not question:
        await update.message.reply_text('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /ask [–≤–æ–ø—Ä–æ—Å]')
        return
    
    results = storage.search_entries(question)
    
    if results:
        response = f'–ü–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É "{question}":\n\n'
        for i, result in enumerate(results[:3], 1):
            response += f'{i}. {result["content"]}\n\n'
    else:
        kie_model = os.getenv('KIE_DEFAULT_MODEL') or os.getenv('KIE_MODEL')
        if kie_model:
            try:
                await update.message.reply_text('ü§î –ò—â—É –æ—Ç–≤–µ—Ç...')
                kie_resp = await kie.invoke_model(kie_model, {'text': question})
                if kie_resp.get('ok'):
                    result = kie_resp.get('result')
                    if isinstance(result, dict) and 'output' in result:
                        output = result['output']
                    else:
                        output = result
                    response = f'–í–æ–ø—Ä–æ—Å: {question}\n\n–û—Ç–≤–µ—Ç:\n{output}'
                else:
                    response = f'–í–æ–ø—Ä–æ—Å: {question}\n\n–û—à–∏–±–∫–∞ API: {kie_resp.get("error")}'
            except Exception as e:
                response = f'–í–æ–ø—Ä–æ—Å: {question}\n\n–û—à–∏–±–∫–∞: {e}'
        else:
            response = f'–ü–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É "{question}" –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.'
    
    await update.message.reply_text(response)


async def add_knowledge(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Add new knowledge."""
    knowledge = ' '.join(context.args) if context.args else ''
    
    if not knowledge:
        await update.message.reply_text('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∑–Ω–∞–Ω–∏–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /add [–∑–Ω–∞–Ω–∏–µ]')
        return
    
    success = storage.add_entry(knowledge, update.effective_user.id)
    
    if success:
        await update.message.reply_text(f'‚úÖ –ó–Ω–∞–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ: "{knowledge[:50]}..."')
    else:
        await update.message.reply_text('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å –∑–Ω–∞–Ω–∏–µ.')


async def pre_checkout_query_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle pre-checkout query for Telegram Stars payments."""
    query = update.pre_checkout_query
    user_id = query.from_user.id
    
    # Verify the payment amount matches what we expect
    # The payload format is: topup_{user_id}_{timestamp}
    payload_parts = query.invoice_payload.split('_')
    
    if len(payload_parts) >= 2 and payload_parts[0] == 'topup':
        # Extract user_id from payload to verify
        payload_user_id = int(payload_parts[1])
        
        if payload_user_id == user_id:
            # Check if user has a pending payment in session
            if user_id in user_sessions and 'topup_amount' in user_sessions[user_id]:
                # Approve the pre-checkout query
                await query.answer(ok=True)
                logger.info(f"Pre-checkout approved for user {user_id}, amount: {query.total_amount} XTR")
            else:
                # Reject if no pending payment
                await query.answer(ok=False, error_message="Payment session expired. Please try again.")
                logger.warning(f"Pre-checkout rejected for user {user_id}: no pending payment")
        else:
            await query.answer(ok=False, error_message="Invalid payment request.")
            logger.warning(f"Pre-checkout rejected for user {user_id}: invalid user_id in payload")
    else:
        await query.answer(ok=False, error_message="Invalid payment payload.")
        logger.warning(f"Pre-checkout rejected for user {user_id}: invalid payload format")


async def successful_payment_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle successful Telegram Stars payment."""
    user_id = update.effective_user.id
    payment = update.message.successful_payment
    
    user_lang = get_user_language(user_id)
    
    # Extract payment info
    payload_parts = payment.invoice_payload.split('_')
    amount_stars = payment.total_amount  # Amount in XTR (Stars)
    
    # Convert stars to rubles using exchange rate 1.6
    # 1 ruble = 1.6 stars, so 1 star = 1/1.6 rubles
    # But we use the amount from session if available (more accurate)
    if user_id in user_sessions and 'topup_amount' in user_sessions[user_id]:
        # Use the amount from session (more accurate - this is the original ruble amount)
        amount_rubles = user_sessions[user_id]['topup_amount']
    else:
        # Fallback: convert stars back to rubles (1 star = 1/1.6 rubles)
        amount_rubles = float(amount_stars) / 1.6
    
    # Add balance to user
    add_user_balance(user_id, amount_rubles)
    
    # Clear payment session
    if user_id in user_sessions:
        del user_sessions[user_id]
    
    # Save payment record
    payments = load_json_file(PAYMENTS_FILE, {})
    payment_id = f"stars_{user_id}_{int(time.time())}"
    payments[payment_id] = {
        'user_id': user_id,
        'amount': amount_rubles,
        'currency': 'RUB',
        'payment_method': 'telegram_stars',
        'stars_amount': amount_stars,
        'timestamp': time.time(),
        'status': 'completed'
    }
    save_json_file(PAYMENTS_FILE, payments)
    
    # Send confirmation message
    balance_str = f"{get_user_balance(user_id):.2f}".rstrip('0').rstrip('.')
    
    if user_lang == 'ru':
        success_text = (
            f'‚úÖ <b>–û–ü–õ–ê–¢–ê –£–°–ü–ï–®–ù–ê!</b> ‚úÖ\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'üí∞ <b>–ó–∞—á–∏—Å–ª–µ–Ω–æ:</b> {amount_rubles:.2f} ‚ÇΩ\n'
            f'‚≠ê <b>–°–ø–æ—Å–æ–±:</b> Telegram Stars ({amount_stars} ‚≠ê)\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n\n'
            f'üéâ –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ä–µ–¥—Å—Ç–≤–∞ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞!'
        )
    else:
        success_text = (
            f'‚úÖ <b>PAYMENT SUCCESSFUL!</b> ‚úÖ\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'üí∞ <b>Added:</b> {amount_rubles:.2f} ‚ÇΩ\n'
            f'‚≠ê <b>Method:</b> Telegram Stars ({amount_stars} ‚≠ê)\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'üí≥ <b>Your balance:</b> {balance_str} ‚ÇΩ\n\n'
            f'üéâ You can now use funds for content generation!'
        )
    
    keyboard = [
        [InlineKeyboardButton("üí∞ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å" if user_lang == 'ru' else "üí∞ Check Balance", callback_data="check_balance")],
        [InlineKeyboardButton("üé® –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é" if user_lang == 'ru' else "üé® Start Generation", callback_data="show_models")],
        [InlineKeyboardButton("‚óÄÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é" if user_lang == 'ru' else "‚óÄÔ∏è Main Menu", callback_data="back_to_menu")]
    ]
    
    await update.message.reply_text(
        success_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='HTML'
    )
    
    logger.info(f"Successful Stars payment for user {user_id}: {amount_rubles} RUB ({amount_stars} stars)")


def main():
    """Start the bot."""
    global storage, kie
    
    # CRITICAL: Start HTTP server FIRST for Render port check
    import threading
    from http.server import HTTPServer, BaseHTTPRequestHandler
    
    class HealthCheckHandler(BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path == '/health' or self.path == '/':
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(b'{"status":"ok","service":"telegram-bot"}')
            else:
                self.send_response(404)
                self.end_headers()
        
        def log_message(self, format, *args):
            pass  # Suppress HTTP server logs
    
    def start_health_server():
        port = int(os.getenv('PORT', 10000))
        try:
            server = HTTPServer(('0.0.0.0', port), HealthCheckHandler)
            logger.info(f"‚úÖ Health check server started on port {port}")
            server.serve_forever()
        except Exception as e:
            logger.error(f"‚ùå Failed to start health server: {e}")
            import traceback
            traceback.print_exc()
    
    # Start health check server IMMEDIATELY in background thread
    health_thread = threading.Thread(target=start_health_server, daemon=True)
    health_thread.start()
    logger.info("üöÄ Health check server thread started")
    
    # Give server time to bind to port (critical for Render)
    # NOTE: time already imported at top level
    time.sleep(2)
    logger.info("‚úÖ Port should be open now")
    
    # Initialize storage and KIE client here (not at import time to avoid blocking)
    if storage is None:
        storage = KnowledgeStorage()
    if kie is None:
        kie = get_client()
    
    if not BOT_TOKEN:
        logger.error("No TELEGRAM_BOT_TOKEN found in environment variables!")
        return
    
    # Verify models are loaded correctly
    categories = get_categories()
    sora_models = [m for m in KIE_MODELS if m['id'] == 'sora-watermark-remover']
    logger.info(f"Bot starting with {len(KIE_MODELS)} models in {len(categories)} categories: {categories}")
    if sora_models:
        logger.info(f"‚úÖ Sora model loaded: {sora_models[0]['name']} ({sora_models[0]['category']})")
    else:
        logger.warning(f"‚ö†Ô∏è  Sora model NOT found! Available models: {[m['id'] for m in KIE_MODELS]}")
    
    # Create the Application
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Create conversation handler for generation
    generation_handler = ConversationHandler(
        entry_points=[
            CommandHandler('generate', start_generation),
            CommandHandler('models', list_models),
            CallbackQueryHandler(button_callback, pattern='^show_models$'),
            CallbackQueryHandler(button_callback, pattern='^category:'),
            CallbackQueryHandler(button_callback, pattern='^all_models$'),
            CallbackQueryHandler(button_callback, pattern='^gen_type:'),
            CallbackQueryHandler(button_callback, pattern='^check_balance$'),
            CallbackQueryHandler(button_callback, pattern='^language_select:'),
            CallbackQueryHandler(button_callback, pattern='^claim_gift$'),
            CallbackQueryHandler(button_callback, pattern='^help_menu$'),
            CallbackQueryHandler(button_callback, pattern='^support_contact$'),
            CallbackQueryHandler(button_callback, pattern='^select_model:'),
            CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
            CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
            CallbackQueryHandler(button_callback, pattern='^admin_search$'),
            CallbackQueryHandler(button_callback, pattern='^admin_add$'),
            CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
            CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
            CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
            CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
            CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
            CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
            CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
            CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
            CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
            CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
            CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
            CallbackQueryHandler(button_callback, pattern='^referral_info$'),
            CallbackQueryHandler(button_callback, pattern='^generate_again$'),
            CallbackQueryHandler(button_callback, pattern='^my_generations$'),
            CallbackQueryHandler(button_callback, pattern='^gen_view:'),
            CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
            CallbackQueryHandler(button_callback, pattern='^gen_history:'),
            CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
            CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
            CallbackQueryHandler(button_callback, pattern='^tutorial_complete$')
        ],
        states={
            SELECTING_MODEL: [
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^show_models$'),
                CallbackQueryHandler(button_callback, pattern='^category:'),
                CallbackQueryHandler(button_callback, pattern='^all_models$'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ],
            CONFIRMING_GENERATION: [
                CallbackQueryHandler(confirm_generation, pattern='^confirm_generate$'),
                CallbackQueryHandler(button_callback, pattern='^retry_generate:'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ],
            INPUTTING_PARAMS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.AUDIO | filters.VOICE | (filters.Document.MimeType("audio/*")), input_parameters),
                CallbackQueryHandler(button_callback, pattern='^set_param:'),
                CallbackQueryHandler(button_callback, pattern='^add_image$'),
                CallbackQueryHandler(button_callback, pattern='^skip_image$'),
                CallbackQueryHandler(button_callback, pattern='^image_done$'),
                CallbackQueryHandler(button_callback, pattern='^add_audio$'),
                CallbackQueryHandler(button_callback, pattern='^skip_audio$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ],
            SELECTING_AMOUNT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^pay_stars:'),
                CallbackQueryHandler(button_callback, pattern='^pay_sbp:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^language_select:'),
                CallbackQueryHandler(button_callback, pattern='^claim_gift$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ],
            WAITING_PAYMENT_SCREENSHOT: [
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ],
            ADMIN_TEST_OCR: [
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ],
            WAITING_BROADCAST_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                MessageHandler(filters.PHOTO, input_parameters),
                CallbackQueryHandler(button_callback, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, pattern='^cancel$')
            ]
        },
        fallbacks=[
            CommandHandler('cancel', cancel),
            CallbackQueryHandler(cancel, pattern='^cancel$')
        ]
    )
    
    # Add handlers
    # Admin commands
    async def admin_payments(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show all payments (admin only)."""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        stats = get_payment_stats()
        payments = stats['payments']
        
        if not payments:
            await update.message.reply_text("üìä <b>–ü–ª–∞—Ç–µ–∂–∏</b>\n\n–ù–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π.", parse_mode='HTML')
            return
        
        # Show last 10 payments
        total_amount = stats['total_amount']
        total_count = stats['total_count']
        total_str = f"{total_amount:.2f}".rstrip('0').rstrip('.')
        
        text = f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π:</b>\n\n"
        text += f"üí∞ <b>–í—Å–µ–≥–æ:</b> {total_str} ‚ÇΩ\n"
        text += f"üìù <b>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ:</b> {total_count}\n\n"
        text += f"<b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∏:</b>\n\n"
        
        import datetime
        for payment in payments[:10]:
            user_id = payment.get('user_id', 0)
            amount = payment.get('amount', 0)
            timestamp = payment.get('timestamp', 0)
            amount_str = f"{amount:.2f}".rstrip('0').rstrip('.')
            
            if timestamp:
                dt = datetime.datetime.fromtimestamp(timestamp)
                date_str = dt.strftime("%d.%m.%Y %H:%M")
            else:
                date_str = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
            
            text += f"üë§ ID: {user_id} | üíµ {amount_str} ‚ÇΩ | üìÖ {date_str}\n"
        
        if total_count > 10:
            text += f"\n... –∏ –µ—â–µ {total_count - 10} –ø–ª–∞—Ç–µ–∂–µ–π"
        
        await update.message.reply_text(text, parse_mode='HTML')
    
    async def admin_block_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Block a user (admin only)."""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /block_user [user_id]")
            return
        
        try:
            user_id = int(context.args[0])
            block_user(user_id)
            await update.message.reply_text(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    async def admin_unblock_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Unblock a user (admin only)."""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /unblock_user [user_id]")
            return
        
        try:
            user_id = int(context.args[0])
            unblock_user(user_id)
            await update.message.reply_text(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    async def admin_user_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Check user balance (admin only)."""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /user_balance [user_id]")
            return
        
        try:
            user_id = int(context.args[0])
            balance = get_user_balance(user_id)
            balance_str = f"{balance:.2f}".rstrip('0').rstrip('.')
            is_blocked = is_user_blocked(user_id)
            blocked_text = "üîí –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω" if is_blocked else "‚úÖ –ê–∫—Ç–∏–≤–µ–Ω"
            
            # Get user payments
            user_payments = get_user_payments(user_id)
            total_paid = sum(p.get('amount', 0) for p in user_payments)
            total_paid_str = f"{total_paid:.2f}".rstrip('0').rstrip('.')
            
            # Check if user is limited admin
            admin_info = ""
            if is_admin(user_id) and user_id != ADMIN_ID:
                limit = get_admin_limit(user_id)
                spent = get_admin_spent(user_id)
                remaining = get_admin_remaining(user_id)
                admin_info = (
                    f"\nüëë <b>–ê–¥–º–∏–Ω —Å –ª–∏–º–∏—Ç–æ–º:</b>\n"
                    f"üí≥ –õ–∏–º–∏—Ç: {limit:.2f} ‚ÇΩ\n"
                    f"üí∏ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ: {spent:.2f} ‚ÇΩ\n"
                    f"‚úÖ –û—Å—Ç–∞–ª–æ—Å—å: {remaining:.2f} ‚ÇΩ"
                )
            
            text = (
                f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {user_id}\n"
                f"üí∞ <b>–ë–∞–ª–∞–Ω—Å:</b> {balance_str} ‚ÇΩ\n"
                f"üíµ <b>–í—Å–µ–≥–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–æ:</b> {total_paid_str} ‚ÇΩ\n"
                f"üìù <b>–ü–ª–∞—Ç–µ–∂–µ–π:</b> {len(user_payments)}\n"
                f"üîê <b>–°—Ç–∞—Ç—É—Å:</b> {blocked_text}"
                f"{admin_info}"
            )
            
            await update.message.reply_text(text, parse_mode='HTML')
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    async def admin_add_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Add admin with 100 rubles limit (main admin only)."""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≥–ª–∞–≤–Ω–æ–º—É –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /add_admin [user_id]\n\n–î–æ–±–∞–≤–ª—è–µ—Ç –∞–¥–º–∏–Ω–∞ —Å –ª–∏–º–∏—Ç–æ–º 100 ‚ÇΩ –Ω–∞ —Ç–µ—Å—Ç—ã.")
            return
        
        try:
            new_admin_id = int(context.args[0])
            
            # Check if already admin
            if new_admin_id == ADMIN_ID:
                await update.message.reply_text("‚ùå –≠—Ç–æ –≥–ª–∞–≤–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä.")
                return
            
            admin_limits = get_admin_limits()
            if str(new_admin_id) in admin_limits:
                await update.message.reply_text(f"‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {new_admin_id} —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º.")
                return
            
            # Add admin with 100 rubles limit
            # NOTE: time already imported at top level
            admin_limits[str(new_admin_id)] = {
                'limit': 100.0,
                'spent': 0.0,
                'added_by': update.effective_user.id,
                'added_at': int(time.time())
            }
            save_admin_limits(admin_limits)
            
            await update.message.reply_text(
                f"‚úÖ <b>–ê–¥–º–∏–Ω –¥–æ–±–∞–≤–ª–µ–Ω!</b>\n\n"
                f"üë§ User ID: {new_admin_id}\n"
                f"üí≥ –õ–∏–º–∏—Ç: 100.00 ‚ÇΩ\n"
                f"üí∏ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ: 0.00 ‚ÇΩ\n"
                f"‚úÖ –û—Å—Ç–∞–ª–æ—Å—å: 100.00 ‚ÇΩ",
                parse_mode='HTML'
            )
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    # Add handlers
    # Add error handler for better debugging
    async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Log the error and send a telegram message to notify the developer."""
        logger.error("Exception while handling an update:", exc_info=context.error)
        
        # Try to send error message to user if update is available
        if update and isinstance(update, Update):
            if update.callback_query:
                try:
                    await update.callback_query.answer(
                        "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start",
                        show_alert=True
                    )
                except:
                    pass
            elif update.message:
                try:
                    await update.message.reply_text(
                        "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start"
                    )
                except:
                    pass
    
    application.add_error_handler(error_handler)
    
    # Add payment handlers for Telegram Stars
    # NOTE: MessageHandler and filters already imported at top level, don't re-import
    from telegram.ext import PreCheckoutQueryHandler
    application.add_handler(PreCheckoutQueryHandler(pre_checkout_query_handler))
    application.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, successful_payment_handler))
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("balance", check_balance))
    application.add_handler(CommandHandler("search", search))
    application.add_handler(CommandHandler("ask", ask))
    application.add_handler(CommandHandler("add", add_knowledge))
    application.add_handler(CommandHandler("payments", admin_payments))
    application.add_handler(CommandHandler("block_user", admin_block_user))
    application.add_handler(CommandHandler("unblock_user", admin_unblock_user))
    application.add_handler(CommandHandler("user_balance", admin_user_balance))
    application.add_handler(CommandHandler("add_admin", admin_add_admin))
    application.add_handler(generation_handler)
    application.add_handler(CommandHandler("models", list_models))
    
    # HTTP server already started at the beginning of main()
    # Run the bot
    logger.info("Bot starting...")
    
    # Wait a bit to let any previous instance finish
    # NOTE: time and asyncio already imported at top level
    import asyncio
    logger.info("Waiting 5 seconds to avoid conflicts with previous instance...")
    time.sleep(5)
    
    # Try to clear pending updates manually before starting
    async def clear_updates():
        try:
            async with application:
                # Delete webhook if exists
                await application.bot.delete_webhook(drop_pending_updates=True)
                logger.info("Cleared webhook and pending updates")
        except Exception as e:
            logger.warning(f"Could not clear updates: {e}")
    
    # Run the clearing in a separate event loop
    try:
        asyncio.run(clear_updates())
    except Exception as e:
        logger.warning(f"Could not clear updates: {e}")
    
    max_retries = 5
    retry_delay = 15
    
    for attempt in range(max_retries):
        try:
            logger.info(f"Attempt {attempt + 1}/{max_retries} to start bot...")
            # Drop pending updates to avoid conflicts with other bot instances
            application.run_polling(
                drop_pending_updates=True
            )
            # If we get here, bot started successfully
            break
        except Exception as e:
            error_msg = str(e)
            if "Conflict" in error_msg or "terminated by other getUpdates" in error_msg:
                if attempt < max_retries - 1:
                    logger.warning(f"‚ö†Ô∏è  Conflict detected! Another bot instance may be running.")
                    logger.info(f"Waiting {retry_delay} seconds before retry {attempt + 2}/{max_retries}...")
                    time.sleep(retry_delay)
                    # Try to clear updates again
                    try:
                        asyncio.run(clear_updates())
                    except:
                        pass
                    retry_delay = min(retry_delay + 5, 30)  # Increase delay but cap at 30s
                    continue
                else:
                    logger.error("‚ùå Conflict: Another bot instance is already running!")
                    logger.error("Please stop the other instance before starting this one.")
                    logger.error("On Render: Check if there are multiple services running with the same bot token.")
                    logger.error("Or wait a few minutes and the old instance should stop automatically.")
                    # Don't raise - let it retry on next deploy
                    time.sleep(60)  # Wait a minute before exiting
                    raise
            else:
                logger.error(f"‚ùå Bot crashed: {e}")
                import traceback
                traceback.print_exc()
                raise


if __name__ == '__main__':
    main()


